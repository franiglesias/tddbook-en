# What is TDD and why should I care about it?

Test Driven Development is a software development methodology in which tests are written in order to guide the structure of production code.

The tests specify -in a formal, executable and exemplified manner- the behaviors that the software we're working on should have, defining small objectives that, after being achieved, allow us to build the software in a progressive, safe and structured way.

Despite we're talking about tests, we're not referring to *Quality Assurance* (from now on: **QA**), even though by working with TDD methodology we achieve the secondary effect of obtaining a unitary test suite that is valid and has the maximum possible coverage. In fact, typically part of the tests created during TDD are unnecessary for a comprehensive battery of regression tests, and therefore end up being removed as new tests make them redundant.

That is to say: both **TDD** and **QA** are based in the utilizations of **tests as tools**, but this use is different in several aspects. Specifically, in TDD:

* Tests are written before the software that they execute even exists.
* The tests are very small and their objective is to force writing the minimum amount of production code needed to pass the test, which has the effect of implementing the behavior defined by the test.
* The tests guide the development of the code, and the process contributes to the design of the system.

In TDD, the tests are defined as executable *specifications* of the behavior of a given unit of software, while in QA, tests are tools for verification of that same behavior.
Put in simpler words:

* When we do QA, we try to verify that the software that we've written behaves according to the defined requirements.
* When we do TDD, we write software to fulfill the defined requirements, one by one, so that we end up with a product that complies with them.

## The Test Driven Development methodology

Although we will expand on this topic in depth throughout the book, we will briefly present the essentials of the methodology.

In TDD, tests are written in a way that we could think of as a **dialogue** with production code. This dialogue, the rules that regulate it, and the cycles that are generated by this way of interacting with code will be practiced in the first kata of the book: [FizzBuzz](#fizzbuzz).

Basically, it consists in:
* Writing a test that fails
* Writing code that makes the test pass
* Improving the code's (and the test's) structure

### Writing a test that fails

Once we are clear about the piece of software which we're going to work on and the functionality that we want to implement, the first thing to do is to define a very small first test that will fail hopelessly because the file containing the production code that it needs to run doesn't even exist. While this is something that we'll deal with in all of the kata, in the [NIF](#nif) kata we will delve into strategies that will help us to decide on the first tests.

Here's an example in Go:

```go
// roman/roman_test.go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s",
			 1,
			 "I", 
			 roman
		 )
	}
}
```

Although we can predict that the test won't even be able to be compiled or interpreted, we'll try to run it nonetheless. In TDD it's fundamental to **see the tests fail**, assuming it isn't enough. Our job is making the test fail for the right reason, and then making it pass by writing production code.

```
# tddbook-go/roman [tddbook-go/roman.test]
./roman_test.go:6:11: undefined: decToRoman

Compilation finished with exit code 2
```

The error message will indicate us what to do next. Our short-term goal is to make that error message disappear, as well as those that might come after, one by one.

```go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s",
			1,
			"I",
			roman
		)
	}
}

func decToRoman(decimal int) string {
	
}
```

For instance, after introducing the `decToRoman` function, the error will change. Now it's telling us that it should return a value:

```
# tddbook-go/roman [tddbook-go/roman.test]
./roman_test.go:16:1: missing return at end of function

Compilation finished with exit code 2
```

It could even happen that we get an unexpected message, such as that we've tried to load the `Book` class and it turns out that we had mistakingly created a filled named `brok`. That's why it's so important to run test, and see if it fails and how does it do it exactly.

```go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s",
			1,
			"I",
			roman
		)
	}
}

func decToroman(decimal int) string {
	
}
```

This code results in the following message:

```
# tddbook-go/roman [tddbook-go/roman.test]
./roman_test.go:6:11: undefined: decToRoman
./roman_test.go:16:1: missing return at end of function

Compilation finished with exit code 2
```

This error tells us that we have misspelled the name of the function, so we start by correcting it:

```go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s", 
			1, 
			"I", 
			roman
		)
	}
}

func decToRoman(decimal int) string {
	
}
```

And we can continue. Since the test states that it expects the function to return "I" when we pass it 1 as an input, the failed test should indicate us that the actual result doesn't match the expected one. However, at the moment, the test is telling us that the function doesn't return anything. It's still a compilation error and still not the correct reason to fail.

```
# tddbook-go/roman [tddbook-go/roman.test]
./roman_test.go:16:1: missing return at end of function

Compilation finished with exit code 2
```

To make the test fail for the reason that we expect it to, we have to make the function return a `string`, even if it's an empty one.

```go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s",
			1, 
			"I", 
			roman
		)
	}
}

func decToRoman(decimal int) string {
	return ""
}
```

So, this change turns the error into one related with the test definition, as it's not obtaining the result that it expects. This is the correct reason for failure, the one that will force us to write the production code that will make the test pass.

```
=== RUN   TestRomanNumeralsConversion
--- FAIL: TestRomanNumeralsConversion (0.00s)
    roman_test.go:9: Decimal 1 should convert to I, but found 
FAIL

Process finished with exit code 1
```

And so we would be ready to take the next step:

### Writing code that makes the test pass

As a response to the previous result, we write the production code that is needed for the test to pass, but nothing else. Continuing with our example:

```go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s", 
			1, 
			"I", 
			roman
		)
	}
}

func decToRoman(decimal int) string {
	return "I"
}
```

Tras hacer pasar el primer test podemos empezar creando el archivo que contendrá la unidad bajo test. Podríamos incluso volver a lanzar el test ahora, lo cual seguramente provocará que el compilador o intérprete nos devuelva un mensaje de error distinto. Aquí ya dependemos un poco de circunstancias, como las convenciones del lenguaje en que estamos desarrollando, el IDE con el que trabajamos, etc.

En todo caso, se trata de ir dando pequeños pasos hasta que el compilador o intérprete quede conforme y pueda ejecutar el test. En principio, el test debería ejecutarse y fallar indicando que el resultado recibido de la unidad de software no coincide con el esperado.

En este punto hay que hacer una salvedad porque dependiendo del lenguaje, del *framework* y de algunas prácticas en testing, la forma concreta de este primer test puede ser un poco distinta. Por ejemplo, hay *frameworks* de test en los que basta con que la ejecución del test no arroje errores o excepciones para considerar que pasa, por lo que un test que simplemente instancia un objeto o invoca uno de sus métodos sería suficiente. En otros casos, es necesario que el test incluya una aserción y si no se hace ninguna considera que el test no pasa.

En cualquier caso, el objetivo de esta fase es lograr que el test se ejecute con éxito.

Con la kata [Prime Factors](#primefactors) estudiaremos el modo en que puede cambiar el código de producción para incorporar nueva funcionalidad.

### Mejorar la estructura del código (y del test)

Cuando se ha logrado hacer pasar cada test debemos examinar el trabajo realizado hasta el momento y comprobar si es posible refactorizar tanto el código de producción como el de test. Aquí aplicamos los principios habituales: si detectamos cualquier *smell*, dificultad para entender lo que ocurre, duplicación de conocimiento, etc. debemos refactorizar el código para ponerlo en mejor estado antes de continuar.

En el fondo, las preguntas en este momento son:

* ¿Hay alguna manera mejor de organizar el código que he escrito? 
* ¿Hay alguna manera mejor de expresar lo que que este código hace y que sea más fácil de entender?
* ¿Puedo encontrar alguna regularidad y hacer que el algoritmo sea más general?

Para ello debemos mantener todos los tests que hayamos escrito pasando. Si alguno de los tests se pone en rojo tendríamos una regresión y habríamos estropeado, por así decir, la funcionalidad ya creada.

Tras el primer ciclo es normal no encontrar muchas oportunidades de refactor, pero no te fíes: siempre hay otra manera de ver y hacer las cosas. Por regla general, cuanto antes detectes oportunidades de reorganizar y limpiar el código y lo hagas, más fácil será el desarrollo.

Por ejemplo, nosotros hemos creado la función bajo test en el mismo archivo del test.

```go
package roman

import "testing"

func TestRomanNumeralsConversion(t *testing.T) {
	roman := decToRoman(1)

	if roman != "I" {
		t.Errorf(
			"Decimal %d should convert to %s, but found %s", 
			1, 
			"I", 
			roman
		)
	}
}

func decToRoman(decimal int) string {
	return "I"
}
```

Resulta que hay una forma mejor de organizar ese código y es crear un archivo que contenga la función. De hecho, es una práctica recomendada en casi todos los lenguajes de programación. Sin embargo, al principio nos la podemos saltar. 

```go
//roman/roman.go

package roman

func decToRoman(decimal int) string {
	return "I"
}
```

Y, en el caso de Go, podemos convertirla en una función *exportable* si su nombre comienza con mayúsculas.

```go
package roman

func DecToRoman(decimal int) string {
	return "I"
}
```

Para profundizar en todo lo que tiene que ver con el refactor al trabajar tendremos la kata [Bowling Game](#bowling).

### Repetir el ciclo hasta terminar

Una vez que el código de producción hace pasar el test y está lo mejor organizado posible en esa fase, es el turno de escoger otro aspecto de la funcionalidad y crear un nuevo test que falle para describirlo.

Este nuevo test falla porque el código existente no cubre la funcionalidad deseada y es necesario introducir un cambio. Por tanto, nuestra misión ahora es poner este nuevo test en verde haciendo las transformaciones necesarias en el código, las cuales serán pequeñas si hemos sabido dimensionar correctamente nuestros tests anteriores.

Tras conseguir que el nuevo test pase, buscamos las oportunidades de refactor para tener un mejor diseño del código. A medida que avancemos en el desarrollo de la pieza de software veremos que los refactors posibles van siendo más significativos.

En los primeros ciclos comenzaremos con cambios de nombres, extracción de constantes y variables, etc. Luego pasaremos a introducir métodos privados o extraer ciertos aspectos a funciones. En algún momento descubriremos la necesidad de extraer funcionalidad a clases colaboradoras, etc.

Cuando estemos satisfechas con el estado del código repetimos el ciclo mientras nos queda funcionalidad por añadir.

### ¿Cuándo termina el desarrollo en TDD?

La respuesta obvia podría ser: cuando toda la funcionalidad está implementada.

Pero, ¿cómo sabemos esto?

Kent Beck proponía hacer una lista con todos los aspectos que habría que conseguir para considerar completa la funcionalidad. Cada vez que se consigue alguno se tacha de la lista. A veces, al progresar en el desarrollo nos damos cuenta de la necesidad de añadir, quitar, o mover, elementos en la lista. Es una buena recomendación.

Existe una manera más formal de asegurarnos de que una funcionalidad está completa. Básicamente consiste en **no ser capaz** de crear un nuevo test que falle. En efecto, si un algoritmo está completamente implementado será imposible crear un test nuevo que pueda fallar.

## Qué no es Test Driven Development

El resultado o `outcome` de Test Driven Development no es crear un software libre de defectos, aunque se previenen muchos de ellos; ni generar una suite de tests unitarios, aunque en la práctica se obtiene una con gran cobertura que puede llegar al 100%, con la contrapartida de que puede presentar redundancia. Pero nada de esto es el objetivo de TDD, en todo caso es un efecto colateral ciertamente beneficioso.

### TDD no es Quality Assurance

Aunque usamos las mismas herramientas (tests), las usamos para finalidades distintas. Los tests en TDD guían el desarrollo, estableciendo objetivos específicos para alcanzar añadiendo código o aplicando cambios en él. El resultado de TDD es una suite de tests que puede utilizarse en QA como tests de regresión, aunque es frecuente que tengamos que retocar esos tests de una manera u otra. En unos casos para eliminar tests redundantes y en otros para asegurar que las casuísticas están bien cubiertas.

En cualquier caso, TDD ayuda enormemente el proceso de QA porque previene muchos de los defectos más comunes y contribuye a construir un código bien estructurado y con bajo acoplamiento, aspectos que incrementan la fiabilidad del software, nuestra capacidad para intervenir en caso de errores e incluso la posibilidad de crear nuevos tests en un future.

### TDD no reemplaza el diseño

TDD es una herramienta para contribuir al diseño de software, pero no lo reemplaza.

Cuando desarrollamos unidades pequeñas y con una funcionalidad muy bien definida, TDD nos ayuda a establecer el diseño del algoritmo gracias a la red de seguridad proporcionada por los tests que vamos creando.

Pero cuando la unidad considerada es mayor, un análisis previo que nos lleve a un "boceto" de los elementos principales de la solución nos permite tener un marco de desarrollo.

El enfoque *outside-in* intenta integrar el proceso de diseño en el desarrollo, usando lo que Sandro Mancuso etiqueta como *Just-in-time design*: partimos de una idea general de cómo se estructura y de cómo funcionará el sistema y diseñamos en el ámbito de la iteración en la que nos encontremos.

### En qué nos ayuda TDD

Lo que TDD nos proporciona es una herramienta que:

* Guía el desarrollo del software de una forma sistemática y progresiva.
* Nos permite realizar afirmaciones contrastables sobre si la funcionalidad requerida ha sido implementada o no.
* Nos ayuda a evitar la necesidad de diseñar todos los detalles de implementación anticipadamente, ya que en sí misma es una herramienta de ayuda al diseño de los componentes del software. 
* Nos permite posponer decisiones a varios niveles.
* Nos permite centrarnos en problemas muy concretos, avanzando en pasos pequeños y fáciles de revertir si introducimos errores.

## Beneficios

Varios estudios han mostrado evidencias que apuntan a favor de que la aplicación de TDD tiene beneficios en los equipos de desarrollo. No son evidencias concluyentes, pero las investigaciones realizadas tienden a coincidir en que con TDD:

* Se escribe una mayor cantidad de tests
* El software tiene menos defectos
* La productividad no se ve disminuida, incluso puede aumentar

Es bastante difícil cuantificar el beneficio de usar TDD en cuanto a productividad o velocidad, sin embargo subjetivamente se pueden experimentar varios beneficios.

Uno de ellos es que la metodología TDD puede bajar la cargar cognitiva del desarrollo. Esto es así porque favorece dividir el problema en tareas pequeñas con un foco muy definido, lo que nos permite ahorrar la limitada capacidad de nuestra memoria de trabajo. 

La evidencia anecdótica apunta a que las desarrolladoras y equipos que introducen TDD reducen los defectos, reducen el tiempo dedicado a bugs, aumentan la confianza a la hora de desplegar y la productividad no se ve afectada negativamente.

## Referencias

* [Test Driven Development](https://en.wikipedia.org/wiki/Test-driven_development)[^fn1] 
* [Why Test-driven Development](http://derekbarber.ca/blog/2012/03/27/why-test-driven-development/)[^fn2]
* [Test driven development: empirical body of evidence](https://pdfs.semanticscholar.org/ad0f/dd36aa09d25b739b1649bfa5e20c9e46eb65.pdf )[^fn3]
* [Does Test-Driven Development Really Improve Software Design Quality](https://digitalcommons.calpoly.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=1027&context=csse_fac)[^fn4]
* [6 Misconceptions about TDD – Part 1. TDD Brings Little Business Value and Isn’t Worth it](https://www.thedroidsonroids.com/blog/pros-of-tdd-test-driven-development-for-business)[^fn5]
* [TDD is about design, not testing](https://medium.com/@philborlin/tdd-is-about-design-not-testing-e42af0b28475)[^fn6] 
* [Does TDD really lead to good design?](https://codurance.com/2015/05/12/does-tdd-lead-to-good-design/)[^fn7] 
* [Using TDD to influence design](https://www.thoughtworks.com/insights/blog/using-tdd-influence-design)[^fn8] 


[^fn1]: https://en.wikipedia.org/wiki/Test-driven_development
[^fn2]: http://derekbarber.ca/blog/2012/03/27/why-test-driven-development/
[^fn3]: https://pdfs.semanticscholar.org/ad0f/dd36aa09d25b739b1649bfa5e20c9e46eb65.pdf
[^fn4]: https://digitalcommons.calpoly.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=1027&context=csse_fac
[^fn5]: https://www.thedroidsonroids.com/blog/pros-of-tdd-test-driven-development-for-business
[^fn6]: https://medium.com/@philborlin/tdd-is-about-design-not-testing-e42af0b28475
[^fn7]: https://codurance.com/2015/05/12/does-tdd-lead-to-good-design/
[^fn8]: https://www.thoughtworks.com/insights/blog/using-tdd-influence-design
