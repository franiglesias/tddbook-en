# Task list, *outside-in* TDD sliced in user stories

In this version of the same exercise about creating an application using TDD, we'll work with the project organized in user stories. That is: we have divided the project into features that provide value. Our goal is to show a work methodology that we could put into practice inside real projects.

This project will be done in PHP, with PHPUnit and some components from Symfony framework. The solution is a bit different from that in the previous chapter because this time we are going to limit the scope of our job to the user story, and that imposes some constraints that we didn't have before.

## Adding task to a list

Let's review the definition:

### US 1

* As a User
* I want to add tasks to a to-do list
* So that, I can organize my tasks

To complete this user story we will need, apart from an endpoint to which we can call and a controller that manages it, a use case to add tasks to the list, and a repository to store them. Our use case will be a *command*, so the effect of the action will be a call to the repository storing every new task.

To be able to verify this with a test we don't want to write code that won't be needed in production. For example, we are not going to write methods (yet) to retrieve information from the repository. Strictly speaking, at this moment we don't even know if we are going to need them (*spoiler*: yes, but that will be coding for a future that we don't know). So, at first, we will use a *mock* of repository and check that the right calls are made.

Once we have this clarified, we write a test that will send a POST request to the endpoint to create a new task and will verify that at some time, we are calling to a task repository, trusting that the real implementation will manage it correctly when available.

It is a good idea to start the test from the end, stating what we expect, and build the rest with the needed actions. In this case, we expect the existence of a `TaskRepository` that will be an interface. Also, we will introduce the concept of `Task`.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class TodoListAcceptanceTest extends WebTestCase
{
    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $taskRepository = $this->createMock(TaskRepository::class);
        $task = new Task(1, 'Write a test that fails');
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);

        $client = self::createClient();

        $client->getContainer()->set(TaskRepository::class, $taskRepository);

        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write a test that fails'], JSON_THROW_ON_ERROR)
        );
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

We will have to run the test and implement all the things that it will be asking until we get it failing because the right reason.

The first error message is that we haven't defined `TaskRepository`, so we start from there:

```
Cannot stub or mock class or interface "App\Tests\Katas\TodoList\TaskRepository" which does not exist
```

This error happens in PHP and PHPUnit. In other languages, you could find a different one.

For the moment, my solution is to create it in the same file as the test. If the error message changes, then I will move it to its file.

```php
interface TaskRepository
{

}
```

Now, the test fails because of a different reason, so we have passed this obstacle. We use the Move Class refactoring to move `TaskRepository` to `App\TodoList\Domain\TaskRepository` and then we run again the tests, getting the following error:

```
Error : Class 'App\Tests\Katas\TodoList\Task' not found
```

That is telling us that we have not defined the class `Task`. At the moment, we will create `Task`in the same file, re-running the test to see if the error message changes.

```php
class Task
{
    
}
```

The error is saying that there is not a method `store` in `TaskRepository`, so we can't mock it. We have to introduce it, but we will move `Task` to its place in `App\TodoList\Domain` before. As you can see, we are organizing code using a layered architecture.

After moving `Task`, we add the `store` method to `TaskRepository`:

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;
}
```

The next error is a bit weirder:

```
Symfony\Component\Config\Exception\LoaderLoadException : The file "../src/Controller" does not exist
 (in: /application/config) in /application/config/services.yaml 
 (which is loaded in resource "/application/config/services.yaml").
```

It has to do with the Symfony framework configuration that we are using for this exercise. This message is telling us that there are no files that contain controllers in the given path and namespace. I don't want them there, instead, I want to put them into `App\TodoList\Infrastructure\EntryPoint\Api`. This is because I want to keep a clean architecture, with components organized in layers. Controllers and other entry points to the application are in the infrastructure layer, inside a category `EntryPoint` that, in this case, has a port, related to the communication using the API.

To achieve this, we only have to go to the file `config/services.yaml` and change what is required:

```yaml
    # controllers are imported separately to make sure services can be injected
    # as action arguments even if you don't extend any base controller class
    App\TodoList\Infrastructure\EntryPoint\Api\:
        resource: '../src/TodoList/Infrastructure/EntryPoint/Api'
        tags: ['controller.service_arguments']
```

When we run the test, we get a similar error:

```
Symfony\Component\Config\Exception\LoaderLoadException : The file "../src/TodoList/Infrastructure/EntryPoint/Api" 
 does not exist (in: /application/config) in /application/config/services.yaml
 (which is loaded in resource "/application/config/services.yaml").
```

This is positive because it reflects that we have made the change in **services.yaml** right, but we haven't added a controller in the desired location so that it can be loaded and avoid the error. So we add a `TodoListController.php` file to the folder with this code:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


class TodoListController
{

}
```

Running this test throws to new error message. This is the first:

```
"No route found for "POST /api/todo""
```

And that's a framework problem because the HTTP client is calling to an endpoint that is not defined anywhere yet. We solve this by configuring it in `routes.yaml`.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']
```

As we always do after a change, we run the test, that now will shout that there is not a method in the controller in charge of managing the response to this end point.

```
"The controller for URI "/api/todo" is not callable. 
Expected method "addTask" on class "App\TodoList\Infrastructure\EntryPoint\Api\TodoListController"...
```

We can implement it this way:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


class TodoListController
{
    public function addTask()
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

It is a single line that throws an exception to mark that the method is not implemented. We do it this way so the test itself stated that we have something not implemented. An empty method body would not tell us anything and, in many situations, it would be easy to lose track of the thing we have left pending to write.

If we run the test, it throws exactly that error:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask"
```

But also this one, from the test itself.

```
Expectation failed for method name is equal to 'store' when invoked 1 time(s).
Method was expected to be called 1 times, actually called 0 times.
```

This is the error which we will be expecting from the test as we wrote it. There are no framework configuration errors. I tell us that a Task is never stored in the repository. In other words: no production code executes the desired behavior.

Those two errors tell as that is the time to implement.

And to do that, we need to go one step into the application. In our example, this is `TodoListController`. At this point, we leave the acceptance test loop and we enter in a cycle of unitary tests to develop `TodoListController::addTask`.

## Designing *in red*

The acceptance test is not passing and it is asking us to implement something in `TodoListController`. To do so, we are going to think about how we want the controller to be and it will delegate the job to other objects.

In particular, we want the controller to be a very tiny layer in charge of:

* Getting the necessary information from the request
* Pass it to a use case to do what is needed
* Get the response from the use case and send it back to the *endpoint*

In a classic approach, we would implement the complete solution in the controller and, then, we would be moving logic to the required components.

Instead of that, in the mockist approach, we design how this implementation level would look like and we use doubles for collaborations we could need. For example, this is our test:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{

    /** @test */
    public function shouldAddTask(): void
    {
        $addTaskHandler = $this->createMock(AddTaskHandler::class);
        $addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');
        
        $todoListController = new TodoListController($addTaskHandler);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );
        
        $response = $todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }
}
```

In this test, two things are verified. On the one hand, that we return a response with a status code of 201 (created). On the other, that we will have a use case named `AddTaskHandler` in charge to process the creation of the task provided its descriptions, that it's received as a payload in the request.

When we run the test, we start getting the expected error. The first on is that we don't have any `AddTaskHandler`. Again, I'll start by adding it to the test fail, and I'll move it in the next step. In fact, it's literally what the error says:

```
Cannot stub or mock class or interface "App\Tests\TodoList\Infrastructure\EntryPoint\Api\AddTaskHandler" 
which does not exist
```

So, we add:

```php
class AddTaskHandler
{

}
```

Running the test now will ask us to implement the method `execute` that is not defined. Before doing so, we are going to move `AddTaskHandler`, that is the use case, to its place in the application layer: `App\TodoList\Application`. Next, we add the method including our "not implemented" exception.

```php
namespace App\TodoList\Application;

class AddTaskHandler
{
    public function execute(): void
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

This way, what will happen is as follows: once we've implemented the controller, we'll see that its unitary test passes, because we are using the `AddTaskHandler` double and we are not calling to the real code. This will happen when running the acceptance test, which will be pointing us to implement `AddTaskHandler` and go one lever deeper in the application.

The next error is well known:

```
RuntimeException : Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
```

This indicates that the test is calling the `addTask` method, not implemented yet. It is just where we want to be. We will implement logic in `TodoListController::addTask` to make the test pass:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    /** @var AddTaskHandler */
    private AddTaskHandler $addTaskHandler;

    public function __construct(AddTaskHandler $addTaskHandler)
    {
        $this->addTaskHandler = $addTaskHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);

        $this->addTaskHandler->execute($payload['task']);
        return new JsonResponse('', Response::HTTP_CREATED);
    }
}
``` 

The test passes!

We could go slower here to drive the implementation with smaller steps, but I think that it's better to do it in only one because the logic is not too complex, and this way we're not too dispersed. The important thing, however, is that we have achieved the goal of developing this controller with a unitary test that is passing right now.

Given that the unitary test is passing, we don't have any more work to do at this level. Nevertheless, I'm going to make a little refactoring to hide the details of getting the payload from the request, leaving the body of the controller a bit cleaner and easy to follow.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    /** @var AddTaskHandler */
    private AddTaskHandler $addTaskHandler;

    public function __construct(AddTaskHandler $addTaskHandler)
    {
        $this->addTaskHandler = $addTaskHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

## Returning to the acceptance test

Once we've made the unit test pass, we have to return to the acceptance level so that it tells us how to proceed. We execute it and we get the following:

```
RuntimeException: "Implement App\TodoList\Application\AddTaskHandler::App\TodoList\Application\AddTaskHandler::execute" 
```

Now it's time to go a little bit deeper in the application and move on to the `AddTaskHandler` use case. What we expect from this UseCase is that it uses the information it receives to create a task, and stores it in TaskRepository.

To create a task, we'll need to give it an ID, which we're going to ask from the repository itself. The repository will have an appropriate method.

We can express this with the following unit test.

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class AddTaskHandlerTest extends TestCase
{
    /** @test */
    public function shouldCreateAndStoreATask(): void
    {
        $task = new Task(1, 'Task Description');
        
        $taskRepository = $this->createMock(TaskRepository::class);
        
        $taskRepository
            ->method('nextIdentity')
            ->willReturn(1);
        
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);
        
        $addTaskHandler = new AddTaskHandler($taskRepository);
        
        $addTaskHandler->execute('Task Description');
    }
}
```

We run the test. We get this error first:

```
Trying to configure method "nextIdentity" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

We add the method to the interface:

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;
    
    public function nextIdentity(): int;
}
```

Which generates this error:

```
RuntimeException : Implement App\TodoList\Application\AddTaskHandler::App\TodoList\Application\AddTaskHandler::execute
```

And we're ready to implement the use case. This code should suffice:

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class AddTaskHandler
{
    /** @var TaskRepository */
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(string $taskDescription): void
    {
        $id = $this->taskRepository->nextIdentity();

        $task = new Task($id, $taskDescription);

        $this->taskRepository->store($task);
    }
}
```

This code is enough to pass the test, so we can go back to the acceptance level.

## New cycle

When rerunning the acceptance test we find out that it passes. However, the use story isn't implemented yet, as we don't have a concrete repository in which `Task` objects are being saved. In fact, our `Task` classes don't have any code yet.

The reason is that we're using a `TaskRepository` *mock* in the acceptance test. We'd like to stop using it so that `TodoList` uses a concrete implementation. The problem that we'd have if we did so, would be that we wouldn't have any method to explore the content of the repository and verify the test. We're going to do this in two stages.

In the first one, we simple remove the usage of the *mock* and verify that the API response returns the code 201 (created).

```php
namespace App\Tests\Katas\TodoList;

use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $client = self::createClient();

        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write a test that fails'], JSON_THROW_ON_ERROR)
        );

        $response = $client->getResponse();

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }


    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

Before continuing, we have to erase the service definition that we made earlier in `services_test.yaml`. As it's the only service that we had declared there, we can just delete the file without any problem.

And when we execute the test, the following *framework* error appears:

```
Cannot autowire service "App\TodoList\Application\AddTaskHandler": argument "$taskRepository" of method "__construct()"
```

This happens because we just have an interface of `TaskRepository`, and we would need a concrete implementation that we could use. This way, we have an error that lets us move on with the development. We'll need a test to implement `FileTaskRepository`, a repository based on a simple text file to store the serialize objects:

```php
namespace App\Lib;


class FileStorageEngine
{
    private string $filePath;

    public function __construct($filePath)
    {
        $this->filePath = $filePath;
    }

    public function loadObjects(string $class): array
    {
        if (!file_exists($this->filePath)) {
            return [];
        }

        $file = fopen($this->filePath, 'rb');
        $objects = unserialize(fgets($file), ['allowed_classes' => [$class]]);
        fclose($file);

        return $objects;
    }

    public function persistObjects(array $objects): void
    {
        $file = fopen($this->filePath, 'wb');
        fwrite($file, serialize($objects));
        fclose($file);
    }
}
```

In the first place we're going to create a default implementation for `FileTaskRepository` in the right place, which will be `App\TodoList\Infrastructure\Persistence`:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    public function store(Task $task): void
    {
        throw new \RuntimeException('Implement store() method.');
    }

    public function nextIdentity(): int
    {
        throw new \RuntimeException('Implement nextIdentity() method.');
    }
}
```

When we execute the acceptance test again two errors happen. One tells us that we have to implement the repositories' `nextIdentity` method. The other, which is an error of the test itself, informs us that the *endpoint* returns the 500 code instead of 201. This is reasonable, as out current `FileTaskRepository` implementation will fail fatally.

But it's good news, because it tells us how to proceed. So, we'll create a new unit test to guide the development of `FileTaskRepository`. In this test, we simulate a different number of objects in storage to ensure the correct implementation.

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $storageEngine = $this->createMock(FileStorageEngine::class);

        $taskRepository = new FileTaskRepository($storageEngine);
        $storageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $taskRepository->nextIdentity());
        self::assertEquals(2, $taskRepository->nextIdentity());
        self::assertEquals(3, $taskRepository->nextIdentity());
    }
}
```

With this test passing, we return to the acceptance test, which fails again. The *endpoint* returns an error 500 because we don't have an implementation of the `store` method in `FileTaskRepository`.

We'll introduce a new test, although we've refactored it a bit beforehand in order to make introducing changes easier:

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $this->taskRepository->nextIdentity());
        self::assertEquals(2, $this->taskRepository->nextIdentity());
        self::assertEquals(3, $this->taskRepository->nextIdentity());
    }

    /** @test */
    public function shouldStoreATask(): void
    {
        $task = new Task(1, 'Task Description');

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn([]);
        $this->fileStorageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }
}
```

This is our implementation to pass the test:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    /** @var FileStorageEngine */
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }
}
```

We have to implement the `Task::id` method, which makes us also introduce a constructor:

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }
}
```

The implementation passes the test. To not lose track I won't introduce any more examples, which would be appropriate to grow more confidence about the behavior of the test. But, for now, it's enough to understand the process.

As we're in green, we go back to the acceptance test to check how far we've come. And when we run it, the acceptance test passes, indicating that the feature is complete. Or almost, as at the moment we don't have any way to know if the tasks have been stored or not.

One possibility is to obtain the contents of `FileStorageEngine` and see if our tasks are there. It doesn't force us to implement anything in the production code:

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $client = self::createClient();

        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write a test that fails'], JSON_THROW_ON_ERROR)
        );

        $response = $client->getResponse();

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());

        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }


    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

The test verifies that we've stored a task in the repository, confirming that the first user story is implemented. It may be a good time to examine what we've done so far and see if we can do any refactoring that may facilitate the next development steps.

Let's start with the acceptance test:

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $response = $this->whenWeRequestToCreateATaskWithDescription('Write a test that fails');

        $this->thenResponseShouldBeSuccessful($response);

        $this->thenTheTaskIsStored();
    }


    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    private function whenWeRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }

    private function thenResponseShouldBeSuccessful(Response $response): void
    {
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    private function thenTheTaskIsStored(): void
    {
        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }
}
```

**TodoListControllerTest**:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->todoListController = new TodoListController($this->addTaskHandler);
    }


    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }
}
```

There are other small changes in some files, but we're not going to go into detail here.

## See the tasks on the list

### US 2

* As a User
* I want to see the task in my to-do list
* So that, I can know what I have to do next

Our second user story requires its own *endpoint*, controller, and use case. We already have a task repository, to which we'll have to add a method to retrieve the full list.

Since we have a *real* implementation of the repository, we no longer have to use a *mock*, as we had done earlier to be able to kickstart the development. In a situation in which we were using database persistence, or something similar, we'd probably need a *fake* implementation, such an in-memory repository or even the simple file repository that we're using, which we need because of the persistence problem between PHP requests.

This is the first version of the acceptance test for this user story:

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $response = $this->whenWeRequestToCreateATaskWithDescription('Write a test that fails');

        $this->thenResponseShouldBeSuccessful($response);

        $this->thenTheTaskIsStored();
    }

    /** @test */
    public function asUserIWantToSeeTheTasksInMyTodoList(): void
    {
        $expectedList = [
            '[ ] 1. Write a test that fails',
            '[ ] 2. Write code to make the test pass'
        ];
        
        $this->apiCreateTaskWithDescription('Write a test that fails');
        $this->apiCreateTaskWithDescription('Write code to make the test pass');
        
        $this->client->request(
            'GET',
            '/api/todo'
        );

        $response =  $this->client->getResponse();
        
        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        
        $taskList = json_decode($response->getContent(), true);
        
        self::assertEquals($expectedList, $taskList);
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    private function whenWeRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        return $this->apiCreateTaskWithDescription($taskDescription);
    }

    private function thenResponseShouldBeSuccessful(Response $response): void
    {
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    private function thenTheTaskIsStored(): void
    {
        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }

    private function apiCreateTaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }
}
```

So we run it and, as before, we take note of the error that it throws and fix them until the test fails for the proper reasons. In this case we can see two related errors.

The first one is that there isn't an appropriate route for the *endpoint*.

```
"No route found for "GET /api/todo": Method Not Allowed (Allow: POST)"
```

Which, of course, causes the error in the test when verifying the state code:

```
Failed asserting that 405 matches expected 200.
```

We configure the route in **routes.yaml**:

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']
```

We run the test. The error is different, which indicates that we've correctly made the change, but now it tells us that we're missing the specific controller:

```
"The controller for URI "/api/todo" is not callable. Expected method "getTaskList" on class "App\TodoList\Infrastructure\EntryPoint\Api\TodoListController"
```

So we add our initial *empty* implementation:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    /** @var AddTaskHandler */
    private AddTaskHandler $addTaskHandler;

    public function __construct(AddTaskHandler $addTaskHandler)
    {
        $this->addTaskHandler = $addTaskHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

When we run the test again, an exception is thrown indicating that we need to implement something. It's time to go back to the `TodoListController` test. It's important to learn to identify when to move between the acceptance test cycle and the unit tests cycle.

The new test helps us introduce the new use case `GetTaskListHandler`, but it also poses an interesting problem: what should `GetTaskListHandler`, `Task` objects, or a representation of them?

In this case, the most adequate option would be to use some kind of `DataTransformer` and apply a `Strategy` pattern so that `TodoListController` tells the use case which `DataTransformer` it wants to use. This *transformer* can be passed to the controller as a dependency, and it will send it to the use case as a parameter.

As you can see, now we're literally designing. So we're going to see how the test ends up.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer
        );
    }

    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }

    /** @test */
    public function shouldGetTaskList(): void
    {
        $expectedList = [
            '[ ] 1. Task Description',
            '[ ] 2. Task Description',
        ];
        $this->getTaskListHandler
            ->expects(self::once())
            ->method('execute')
            ->with($this->taskListTransformer)
            ->willReturn($expectedList);

        $response = $this->todoListController->getTaskList(new Request());

        self::assertEquals(200, $response->getStatusCode());

        $list = json_decode($response->getContent(), true);

        self::assertEquals($expectedList, $list);
    }
}
```

At this point, we only need to `TaskListTransformer` so that the controller can pass it to the use case. If we run the test, it'll fail because we haven't defined the `GetTaskListHandler` class yet. We introduce an initial implementation.

```php
class GetTaskListHandler
{
    
}
```

Running the test again we see that now it's asking for `TaskListTransformer`. First we move `GetTaskListHandler` to its location in `App\TodoList\Application`. Then we create `TaskListTransformer`.

```php
class TaskListTransformer
{
    
}
```

We check the result of the test again, which now tells us that we're missing an `execute` method in `GetTaskListHandler`. Same as before, we first move the `TaskListTransformer` to its place.

In principle, I would put it in `App\TodoList\Infrastructure\EntryPoint\Api`, as the purpose of the *transformer* is to prepare a specific response for the API. But this would be correct for the concrete implementation that we end up using. If we do it this way we'd have a badly oriented dependency, as it would be pointing from Application towards Infrastructure. To invert it, we'll have to put `TaskListTransformer` in the application layer as an interface. It's place would be: `App\TodoList\Application\TaskListTransformer`.

Once relocated, we add the `execute` method to `GetTaskListHandler`.

```php
namespace App\TodoList\Application;

class GetTaskListHandler
{
    public function execute(TaskListTransformer $taskListTransformer): array
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Having added this, when we run the test we see that it fails because we've managed to trigger the exception that asks us to implement `getTaskList` in the controller:

```
RuntimeException : Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
```

And we can implement whatever the test needs to pass:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(Request $request): Response
    {
        $taskList = $this->getTaskListHandler->execute($this->taskListTransformer);

        return new JsonResponse($taskList, Response::HTTP_OK);
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

We may observe that the controller has many dependencies. This can be solved with a command bus or by dividing the class in several smaller ones, but we're not going to do it in this exercise to avoid losing focus.

In any case, the test passes, which indicates that it's time to move back to the acceptance test cycle.

It will keep failing, as we might have expected:

```
PHP Exception RuntimeException: "Implement App\TodoList\Application\GetTaskListHandler::execute" 
```

An error that tells us that the next step is to use a unit test to develop the `GetTaskListHandler` use case.

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class GetTaskListHandlerTest extends TestCase
{
    /** @test */
    public function shouldGetExistingTasks(): void
    {
        $expectedList = [
            '[ ] 1. Write a test that fails',
            '[ ] 2. Write code to make the test pass',
        ];

        $taskList = [
            new Task(1, 'Write a test that fails'),
            new Task(2, 'Write code to make the test pass'),
        ];

        $tasksRepository = $this->createMock(TaskRepository::class);
        $tasksRepository
            ->method('findAll')
            ->willReturn($taskList);

        $taskListTransformer = $this->createMock(TaskListTransformer::class);
        $taskListTransformer
            ->expects(self::once())
            ->method('transform')
            ->with($taskList)
            ->willReturn($expectedList);

        $getTaskListHandler = new GetTaskListHandler($tasksRepository);
        $list = $getTaskListHandler->execute($taskListTransformer);

        self::assertEquals($expectedList, $list);
    }
}
```

When we run this test, it asks us to add the `findAll` method to the repository.

```
Trying to configure method "findAll" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

We do this both in the interface and the concrete implementation:

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;

    public function nextIdentity(): int;

    public function findAll(): array;
}

```

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    /** @var FileStorageEngine */
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        throw new \RuntimeException('Implement findAll() method.');
    }
}
```

And the same for the `transform` method in `TaskListTransformer`:

```
Trying to configure method "transform" which cannot be configured because it does not exist, 
has not been specified, is final, or is static
```

Which will end up like this, once it's been redefined as an interface:

```php
namespace App\TodoList\Application;

interface TaskListTransformer
{
    public function transform(array $taskList): array;
}
```

With these changes, the test will now fail to tell us that we need to implement the `execute` method of the use case, which is just where we wanted to be:

```
RuntimeException : Implement App\TodoList\Application\GetTaskListHandler::execute
```

And here's the implementation that makes the test pass.

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\TaskRepository;
use App\TodoList\Application\TaskListTransformer;

class GetTaskListHandler
{
    /** @var TaskRepository */
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(TaskListTransformer $taskListTransformer): array
    {
        $tasks = $this->taskRepository->findAll();

        return $taskListTransformer->transform($tasks);
    }
}
```

Now that we've gone back to green, we'll return to the acceptance cycle. When we run the test, the result is a new error message, which asks us to implement `findAll` in `FileTaskRepository`.

```
RuntimeException: "Implement findAll() method."
```

This requires a unit test.

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $this->taskRepository->nextIdentity());
        self::assertEquals(2, $this->taskRepository->nextIdentity());
        self::assertEquals(3, $this->taskRepository->nextIdentity());
    }

    /** @test */
    public function shouldStoreATask(): void
    {
        $task = new Task(1, 'Task Description');

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn([]);
        $this->fileStorageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }

    /** @test */
    public function shouldGetStoredTasks(): void
    {
        $storedTasks = [
            1 => new Task(1, 'Write a test that fails'),
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        self::assertEquals($storedTasks, $this->taskRepository->findAll());
    }
}
```

When we run it, it will ask:

```
RuntimeException : Implement findAll() method.
```

So we get to it:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    /** @var FileStorageEngine */
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        return $this->fileStorageEngine->loadObjects(Task::class);
    }
}
```

Now the unit test passes, with which we've implemented a good part of the repository. Will it be enough to make the acceptance test pass?

No, we still have work to do. At this moment, we're asked to introduce a concrete implementation of `TaskListTransformer`.

Now we have to introduce a new unit test to develop the concrete *Transformer*, which we'll locate in `App\TodoList\Infrastructure\EntryPoint\Api`, as it's the controller the one that's interested in using it. We'll call it `StringTaskListTransformer`, as it converts a `Task` into a `string` representation.

This is going to pose a small design challenge. We don't have any way to access the properties of `Task` yet, an entity that we also hadn't had to develop further until now, and the truth is that we shouldn't condition its implementation to this kind of necessities. In a more realistic and sophisticated system we could apply a `Visitor` pattern or something similar. In this case, what we'll do is we'll pass a template to `Task`, and `Task` will return it all filled out with its data.

Since `Task` is an entity I prefer not to *mock* it, so the test will end up this way:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Domain\Task;
use App\TodoList\Infrastructure\EntryPoint\Api\StringTaskListTransformer;
use PHPUnit\Framework\TestCase;

class StringTaskListTransformerTest extends TestCase
{
    /** @test
     * @dataProvider examplesProvider
     */
    public function shouldTransformList($tasksList, $expected): void
    {
        $taskListTransformer = new StringTaskListTransformer();

        $result = $taskListTransformer->transform($tasksList);

        self::assertEquals($expected, $result);
    }

    public function examplesProvider(): array
    {
        return [
          [[], []],
          [[new Task(1, 'Task Description')], ['[ ] 1. Task Description']]
        ];
    }
}

```

And the production code could be this one:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\TaskListTransformer;

class StringTaskListTransformer implements TaskListTransformer
{
    public function transform(array $taskList): array
    {
        $transformed = [];

        foreach ($taskList as $task) {
            $transformed[] = $task->representedAs('[:check] :id. :description');
        }

        return $transformed;
    }
}

```

The test will throw an error to tell us that the `representedAs` method is not implemented in `Task`, so we can add it.

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(): string
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Saving the distance, we can use the current test as an acceptance test. If we execute it, we'll see that this exception is thrown:

```
RuntimeException : Implement App\TodoList\Domain\Task::representedAs
```

Which would indicate the necessity to advance to the next level and create a unit test to develop `Task`, or at least its `representedAs` method. Another option would be to develop `Task` under the coverage of the current test, but this is not a very good idea, as the test could require examples that don't actually provide anything useful to the matter at hand and are only relevant to `Task`.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');
        
        $representation = $task->representedAs('[:check] :id. :description');
        
        self::assertEquals($expected, $representation);
    }
}
```

For the time-being, this implementation would already suffice.

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }
}
```

So we could go up one level and go back to the previous *Transformer* test, which passes with no problem.

With this test in green, we return to the acceptance level, which also passes, indicating that we've finished the development of this user story.

## Checking completed tasks

### US-3

* As a User
* I want to check a task when it is done
* So that, I can see my progress

The third user story is easily built from the two previous ones, as our application already allows to introduce tasks and see the list. For this reason, before beginning the development, let's refactor the acceptance test so it's easier to extend. In fact, we can even reuse some of its parts. This is the results, already with the new acceptance test added.

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $response = $this->whenWeRequestToCreateATaskWithDescription('Write a test that fails');

        $this->thenResponseShouldBeSuccessful($response);

        $this->thenTheTaskIsStored();
    }

    /** @test */
    public function asUserIWantToSeeTheTasksInMyTodoList(): void
    {
        $this->givenIHaveAddedTasks();

        $response = $this->whenIRequestTheListOfTasks();

        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass'
            ],
            $response
        );
    }

    /** @test */
    public function asUserIWantToMarkTasksAsCompleted(): void
    {
        $this->givenIHaveAddedTasks();
        
        $this->client->request(
            'PATCH',
            '/api/todo/1',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)

        );
        
        $patchResponse = $this->client->getResponse();

        self::assertEquals(Response::HTTP_OK, $patchResponse->getStatusCode());
                
        $response = $this->whenIRequestTheListOfTasks();

        $this->thenICanSeeAddedTasksInTheList(
            [
                '[√] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass'
            ],
            $response
        );
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    private function whenWeRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        return $this->apiCreateTaskWithDescription($taskDescription);
    }

    private function thenResponseShouldBeSuccessful(Response $response): void
    {
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    private function thenTheTaskIsStored(): void
    {
        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }

    private function apiCreateTaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }

    private function whenIRequestTheListOfTasks(): Response
    {
        $response = $this->apiGetTasksList();

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        return $response;
    }

    private function apiGetTasksList(): Response
    {
        $this->client->request(
            'GET',
            '/api/todo'
        );

        return $this->client->getResponse();
    }

    private function givenIHaveAddedTasks(): void
    {
        $this->apiCreateTaskWithDescription('Write a test that fails');
        $this->apiCreateTaskWithDescription('Write code to make the test pass');
    }

    private function thenICanSeeAddedTasksInTheList(array $expectedTasks, Response $response): void
    {
        $taskList = json_decode($response->getContent(), true);

        self::assertEquals(
            $expectedTasks, $taskList);
    }
}
```

When we run the test, it fails -as expected- because it doesn't find the route to the *endpoint*:

```
"No route found for "PATCH /api/todo/1"
```

And, as we've done before, we'll have to define it and create a controller that handles it. First, the route definition in **routes.yaml**.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']

api_get_task_list:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
  methods: ['GET']

api_mark_task_completed:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
  methods: ['PATCH']
```

A new execution of the test indicates that there's a controller missing:

```
"The controller for URI "/api/todo/1" is not callable. Expected method "markTaskCompleted"
```

And we add an empty one:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(Request $request): Response
    {
        $taskList = $this->getTaskListHandler->execute($this->taskListTransformer);

        return new JsonResponse($taskList, Response::HTTP_OK);
    }

    public function markTaskCompleted(int $taskId): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

The error now is:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted"
```

And the test fails because it expects that *endpoint* to be properly running and responding, but it's not implemented yet. Therefore, we move to the unit level to define the functionality of the controller.

As in the previous cases, implementing the functionality requires apart from the controller, a use case that utilizes the repository to recover and store back the task we wish to mark. Therefore, the key of the test will be to expect the use case to be executed with the right parameters.

So, the test will end up more or less like this:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }


    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }

    /** @test */
    public function shouldGetTaskList(): void
    {
        $expectedList = [
            '[ ] 1. Task Description',
            '[ ] 2. Task Description',
        ];
        $this->getTaskListHandler
            ->expects(self::once())
            ->method('execute')
            ->with($this->taskListTransformer)
            ->willReturn($expectedList);

        $response = $this->todoListController->getTaskList(new Request());

        self::assertEquals(200, $response->getStatusCode());

        $list = json_decode($response->getContent(), true);

        self::assertEquals($expectedList, $list);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $this->markTaskCompletedHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::COMPLETED_TASK_ID, true);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->markTaskCompleted(self::COMPLETED_TASK_ID, $request);

        self::assertEquals(200, $response->getStatusCode());
    }
}
```

Once we have the test, we run it. The result is that it asks us to create the `MarkTaskCompletedHandler` class.

```
Cannot stub or mock class or interface "App\Tests\TodoList\Infrastructure\EntryPoint\Api\MarkTaskCompletedHandler" which does not exist
```

We create it in the test itself, and then we move it to its location in `App\TodoList\Application` Next, it will ask us to create the `execute` method.

```
Trying to configure method "execute" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

Which we'll prepare this way:

```php
namespace App\TodoList\Application;


class MarkTaskCompletedHandler
{
    public function execute(int $taskId, bool $completed): void
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

With this we'll already have all that we need to implement the controller's action, something we do because the following error says so:

```
RuntimeException : Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
```

This is the code that will pass the controller's test.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(Request $request): Response
    {
        $taskList = $this->getTaskListHandler->execute($this->taskListTransformer);

        return new JsonResponse($taskList, Response::HTTP_OK);
    }

    public function markTaskCompleted(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->markTaskCompletedHandler->execute($taskId, $payload['completed']);

        return new JsonResponse('', Response::HTTP_OK);
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

Once the controller's test passes, we'll have to rerun the acceptance test. It will reveal the next step.

```
RuntimeException: "Implement App\TodoList\Application\MarkTaskCompletedHandler::execute"
```

It's asking us to implement the use case. Therefore, we need a new unit test:

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class MarkTaskCompletedHandlerTest extends TestCase
{
    private const COMPLETED_TASK_ID = 1;

    /** @test */
    public function shouldMarkTaskAsCompletedAndPersist(): void
    {
        $task = new Task(self::COMPLETED_TASK_ID, 'Task Description');
        
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('retrieve')
            ->with(self::COMPLETED_TASK_ID)
            ->willReturn($task);

        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);

        $markTaskCompletedHandler = new MarkTaskCompletedHandler($taskRepository);

        $markTaskCompletedHandler->execute(self::COMPLETED_TASK_ID, true);
    }
}
```

The execution of the test throws the following error:

```
Trying to configure method "retrieve" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

Up until now we hadn't needed this method in the repository, so we'll have to add it to the interface.

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;

    public function nextIdentity(): int;

    public function findAll(): array;

    public function retrieve(int $taskId): Task;
}
```


This will be enough to be able to continue executing the test, and reach the point where it asks us to implement the `execute` method of the use case.

```
RuntimeException : Implement App\TodoList\Application\MarkTaskCompletedHandler::execute
```

So we get to it. It's pretty simple:

```php
namespace App\TodoList\Application;


use App\TodoList\Domain\TaskRepository;

class MarkTaskCompletedHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, bool $completed): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        if ($completed) {
            $task->markCompleted();
        }
        
        $this->taskRepository->store($task);
    }
}
```

When we execute the test again, it'll fail. This is because we haven't defined the `Task::markCompleted` method:

```
Error : Call to undefined method App\TodoList\Domain\Task::markCompleted()
```

Every time we get an error of this kind, we'll have to dig deeper and enter a new unit test cycle. In this case, to implement this method in `Task`. We don't have direct access to the `complete` property, which we haven't even defined yet, but we can indirectly control its state thanks to its representation.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();
        
        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }
}
```

The implementation is quite simple:

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }
}
```

With this, the `Task` test passes, and we can return to the use case level. When running the test again, we see that it also passes, so we can also go back to the acceptance test.

This test, however, will not pass, as it expects that we implement the `retrieve` method in `FileTaskRepository`, which we don't have yet. We go to the test.

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $this->taskRepository->nextIdentity());
        self::assertEquals(2, $this->taskRepository->nextIdentity());
        self::assertEquals(3, $this->taskRepository->nextIdentity());
    }

    /** @test */
    public function shouldStoreATask(): void
    {
        $task = new Task(1, 'Task Description');

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn([]);
        $this->fileStorageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }

    /** @test */
    public function shouldGetStoredTasks(): void
    {
        $storedTasks = [
            1 => new Task(1, 'Write a test that fails'),
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        self::assertEquals($storedTasks, $this->taskRepository->findAll());
    }

    /** @test */
    public function shouldRetrieveATaskByItsId(): void
    {
        $expectedTask = new Task(1, 'Write a test that fails');
        
        $storedTasks = [
            1 => $expectedTask,
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        self::assertEquals($expectedTask, $this->taskRepository->retrieve(1));
    }
}
```

As it we could have expected, the test will demand us to write the `retrieve` method. 

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        return $this->fileStorageEngine->loadObjects(Task::class);
    }

    public function retrieve(int $taskId): Task
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return $tasks[$taskId];
    }
}
```

And with this, the `FileTaskRepository` test turns green. We take the opportunity to do a small refactoring, so that the dependency is controlled:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
        $tasks = $this->findAll();

        $tasks[$task->id()] = $task;

        $this->persistAllInStorage($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->findAll();

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        return $this->getAllFromStorage();
    }

    public function retrieve(int $taskId): Task
    {
        $tasks = $this->findAll();

        return $tasks[$taskId];
    }

    private function getAllFromStorage(): array
    {
        return $this->fileStorageEngine->loadObjects(Task::class);
    }

    private function persistAllInStorage(array $tasks): void
    {
        $this->fileStorageEngine->persistObjects($tasks);
    }
}
```

And we launch the acceptance test one more time, which now passes cleanly.

## Next steps

At this point, all three user stories have been implemented. What do we want to do now?

One of the improvements that we can do at the moment is fix the acceptance test so it can be used as a QA test. Now that we've developed all of the involved components, it's possible to make the test more expressive and useful to describe the implemented behavior.

The unit tests may be used as they are. A common objection is that, as they're based on *mocks*, they're fragile due to their coupling to the implementation.  However, we must remember that we've basically been designing each of the components that we needed, as well as the way in which we wanted them to interact. In other words: it's not foreseeable that this implementation is going to change so much that it invalidates the tests. On the other hand, the unit tests that we've been using characterize the specific behavior of each unit. Altogether they're fast and they provide us the necessary resolution to help us quickly diagnose any problem that might arise.

So, we're going to retouch the acceptance test so that it has better business language:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $this->givenIRequestToCreateATaskWithDescription('Write a test that fails');
        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
            ],
            $response
        );
    }

    /** @test */
    public function asUserIWantToSeeTheTasksInMyTodoList(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );
        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass',
            ],
            $response
        );
    }

    /** @test */
    public function asUserIWantToMarkTasksAsCompleted(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );
        $this->givenIMarkATaskAsCompleted(1);
        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[√] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass',
            ],
            $response
        );
    }

    private function givenIRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        return $this->apiCreateTaskWithDescription($taskDescription);
    }

    private function apiCreateTaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }

    private function whenIRequestTheListOfTasks(): Response
    {
        $response = $this->apiGetTasksList();

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());

        return $response;
    }

    private function apiGetTasksList(): Response
    {
        $this->client->request(
            'GET',
            '/api/todo'
        );

        return $this->client->getResponse();
    }

    private function thenICanSeeAddedTasksInTheList(array $expectedTasks, Response $response): void
    {
        $taskList = json_decode($response->getContent(), true);

        self::assertEquals($expectedTasks, $taskList);
    }

    private function givenIHaveAddedTasks($tasks): void
    {
        foreach ($tasks as $task) {
            $this->apiCreateTaskWithDescription($task);
        }
    }

    private function givenIMarkATaskAsCompleted(int $taskId): void
    {
        $patchResponse = $this->apiMarkTaskCompleted($taskId);

        self::assertEquals(Response::HTTP_OK, $patchResponse->getStatusCode());
    }

    private function apiMarkTaskCompleted(int $taskId): Response
    {
        $this->client->request(
            'PATCH',
            '/api/todo/' . $taskId . '',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)

        );

        return $this->client->getResponse();
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }
}
```

Basically, we've rewritten the test using a *Behavior Driven Development* style. We didn't need to make a Gherkin here, but we could have.

This has allowed us to get rid of the direct call to the storage engine that we had introduced at the beginning, and by doing it, we make the test more portable. Now it only uses *endpoint* calls, so it can work in different environments such as, for example, a local and a continuous integration one.
