# Task list, *outside-in* TDD sliced in user stories

In this version of the same exercise about creating an application using TDD, we'll work with the project organized in user stories. That is: we have divided the project into features that provide value. Our goal is to show a work methodology that we could put into practice inside real projects.

This project will be done in PHP, with PHPUnit and some components from Symfony framework. The solution is a bit different from that in the previous chapter because this time we are going to limit the scope of our job to the user story, and that imposes some constraints that we didn't have before.

## Adding task to a list

Let's review the definition:

### US 1

* As a User
* I want to add tasks to a to-do list
* So that, I can organize my tasks

To complete this user story we will need, apart from an endpoint to which we can call and a controller that manages it, a use case to add tasks to the list, and a repository to store them. Our use case will be a *command*, so the effect of the action will be a call to the repository storing every new task.

To be able to verify this with a test we don't want to write code that won't be needed in production. For example, we are not going to write methods (yet) to retrieve information from the repository. Strictly speaking, at this moment we don't even know if we are going to need them (*spoiler*: yes, but that will be coding for a future that we don't know). So, at first, we will use a *mock* of repository and check that the right calls are made.

Once we have this clarified, we write a test that will send a POST request to the endpoint to create a new task and will verify that at some time, we are calling to a task repository, trusting that the real implementation will manage it correctly when available.

It is a good idea to start the test from the end, stating what we expect, and build the rest with the needed actions. In this case, we expect the existence of a `TaskRepository` that will be an interface. Also, we will introduce the concept of `Task`.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class TodoListAcceptanceTest extends WebTestCase
{
    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $taskRepository = $this->createMock(TaskRepository::class);
        $task = new Task(1, 'Write a test that fails');
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);

        $client = self::createClient();

        $client->getContainer()->set(TaskRepository::class, $taskRepository);

        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write a test that fails'], JSON_THROW_ON_ERROR)
        );
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

We will have to run the test and implement all the things that it will be asking until we get it failing because the right reason.

The first error message is that we haven't defined `TaskRepository`, so we start from there:

```
Cannot stub or mock class or interface "App\Tests\Katas\TodoList\TaskRepository" which does not exist
```

This error happens in PHP and PHPUnit. In other languages, you could find a different one.

For the moment, my solution is to create it in the same file as the test. If the error message changes, then I will move it to its file.

```php
interface TaskRepository
{

}
```

Now, the test fails because of a different reason, so we have passed this obstacle. We use the Move Class refactoring to move `TaskRepository` to `App\TodoList\Domain\TaskRepository` and then we run again the tests, getting the following error:

```
Error : Class 'App\Tests\Katas\TodoList\Task' not found
```

That is telling us that we have not defined the class `Task`. At the moment, we will create `Task`in the same file, re-running the test to see if the error message changes.

```php
class Task
{
    
}
```

The error is saying that there is not a method `store` in `TaskRepository`, so we can't mock it. We have to introduce it, but we will move `Task` to its place in `App\TodoList\Domain` before. As you can see, we are organizing code using a layered architecture.

After moving `Task`, we add the `store` method to `TaskRepository`:

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;
}
```

The next error is a bit weirder:

```
Symfony\Component\Config\Exception\LoaderLoadException : The file "../src/Controller" does not exist
 (in: /application/config) in /application/config/services.yaml 
 (which is loaded in resource "/application/config/services.yaml").
```

It has to do with the Symfony framework configuration that we are using for this exercise. This message is telling us that there are no files that contain controllers in the given path and namespace. I don't want them there, instead, I want to put them into `App\TodoList\Infrastructure\EntryPoint\Api`. This is because I want to keep a clean architecture, with components organized in layers. Controllers and other entry points to the application are in the infrastructure layer, inside a category `EntryPoint` that, in this case, has a port, related to the communication using the API.

To achieve this, we only have to go to the file `config/services.yaml` and change what is required:

```yaml
    # controllers are imported separately to make sure services can be injected
    # as action arguments even if you don't extend any base controller class
    App\TodoList\Infrastructure\EntryPoint\Api\:
        resource: '../src/TodoList/Infrastructure/EntryPoint/Api'
        tags: ['controller.service_arguments']
```

When we run the test, we get a similar error:

```
Symfony\Component\Config\Exception\LoaderLoadException : The file "../src/TodoList/Infrastructure/EntryPoint/Api" 
 does not exist (in: /application/config) in /application/config/services.yaml
 (which is loaded in resource "/application/config/services.yaml").
```

This is positive because it reflects that we have done right the change in **services.yaml**, but we haven't added a controller in the desired location so it can be loaded and avoid the error. So we add a `TodoListController.php` file to the folder with this code:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


class TodoListController
{

}
```

Running this test throws to new error message. This is the first:

```
"No route found for "POST /api/todo""
```

And that's a framework problem because the HTTP client is calling to an endpoint that is not defined anywhere yet. We solve this by configuring it in `routes.yaml`.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']
```

As we always do after a change, we run the test, that now will shout that there is not a method in the controller in charge of managing the response to this end point.

```
"The controller for URI "/api/todo" is not callable. 
Expected method "addTask" on class "App\TodoList\Infrastructure\EntryPoint\Api\TodoListController"...
```

We can implement it this way:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


class TodoListController
{
    public function addTask()
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

It is a single line that throws an exception to mark that the method is not implemented. We do it this way so the test itself stated that we have something not implemented. An empty method body would not tell us anything and, in many situations, it would be easy to lose track of the thing we have left pending to write.

If we run the test, it throws exactly that error:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask"
```

But also this one, from the test itself.

```
Expectation failed for method name is equal to 'store' when invoked 1 time(s).
Method was expected to be called 1 times, actually called 0 times.
```

This is the error which we will be expecting from the test as we wrote it. There are no framework configuration errors. I tell us that a Task is never stored in the repository. In other words: no production code executes the desired behavior.

Those two errors tell as that is the time to implement.

And to do that, we need to go one step into the application. In our example, this is `TodoListController`. At this point, we leave the acceptance test loop and we enter in a cycle of unitary tests to develop `TodoListController::addTask`.

## Designing *in red*

The acceptance test is not passing and it is asking us to implement something in `TodoListController`. To do so, we are going to think about how we want the controller to be and it will delegate the job to other objects.

In particular, we want the controller to be a very tiny layer in charge of:

* Getting the necessary information from the request
* Pass it to a use case to do what is needed
* Get the response from the use case and send it back to the *endpoint*

In a classic approach, we would implement the complete solution in the controller and, then, we would be moving logic to the required components.

Instead of that, in the mockist approach, we design how this implementation level would look like and we use doubles for collaborations we could need. For example, this is our test:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{

    /** @test */
    public function shouldAddTask(): void
    {
        $addTaskHandler = $this->createMock(AddTaskHandler::class);
        $addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');
        
        $todoListController = new TodoListController($addTaskHandler);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );
        
        $response = $todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }
}
```

In this test, two things are verified. On the one hand, that we return a response with a status code of 201 (created). On the other, that we will have a use case named `AddTaskHandler` in charge to process the creation of the task provided its descriptions, that it's received as a payload in the request.

When we run the test, we start getting the expected error. The first on is that we don't have any `AddTaskHandler`. Again, I'll start by adding it to the test fail, and I'll move it in the next step. In fact, it's literally what the error says:

```
Cannot stub or mock class or interface "App\Tests\TodoList\Infrastructure\EntryPoint\Api\AddTaskHandler" 
which does not exist
```

So, we add:

```php
class AddTaskHandler
{

}
```

Running the test now will ask us to implement the method `execute` that is not defined. Before doing so, we are going to move `AddTaskHandler`, that is the use case, to its place in the application layer: `App\TodoList\Application`. Next, we add the method including our "not implemented" exception.

```php
namespace App\TodoList\Application;

class AddTaskHandler
{
    public function execute(): void
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

This way, what will happen is as follows: once we've implemented the controller, we'll see that its unitary test passes, because we are using the `AddTaskHandler` double and we are not calling to the real code. This will happen when running the acceptance test, which will be pointing us to implement `AddTaskHandler` and go one lever deeper in the application.

The next error is well known:

```
RuntimeException : Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
```

This indicates that the test is calling the `addTask` method, not implemented yet. It is just where we want to be. We will implement logic in `TodoListController::addTask` to make the test pass:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    /** @var AddTaskHandler */
    private AddTaskHandler $addTaskHandler;

    public function __construct(AddTaskHandler $addTaskHandler)
    {
        $this->addTaskHandler = $addTaskHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);

        $this->addTaskHandler->execute($payload['task']);
        return new JsonResponse('', Response::HTTP_CREATED);
    }
}
``` 

The test passes!

We could go slower here to drive the implementation with smaller steps, but I think that it's better to do it in only one because the logic is not too complex, and this way we're not too dispersed. The important thing, however, is that we have achieved the goal of developing this controller with a unitary test that is passing right now.

Given that the unitary test is passing, we don't have any more work to do at this level. Nevertheless, I'm going to make a little refactoring to hide the details of getting the payload from the request, leaving the body of the controller a bit cleaner and easy to follow.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    /** @var AddTaskHandler */
    private AddTaskHandler $addTaskHandler;

    public function __construct(AddTaskHandler $addTaskHandler)
    {
        $this->addTaskHandler = $addTaskHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

## Returning to the acceptance test

Once we've made the unit test pass, we have to return to the acceptance level so that it tells us how to proceed. We execute it and we get the following:

```
RuntimeException: "Implement App\TodoList\Application\AddTaskHandler::App\TodoList\Application\AddTaskHandler::execute" 
```

Now it's time to go a little bit deeper in the application and move on to the `AddTaskHandler` use case. What we expect from this UseCase is that it uses the information it receives to create a task and stores it in TaskRepository.

To create a task, we'll need to give it an ID, which we're going to ask from the repository itself. The repository will have an appropriate method.

Para crear una tarea, necesitaremos asignarle un ID, el cual le vamos a pedir al propio repositorio que tendrá un método a propósito. 

Esto lo podemos expresar con el siguiente test unitario.

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class AddTaskHandlerTest extends TestCase
{
    /** @test */
    public function shouldCreateAndStoreATask(): void
    {
        $task = new Task(1, 'Task Description');
        
        $taskRepository = $this->createMock(TaskRepository::class);
        
        $taskRepository
            ->method('nextIdentity')
            ->willReturn(1);
        
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);
        
        $addTaskHandler = new AddTaskHandler($taskRepository);
        
        $addTaskHandler->execute('Task Description');
    }
}
```


Ejecutamos el test. Obtenemos primero este error:

```
Trying to configure method "nextIdentity" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

Añadimos el método en la interfaz:

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;
    
    public function nextIdentity(): int;
}
```

Lo que genera este error:

```
RuntimeException : Implement App\TodoList\Application\AddTaskHandler::App\TodoList\Application\AddTaskHandler::execute
```

Y estamos listos para implementar el caso de uso. Este código debería bastar:

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class AddTaskHandler
{
    /** @var TaskRepository */
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(string $taskDescription): void
    {
        $id = $this->taskRepository->nextIdentity();

        $task = new Task($id, $taskDescription);

        $this->taskRepository->store($task);
    }
}
```

El código es suficiente para hacer pasar el test, por lo que podemos volver al nivel de aceptación.

## Nuevo ciclo

Al relanzar el test de aceptación nos encontramos que éste pasa. Sin embargo, la historia de usuario no está implementada aún ya que no tenemos un repositorio concreto en el que se estén guardando `Task`. De hecho, nuestras clases `Task` no tienen ningún código todavía.

El motivo es que estamos usando un *mock* de `TaskRepository` en el test de aceptación. Nos interesaría dejar de usarlo para que `TodoList` utilice una implementación concreta. El problema que tendríamos ahora es que de momento no vamos a tener métodos con los que explorar el contenido del repositorio y verificar el test. Vamos a hacer esto en dos fases.

En la primera simplemente eliminamos el uso del *mock* y verificamos que la respuesta del API devuelve el código 201 (created).

```php
namespace App\Tests\Katas\TodoList;

use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $client = self::createClient();

        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write a test that fails'], JSON_THROW_ON_ERROR)
        );

        $response = $client->getResponse();

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }


    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

Antes de continuar, tenemos que eliminar la definición del servicio que hicimos antes en `services_test.yaml`. Como es el único que tenemos declarado aquí, podemos eliminar el archivo sin problema.

Y al ejecutar el test, nos aparece el siguiente error del *framework*:

```
Cannot autowire service "App\TodoList\Application\AddTaskHandler": argument "$taskRepository" of method "__construct()"
```

Esto ocurre porque sólo tenemos una interfaz de `TaskRepository` y necesitaríamos una implementación concreta que usar. De este modo, tenemos un error que nos permite avanzar en el desarrollo. Necesitaremos un test para implementar `FileTaskRepository`, un repositorio basado en un sencillo archivo de texto para guardar los objetos serializados:

```php
namespace App\Lib;


class FileStorageEngine
{
    private string $filePath;

    public function __construct($filePath)
    {
        $this->filePath = $filePath;
    }

    public function loadObjects(string $class): array
    {
        if (!file_exists($this->filePath)) {
            return [];
        }

        $file = fopen($this->filePath, 'rb');
        $objects = unserialize(fgets($file), ['allowed_classes' => [$class]]);
        fclose($file);

        return $objects;
    }

    public function persistObjects(array $objects): void
    {
        $file = fopen($this->filePath, 'wb');
        fwrite($file, serialize($objects));
        fclose($file);
    }
}
```

En primer lugar vamos a crear una implementación por defecto para `FileTaskRepository` en su lugar, que será `App\TodoList\Infrastructure\Persistence`:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    public function store(Task $task): void
    {
        throw new \RuntimeException('Implement store() method.');
    }

    public function nextIdentity(): int
    {
        throw new \RuntimeException('Implement nextIdentity() method.');
    }
}
```

Al volver a ejecutar el test de aceptación se producen dos errores. Uno nos dice que tenemos que implementar el método `nextIdentity` del repositorio. El otro, que es un error propio del test, nos informa de que el *end point* devuelve el código 500 en lugar de 201. Es lógico porque la implementación que tenemos ahora de FileTaskRepository fallará de forma fatal.

Pero es una buena noticia, porque nos dice por dónde seguir. Así que crearemos un nuevo test unitario para guiar el desarrollo de `FileTaskRepository`. En este test simulamos distinto número de objetos en el almacenamiento para asegurar la implementación correcta.

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $storageEngine = $this->createMock(FileStorageEngine::class);

        $taskRepository = new FileTaskRepository($storageEngine);
        $storageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $taskRepository->nextIdentity());
        self::assertEquals(2, $taskRepository->nextIdentity());
        self::assertEquals(3, $taskRepository->nextIdentity());
    }
}
```

Con este test pasando, volvemos al test de aceptación, que vuelve a fallar. El *end point* devuelve un error 500 porque no tenemos una implementación del método `store` en `FileTaskRepository`.

Introduciremos un nuevo test, aunque antes lo hemos refactorizado un poco a fin de que sea más fácil introducir los cambios:

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $this->taskRepository->nextIdentity());
        self::assertEquals(2, $this->taskRepository->nextIdentity());
        self::assertEquals(3, $this->taskRepository->nextIdentity());
    }

    /** @test */
    public function shouldStoreATask(): void
    {
        $task = new Task(1, 'Task Description');

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn([]);
        $this->fileStorageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }
}
```

Esta es nuestra implementación para pasar el test:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    /** @var FileStorageEngine */
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }
}
```

Tenemos que implementar el método `Task::id`, lo que nos hace introducir también un constructor:

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }
}
```

La implementación hace pasar el test. Para no alargarnos no introduciré más ejemplos, que sería lo propio para tener más confianza en el comportamiento del test. Pero de momento nos vale para entender el proceso.

Como estamos en verde, volvemos al test de aceptación para comprobar qué avances hemos tenido. Y al ejecutarlo, el test de aceptación pasa, indicando que la feature está completa. O casi, ya que por el momento no tenemos forma de saber si las tareas se han almacenado o no.

Una posibilidad es obtener el contenido de `FileStorageEngine` y ver si allí se encuentran nuestras tareas. No nos obliga a implementar nada en el código de producción:

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $client = self::createClient();

        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write a test that fails'], JSON_THROW_ON_ERROR)
        );

        $response = $client->getResponse();

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());

        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }


    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

El test verifica que hemos guardado una tarea en el repositorio, confirmando que la primera historia de usuario está implementada. Puede ser buen momento para examinar lo que hemos hecho y ver si podemos hacer algún refactor que pueda facilitar los siguientes pasos del desarrollo.

Empecemos con el test de aceptación:

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $response = $this->whenWeRequestToCreateATaskWithDescription('Write a test that fails');

        $this->thenResponseShouldBeSuccesful($response);

        $this->thenTheTaskIsStored();
    }


    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    private function whenWeRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }

    private function thenResponseShouldBeSuccesful(Response $response): void
    {
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    private function thenTheTaskIsStored(): void
    {
        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }
}
```

**TodoListControllerTest**:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->todoListController = new TodoListController($this->addTaskHandler);
    }


    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }
}
```

Hay otros pequeños cambios en archivos, pero no los vamos a detallar aquí.


## Ver las tareas de la lista

### US 2

* As a User
* I want to see the task in my to-do list
* So that, I can know what I have to do next

Nuestra segunda historia requiere su propio *end point*, controlador y caso de uso. Ya tenemos un repositorio de tareas, al cual tendremos que añadir un método con el que obtener las lista completa.

Como tenemos una implementación *real* del repositorio ya no tenemos que usar un *mock* como nos hizo falta antes para poder arrancar el desarrollo. En una situación en la que estuviésemos usando una persistencia en base de datos o similar, posiblemente necesitaríamos una implementación *fake*, como un repositorio en memoria o incluso este simple repositorio en archivo que estamos utilizando, que necesitamos por el problema de la persistencia entre requests de PHP.

Esta es la primera versión del test de aceptación para esta historia de usuario:

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $response = $this->whenWeRequestToCreateATaskWithDescription('Write a test that fails');

        $this->thenResponseShouldBeSuccesful($response);

        $this->thenTheTaskIsStored();
    }

    /** @test */
    public function asUserIWantToSeeTheTasksInMyTodoList(): void
    {
        $expectedList = [
            '[ ] 1. Write a test that fails',
            '[ ] 2. Write code to make the test pass'
        ];
        
        $this->apiCreateTaskWithDescription('Write a test that fails');
        $this->apiCreateTaskWithDescription('Write code to make the test pass');
        
        $this->client->request(
            'GET',
            '/api/todo'
        );

        $response =  $this->client->getResponse();
        
        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        
        $taskList = json_decode($response->getContent(), true);
        
        self::assertEquals($expectedList, $taskList);
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    private function whenWeRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        return $this->apiCreateTaskWithDescription($taskDescription);
    }

    private function thenResponseShouldBeSuccesful(Response $response): void
    {
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    private function thenTheTaskIsStored(): void
    {
        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }

    private function apiCreateTaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }
}
```

Así que lo ejecutamos y, como antes, nos vamos fijando en los errores que lanza para arreglarlos hasta que el test falle por las razones correctas. En este caso podemos ver dos errores relacionados. 

El primero es que no hay una ruta adecuada para el *end point*.

```
"No route found for "GET /api/todo": Method Not Allowed (Allow: POST)"
```

Lo que, por supuesto, causa el error en el test al verificar el código de estado:

```
Failed asserting that 405 matches expected 200.
```

Configuramos la ruta en **routes.yaml**:

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']
```

Lanzamos el test. El error es diferente, lo que indica que hemos hecho el cambio correctamente, pero ahora nos hace falta el controlador específico:

```
"The controller for URI "/api/todo" is not callable. Expected method "getTaskList" on class "App\TodoList\Infrastructure\EntryPoint\Api\TodoListController"
```

Así que añadimos nuestra implementación *vacía* inicial:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    /** @var AddTaskHandler */
    private AddTaskHandler $addTaskHandler;

    public function __construct(AddTaskHandler $addTaskHandler)
    {
        $this->addTaskHandler = $addTaskHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

Al volver a lanzar el test, se lanza la excepción que nos indica que necesitamos implementar algo. Es el momento de volver al test unitario de `TodoListController`. Es importante aprender a identificar cuando tenemos que movernos entre el ciclo del test de aceptación y el ciclo de tests unitarios.

El nuevo test nos ayuda a introducir el nuevo caso de uso `GetTaskListHandler`, pero también nos plantea un problema interesante: ¿qué debería devolver `GetTaskListHandler`, objetos `Task` o una representación de estos?

En este caso, lo más correcto sería utilizar algún tipo de `DataTransformer` y aplicar un patrón `Strategy` de modo que `TodoListController` le indique al caso de uso qué `DataTransformer` quiere usar. Este *transformer* se puede pasar como dependencia al controlador y este se lo enviará al caso de uso como parámetro.

Como puedes ver. ahora estamos literalmente diseñando. Así que vamos a ver cómo queda el test.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer
        );
    }

    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }

    /** @test */
    public function shouldGetTaskList(): void
    {
        $expectedList = [
            '[ ] 1. Task Description',
            '[ ] 2. Task Description',
        ];
        $this->getTaskListHandler
            ->expects(self::once())
            ->method('execute')
            ->with($this->taskListTransformer)
            ->willReturn($expectedList);

        $response = $this->todoListController->getTaskList(new Request());

        self::assertEquals(200, $response->getStatusCode());

        $list = json_decode($response->getContent(), true);

        self::assertEquals($expectedList, $list);
    }
}
```

En este punto, sólo necesitamos `TaskListTransformer` para que el controlador lo pase al caso de uso. Si lanzamos el test, fallará porque no tenemos aún definida la clase `GetTaskListHandler`. Introducimos una implementación inicial.

```php
class GetTaskListHandler
{
    
}
```

Lanzando el test de nuevo, vemos que ahora nos pide `TaskListTransformer`. Primero movemos `GetTaskListHandler` a su lugar en `App\TodoList\Application`. Luego creamos `TaskListTransformer`.

```php
class TaskListTransformer
{
    
}
```

Comprobamos de nuevo el resultado del test, que ahora nos dice que nos falta un método execute en `GetTaskListHandler`. Igual que hicimos antes, movemos primero la clase `TaskListTransformer` a su lugar.

En principio yo lo introduciría en `App\TodoList\Infrastructure\EntryPoint\Api` puesto que la razón de ser del transformer es preparar una respuesta específica para el API. Pero eso sería para la implementación concreta que vayamos a usar. Si lo hacemos así tendremos una dependencia mal orientada, pues estaría apuntando de Aplicación a Infraestructura. Para invertirla, tendremos que poner `TaskListTransformer` en la capa de aplicación como interface. Su lugar sería: `App\TodoList\Application\TaskListTransformer`.

Una vez recolocado nos ocupamos de añadir el método execute en `GetTaskListHandler`.

```php
namespace App\TodoList\Application;

class GetTaskListHandler
{
    public function execute(TaskListTransformer $taskListTransformer): array
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Con este añadido, al ejecutar el test conseguimos que falle porque vemos que ha saltado la excepción que nos pide implementar `getTaskList` en el controlador:

```
RuntimeException : Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
```

Y podemos implementar lo necesario para que pase el test:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(Request $request): Response
    {
        $taskList = $this->getTaskListHandler->execute($this->taskListTransformer);

        return new JsonResponse($taskList, Response::HTTP_OK);
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

Se puede observar que el controlador tiene muchas dependencias. Esto se puede solucionar con un bus de comandos o dividiendo la clase en otras más pequeñas, pero no lo vamos a hacer en este ejercicio para no perder el foco.

En cualquier caso, el test pasa, lo que nos indica que es el momento de moverse de nuevo al ciclo del test de aceptación.

Este seguirá fallando, como cabría esperar:

```
PHP Exception RuntimeException: "Implement App\TodoList\Application\GetTaskListHandler::execute" 
```

Fallo que nos dice que el siguiente paso es desarrollar con un test unitario el caso de uso `GetTaskListHandler`.

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class GetTaskListHandlerTest extends TestCase
{
    /** @test */
    public function shouldGetExistingTasks(): void
    {
        $expectedList = [
            '[ ] 1. Write a test that fails',
            '[ ] 2. Write code to make the test pass',
        ];

        $taskList = [
            new Task(1, 'Write a test that fails'),
            new Task(2, 'Write code to make the test pass'),
        ];

        $tasksRepository = $this->createMock(TaskRepository::class);
        $tasksRepository
            ->method('findAll')
            ->willReturn($taskList);

        $taskListTransformer = $this->createMock(TaskListTransformer::class);
        $taskListTransformer
            ->expects(self::once())
            ->method('transform')
            ->with($taskList)
            ->willReturn($expectedList);

        $getTaskListHandler = new GetTaskListHandler($tasksRepository);
        $list = $getTaskListHandler->execute($taskListTransformer);

        self::assertEquals($expectedList, $list);
    }
}
```

Al lanzar este test, nos pide añadir el método `findAll` en el repositorio.

```
Trying to configure method "findAll" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

Esto lo hacemos en la interfaz y en la implementación concreta:

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;

    public function nextIdentity(): int;

    public function findAll(): array;
}

```

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    /** @var FileStorageEngine */
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        throw new \RuntimeException('Implement findAll() method.');
    }
}
```

Y lo mismo para el método `transform` en `TaskListTransformer`:

```
Trying to configure method "transform" which cannot be configured because it does not exist, 
has not been specified, is final, or is static
```

El cual quedará así, una vez redefinido como interfaz:

```php
namespace App\TodoList\Application;

interface TaskListTransformer
{
    public function transform(array $taskList): array;
}
```

Con estos cambios, el test ahora fallará para decirnos que necesitamos implementar el método execute del caso de uso, que es justo donde queríamos estar:

```
RuntimeException : Implement App\TodoList\Application\GetTaskListHandler::execute
```

Y he aquí la implementación que hace pasar el test.

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\TaskRepository;
use App\TodoList\Application\TaskListTransformer;

class GetTaskListHandler
{
    /** @var TaskRepository */
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(TaskListTransformer $taskListTransformer): array
    {
        $tasks = $this->taskRepository->findAll();

        return $taskListTransformer->transform($tasks);
    }
}
```

Ahora que hemos vuelto a verde, regresaremos al ciclo de aceptación. Al lanzar el test el resultado es un mensaje de error nuevo, que nos pide implementar `findAll` en `FileTaskRepository`.

```
RuntimeException: "Implement findAll() method."
```

Esto requiere un test unitario.

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $this->taskRepository->nextIdentity());
        self::assertEquals(2, $this->taskRepository->nextIdentity());
        self::assertEquals(3, $this->taskRepository->nextIdentity());
    }

    /** @test */
    public function shouldStoreATask(): void
    {
        $task = new Task(1, 'Task Description');

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn([]);
        $this->fileStorageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }

    /** @test */
    public function shouldGetStoredTasks(): void
    {
        $storedTasks = [
            1 => new Task(1, 'Write a test that fails'),
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        self::assertEquals($storedTasks, $this->taskRepository->findAll());
    }
}
```

Al ejecutarlo, nos pedirá:

```
RuntimeException : Implement findAll() method.
```

Así que vamos a ello:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{

    /** @var FileStorageEngine */
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        return $this->fileStorageEngine->loadObjects(Task::class);
    }
}
```

Ahora el test unitario pasa, con lo cual tenemos implementado buena parte del repositorio. ¿Será suficiente para hacer pasar el test de aceptación?

No, todavía tenemos cosas pendientes. En este momento se nos reclama introducir una implementación concreta de `TaskListTransformer`.

Ahora nos toca introducir un nuevo test unitario para desarrollar el *Transformer* concreto, que ubicaremos en `App\TodoList\Infrastructure\EntryPoint\Api`, ya que es el controlador quien está interesado en usarlo. Lo denominaremos `StringTaskListTransformer` ya que convierte a `Task` en una representación en forma de `string`.

Este nos va a  suponer un pequeño reto de diseño. No disponemos todavía de formas de acceder a las propiedades de `Task`, una entidad que tampoco hemos tenido que desarrollar más hasta ahora, y lo cierto es que no deberíamos condicionar su implementación a este tipo de necesidades. En un sistema más real y sofisticado podríamos aplicar un patrón *Visitor* o similar. En este caso, lo que haremos será pasar una plantilla a `Task` para que nos la devuelva cubierta con sus datos.

Como `Task` es una entidad prefiero no *mockearla*, así que el test quedará de esta forma:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Domain\Task;
use App\TodoList\Infrastructure\EntryPoint\Api\StringTaskListTransformer;
use PHPUnit\Framework\TestCase;

class StringTaskListTransformerTest extends TestCase
{
    /** @test
     * @dataProvider examplesProvider
     */
    public function shouldTransformList($tasksList, $expected): void
    {
        $taskListTransformer = new StringTaskListTransformer();

        $result = $taskListTransformer->transform($tasksList);

        self::assertEquals($expected, $result);
    }

    public function examplesProvider(): array
    {
        return [
          [[], []],
          [[new Task(1, 'Task Description')], ['[ ] 1. Task Description']]
        ];
    }
}

```

Y el código de producción podría ser este:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\TaskListTransformer;

class StringTaskListTransformer implements TaskListTransformer
{
    public function transform(array $taskList): array
    {
        $transformed = [];

        foreach ($taskList as $task) {
            $transformed[] = $task->representedAs('[:check] :id. :description');
        }

        return $transformed;
    }
}

```

El test lanzará un error para decirnos que no está implementado el método `representedAs` en `Task`, por lo que podemos añadirlo.

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(): string
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Salvando las distancias, podemos usar el test actual como test de aceptación. Si lo ejecutamos veremos que se lanza la excepción:

```
RuntimeException : Implement App\TodoList\Domain\Task::representedAs
```

Lo que nos indicaría la necesidad de pasar al siguiente nivel y crear un test unitario para desarrollar `Task`, o al menos el método `representedAs`. Otra opción, sería desarrollar `Task` bajo la cobertura del test actual, pero no es muy buena idea ya que el test podría requerir de ejemplos que no aportan nada realmente al test y que son relevantes sólo para `task`.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');
        
        $representation = $task->representedAs('[:check] :id. :description');
        
        self::assertEquals($expected, $representation);
    }
}
```

Por el momento esta implementación ya nos iría bien. 

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }
}
```

Así que podríamos subir un nivel y volver al test anterior del *Transformer*, que pasa sin más problemas.

Con este test en verde, regresamos al nivel de aceptación, que también pasa, indicando que hemos terminado de desarrollar esta historia de usuario.

## Marcar tareas completadas

### US-3

* As a User
* I want to check a task when it is done
* So that, I can see my progress

La tercera historia de usuario se construye fácilmente a partir de las dos anteriores, ya que nuestra aplicación ya permite introducir tareas y ver la lista. Por eso, antes de empezar con el desarrollo refactorizaremos el test de aceptación para que sea más sencillo extenderlo. De hecho, hasta podemos reutilizar algunas partes. Este es el resultado, ya con el nuevo test de aceptación.

```php
namespace App\Tests\Katas\TodoList;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $response = $this->whenWeRequestToCreateATaskWithDescription('Write a test that fails');

        $this->thenResponseShouldBeSuccesful($response);

        $this->thenTheTaskIsStored();
    }

    /** @test */
    public function asUserIWantToSeeTheTasksInMyTodoList(): void
    {
        $this->givenIHaveAddedTasks();

        $response = $this->whenIRequestTheListOfTasks();

        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass'
            ],
            $response
        );
    }

    /** @test */
    public function asUserIWantToMarkTasksAsCompleted(): void
    {
        $this->givenIHaveAddedTasks();
        
        $this->client->request(
            'PATCH',
            '/api/todo/1',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)

        );
        
        $patchResponse = $this->client->getResponse();

        self::assertEquals(Response::HTTP_OK, $patchResponse->getStatusCode());
                
        $response = $this->whenIRequestTheListOfTasks();

        $this->thenICanSeeAddedTasksInTheList(
            [
                '[√] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass'
            ],
            $response
        );
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    private function whenWeRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        return $this->apiCreateTaskWithDescription($taskDescription);
    }

    private function thenResponseShouldBeSuccesful(Response $response): void
    {
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    private function thenTheTaskIsStored(): void
    {
        $storage = new FileStorageEngine('repository.data');
        $tasks = $storage->loadObjects(Task::class);

        self::assertCount(1, $tasks);
        self::assertEquals(1, $tasks[1]->id());
    }

    private function apiCreateTaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }

    private function whenIRequestTheListOfTasks(): Response
    {
        $response = $this->apiGetTasksList();

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        return $response;
    }

    private function apiGetTasksList(): Response
    {
        $this->client->request(
            'GET',
            '/api/todo'
        );

        return $this->client->getResponse();
    }

    private function givenIHaveAddedTasks(): void
    {
        $this->apiCreateTaskWithDescription('Write a test that fails');
        $this->apiCreateTaskWithDescription('Write code to make the test pass');
    }

    private function thenICanSeeAddedTasksInTheList(array $expectedTasks, Response $response): void
    {
        $taskList = json_decode($response->getContent(), true);

        self::assertEquals(
            $expectedTasks, $taskList);
    }
}
```

Al lanzar el test, y como era de esperar, falla porque no se encuentra la ruta al *end point*:

```
"No route found for "PATCH /api/todo/1"
```

Y, como hemos hecho antes, tendremos que definirla y crear un controlador que la gestione. En primer lugar, la definición de la ruta en **routes.yaml**.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']

api_get_task_list:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
  methods: ['GET']

api_mark_task_completed:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
  methods: ['PATCH']
```

Una nueva ejecución del test nos indica que falta un controlador:

```
"The controller for URI "/api/todo/1" is not callable. Expected method "markTaskCompleted"
```

Y añadimos uno vacío:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(Request $request): Response
    {
        $taskList = $this->getTaskListHandler->execute($this->taskListTransformer);

        return new JsonResponse($taskList, Response::HTTP_OK);
    }

    public function markTaskCompleted(int $taskId): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

El error ahora es:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted"
```

Y el test falla porque espera que ese *end point* esté funcionando como es debido y respondiendo, pero todavía está sin implementar. Por tanto, nos movemos al nivel unitario para definir la funcionalidad del controlador.

Como en los casos anteriores, implementar la funcionalidad require además del controlador un caso de uso y utilizar el repositorio para recuperar la tarea que se quiere marcar, y volver a guardarla. Por tanto, la clave del test será esperar que se ejecute el caso de uso con los parámetros adecuados.

Así que, el test quedaría más o menos así;

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }


    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(201, $response->getStatusCode());
    }

    /** @test */
    public function shouldGetTaskList(): void
    {
        $expectedList = [
            '[ ] 1. Task Description',
            '[ ] 2. Task Description',
        ];
        $this->getTaskListHandler
            ->expects(self::once())
            ->method('execute')
            ->with($this->taskListTransformer)
            ->willReturn($expectedList);

        $response = $this->todoListController->getTaskList(new Request());

        self::assertEquals(200, $response->getStatusCode());

        $list = json_decode($response->getContent(), true);

        self::assertEquals($expectedList, $list);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $this->markTaskCompletedHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::COMPLETED_TASK_ID, true);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->markTaskCompleted(self::COMPLETED_TASK_ID, $request);

        self::assertEquals(200, $response->getStatusCode());
    }
}
```

Una vez que tenemos el test, lo lanzamos. El resultado es que nos pide crear la clase `MarkTaskCompletedHandler`.

```
Cannot stub or mock class or interface "App\Tests\TodoList\Infrastructure\EntryPoint\Api\MarkTaskCompletedHandler" which does not exist
```

La creamos en el propio test y luego la movemos a su ubicación en `App\TodoList\Application`. A continuación nos pedirá crear el método `execute`.

```
Trying to configure method "execute" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

El cual prepararemos de esta forma:

```php
namespace App\TodoList\Application;


class MarkTaskCompletedHandler
{
    public function execute(int $taskId, bool $completed): void
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Con esto ya tenemos lo necesario para implementar la acción del controlador, cosa que hacemos, porque el siguiente error nos lo indica:

```
RuntimeException : Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
```

Este es el código que hará pasar el test del controlador.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function getTaskList(Request $request): Response
    {
        $taskList = $this->getTaskListHandler->execute($this->taskListTransformer);

        return new JsonResponse($taskList, Response::HTTP_OK);
    }

    public function markTaskCompleted(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->markTaskCompletedHandler->execute($taskId, $payload['completed']);

        return new JsonResponse('', Response::HTTP_OK);
    }

    private function obtainPayload(Request $request): array
    {
        return json_decode($request->getContent(), true, 512, JSON_THROW_ON_ERROR);
    }
}
```

Una vez que el test del controlador pasa, tendremos que volver a lanzar el test de aceptación. Este nos indicará el siguiente paso:

```
RuntimeException: "Implement App\TodoList\Application\MarkTaskCompletedHandler::execute"
```

Nos requiere implementar el caso de uso. Por lo tanto, necesitamos un nuevo test unitario:

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class MarkTaskCompletedHandlerTest extends TestCase
{
    private const COMPLETED_TASK_ID = 1;

    /** @test */
    public function shouldMarkTaskAsCompletedAndPersist(): void
    {
        $task = new Task(self::COMPLETED_TASK_ID, 'Task Description');
        
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('retrieve')
            ->with(self::COMPLETED_TASK_ID)
            ->willReturn($task);

        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);

        $markTaskCompletedHandler = new MarkTaskCompletedHandler($taskRepository);

        $markTaskCompletedHandler->execute(self::COMPLETED_TASK_ID, true);
    }
}
```

La ejecución del test arroja el siguiente error:

```
Trying to configure method "retrieve" which cannot be configured because it does not exist, has not been specified, is final, or is static
```

Hasta ahora no habíamos requerido este método en el repositorio, por lo cual tendremos que añadirlo a la interfaz.

```php
namespace App\TodoList\Domain;

interface TaskRepository
{
    public function store(Task $task): void;

    public function nextIdentity(): int;

    public function findAll(): array;

    public function retrieve(int $taskId): Task;
}
```

Esto será suficiente para poder seguir ejecutando el test y que nos pida implementar el método `execute` en el caso de uso.

```
RuntimeException : Implement App\TodoList\Application\MarkTaskCompletedHandler::execute
```

Así que vamos a ello. Es bastante sencillo:

```php
namespace App\TodoList\Application;


use App\TodoList\Domain\TaskRepository;

class MarkTaskCompletedHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, bool $completed): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        if ($completed) {
            $task->markCompleted();
        }
        
        $this->taskRepository->store($task);
    }
}
```

Al volver a ejecutar el test fallará. Esto es porque no tenemos definido el método `Task::markCompleted`:

```
Error : Call to undefined method App\TodoList\Domain\Task::markCompleted()
```

Siempre que tenemos un error de este tipo, tendremos que profundizar y entrar en un nuevo test unitario. En este caso, para implementar este método en `Task`. No tenemos acceso directo a la propiedad `complete`, que aún no tenemos definida siquiera, pero podemos controlar su estado indirectamente gracias a su representación.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();
        
        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }
}
```

La implementación es bastante sencilla:

```php
namespace App\TodoList\Domain;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }
}
```

Con esto, el test de `Task` pasa y podemos volver al nivel del caso de uso. Al lanzar el test de nuevo, vemos que también pasa, por lo que podemos volver al nivel del test de aceptación.

Este test, en cambio, no pasará porque espera que implementemos el método `retrieve` en `FileTaskRepository`, que aún no lo tenemos. Nos vamos al test.

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    /** @test */
    public function shouldProvideNextIdentityCountingExistingObjects(): void
    {
        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                [],
                ['Task'],
                ['Task', 'Task']
            );

        self::assertEquals(1, $this->taskRepository->nextIdentity());
        self::assertEquals(2, $this->taskRepository->nextIdentity());
        self::assertEquals(3, $this->taskRepository->nextIdentity());
    }

    /** @test */
    public function shouldStoreATask(): void
    {
        $task = new Task(1, 'Task Description');

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn([]);
        $this->fileStorageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }

    /** @test */
    public function shouldGetStoredTasks(): void
    {
        $storedTasks = [
            1 => new Task(1, 'Write a test that fails'),
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        self::assertEquals($storedTasks, $this->taskRepository->findAll());
    }

    /** @test */
    public function shouldRetrieveATaskByItsId(): void
    {
        $expectedTask = new Task(1, 'Write a test that fails');
        
        $storedTasks = [
            1 => $expectedTask,
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        self::assertEquals($expectedTask, $this->taskRepository->retrieve(1));
    }
}
```

Como era de esperar, el test nos reclamará escribir el método retrieve.

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
       $tasks = $this->fileStorageEngine->loadObjects(Task::class);

       $tasks[$task->id()] = $task;

       $this->fileStorageEngine->persistObjects($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        return $this->fileStorageEngine->loadObjects(Task::class);
    }

    public function retrieve(int $taskId): Task
    {
        $tasks = $this->fileStorageEngine->loadObjects(Task::class);

        return $tasks[$taskId];
    }
}
```

Y con este el test de `FileTaskRepository` está en verde. Aprovechamos para hacer un pequeño refactor, de modo que la dependencia esté controlada:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    public function store(Task $task): void
    {
        $tasks = $this->findAll();

        $tasks[$task->id()] = $task;

        $this->persistAllInStorage($tasks);
    }

    public function nextIdentity(): int
    {
        $tasks = $this->findAll();

        return count($tasks) + 1;
    }

    public function findAll(): array
    {
        return $this->getAllFromStorage();
    }

    public function retrieve(int $taskId): Task
    {
        $tasks = $this->findAll();

        return $tasks[$taskId];
    }

    private function getAllFromStorage(): array
    {
        return $this->fileStorageEngine->loadObjects(Task::class);
    }

    private function persistAllInStorage(array $tasks): void
    {
        $this->fileStorageEngine->persistObjects($tasks);
    }
}
```

Y ahora volveremos a lanzar el test de aceptación, que esta vez pasa limpiamente.

## Siguientes pasos

En este punto tenemos las tres historias de usuario implementadas. ¿Qué nos interesa hacer ahora?

Una de las mejoras que podemos hacer en este momento es arreglar el test de aceptación para que pueda usarse como test de QA. Ahora que hemos desarrollado todos los componentes implicados es posible hacer que el test sea más expresivo y más útil para describir el comportamiento implementado.

Los tests unitarios nos pueden valer tal como están. Una objeción típica es que al estar basados en *mocks* son frágiles por su acoplamiento a la implementación. Sin embargo, debemos recordar que básicamente hemos estado diseñando los componentes que necesitábamos y la forma en que queríamos hacerlos interactuar. En otras palabras: no es previsible que esta implementación vaya a cambiar demasiado hasta el punto de invalidar los test. Por otro lado, los tests unitarios que hemos usado, caracterizan el comportamiento concreto de cada unidad. En conjunto son rápidos y nos proporcionan la resolución necesaria como para ayudarnos a diagnosticar rápidamente los problemas que puedan surgir.

Así que vamos a retocar el test de aceptación para que tenga un mejor lenguaje de negocio:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    /** @test */
    public function asUserIWantToAddTaskToAToDoList(): void
    {
        $this->givenIRequestToCreateATaskWithDescription('Write a test that fails');
        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
            ],
            $response
        );
    }

    /** @test */
    public function asUserIWantToSeeTheTasksInMyTodoList(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );
        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass',
            ],
            $response
        );
    }

    /** @test */
    public function asUserIWantToMarkTasksAsCompleted(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );
        $this->givenIMarkATaskAsCompleted(1);
        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[√] 1. Write a test that fails',
                '[ ] 2. Write code to make the test pass',
            ],
            $response
        );
    }

    private function givenIRequestToCreateATaskWithDescription(string $taskDescription): Response
    {
        return $this->apiCreateTaskWithDescription($taskDescription);
    }

    private function apiCreateTaskWithDescription(string $taskDescription): Response
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription], JSON_THROW_ON_ERROR)
        );

        return $this->client->getResponse();
    }

    private function whenIRequestTheListOfTasks(): Response
    {
        $response = $this->apiGetTasksList();

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());

        return $response;
    }

    private function apiGetTasksList(): Response
    {
        $this->client->request(
            'GET',
            '/api/todo'
        );

        return $this->client->getResponse();
    }

    private function thenICanSeeAddedTasksInTheList(array $expectedTasks, Response $response): void
    {
        $taskList = json_decode($response->getContent(), true);

        self::assertEquals($expectedTasks, $taskList);
    }

    private function givenIHaveAddedTasks($tasks): void
    {
        foreach ($tasks as $task) {
            $this->apiCreateTaskWithDescription($task);
        }
    }

    private function givenIMarkATaskAsCompleted(int $taskId): void
    {
        $patchResponse = $this->apiMarkTaskCompleted($taskId);

        self::assertEquals(Response::HTTP_OK, $patchResponse->getStatusCode());
    }

    private function apiMarkTaskCompleted(int $taskId): Response
    {
        $this->client->request(
            'PATCH',
            '/api/todo/' . $taskId . '',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)

        );

        return $this->client->getResponse();
    }

    protected function setUp(): void
    {
        $this->resetRepositoryData();

        $this->client = self::createClient();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }
}
```

Básicamente hemos reescrito el test usando un estilo *Behavior Driven Development.* No nos ha hecho falta hacer un Gherkin aquí, pero hubiésemos podido hacerlo.

Esto nos ha permitido desprendernos de la llamada directa al motor de almacenamiento que habíamos introducido al principio, y al hacerlo conseguimos que el test sea más portable, ya que sólo usa las llamadas a los *end points*, por lo que puede funcionar en distintos entornos (local e integración contínua, por ejemplo).
