# The refactoring phase

In earlier chapters we mentioned the laws of TDD. Originally these laws were two, in Kent Beck's formulation:

* Don't write a line of new code unless you first have a failing automated test.
* Eliminate duplication.

Essentially, what Kent Beck proposed, was to first define a small part of the specification through a test, implement a very small algorithm that satisfies it, and then, revise the code in search of duplication cases to refactor into a more general and flexible algorithm.

And this is, more or less, the way Martin Fowler defined the Red-Green-Refactor cycle:

* Write a test for the next piece of functionality that you wish to add.
* Write the production code necessary to make the test pass.
* Refactor the code, both the new and the old, so that all's well structured.

This statement seems to assume that the refactoring is, so to speak, the end of each stage of the process. But, paradoxically, if we interpret the cycle literally, we'll fall into a bad practice.

## The function of refactoring in TDD

In general, in *Test Driven Development* it's favored that both tests and changes in production code are as small as possible. This minimalist approach is beneficial because it allows us to work with a light cognitive load in each cycle, while we learn and reach a more extensive and deeper comprehension of the problem, postponing decisions to a moment at which we're knowledgeable enough to face them.

Usually, our small TDD steps let us make very simple code changes every time. Many times these changes are obvious and lead us to implementation that we could consider naive. However, as simple or rough they might seem, these implementations do pass the tests, and therefore meet the specifications. We could ship this code if we needed to, because the behavior has been developed.

And once we make the last test pass and all of them are green, we're in good condition to refactor. This green state gives us freedom to change the shape of the implementation, assuring that we're not accidentally changing the achieved functionality.

The refactoring phase is there, precisely, to evolve those naive implementations and turn them into better designs, making use of the safety net provided by the passing tests.

## Which refactorings to do

In each cycle there are many possible refactorings. Obviously, during the first phases they will be smaller, and we might even think that they're unnecessary. However, it's wise to take the opportunity when it presents itself.

We can perform many types of refactorings, such as:

* Replace magic numbers with constants.
* Change variable and parameter names to better reflect their intentions.
* Extract private methods.
* Extract conditionals to methods when they become complex.
* Flatten nested conditional structures.
* Extract conditional branches to private methods.
* Extract functionality to collaborators.

## Refactoring limits

Sometimes, an *excess* of refactoring can lead us to an implementation that's too complicated and prevents us from advancing the TDD process. This happens when we introduce patterns prematurely without having finished the development first. It would be a *premature refactoring* similar to the *premature optimization*, generating code that's hard to maintain.

We could say that there are two kinds of refactoring involved:

* One kind with limited reach, applicable in each red-green-refactor cycle, whose function is to make the algorithm more legible, sustainable, and capable to evolve.
* The other kind, which will take place once we've completed all of the functionality, and whose objective is to introduce a more evolved and pattern-oriented design.

Another interesting question in the introduction of language-exclusive features, which in principal we'd also like to leave until that final phase. Why leave them for that moment? Precisely, because they can limit our capability to refactor a code if we're not yet sure about towards where it could evolve.

For example, this construction in Ruby:

```ruby
def greet(name = nil)
  if name.nil?
    name = 'my friend'
  end

  "Hello, #{name}"
end
```

It could be refactored -in fact it's recommended to do so- in this way. I think it's really beautiful:

```ruby
def greet(name = nil)
  name = 'my friend' if name.nil?

  "Hello, #{name}"
end
```

In this case, the structure represents the idea of assigning a default value to the variable, something that we could also achieve in this way, which is common in other languages:

```ruby
def greet(name = 'my friend')
  "Hello, #{name}"
end
```

The three variations make the tests pass, but each of them puts us in a slightly different spot regarding future requirements.

Por example, let's assume that our next requirement is to be able to introduce several names. One possible solution would be to use *splat parameters*, that is, let the function admit an undefined number of parameters that will later be presented in the method as an `array`. In Ruby this is expressed like this:

```ruby
def greet(*name)
  #
end
```

This declaration, for example, is incompatible with the third variant, as the *splat operator* doesn't admit a default value and we'd have to re-implement that step, which would lead us back to using one of the other variants.

In principle this doesn't seem like that big of an inconvenience, but it means undoing all of the logic determined by that structure, and depending on the development stage that we're in, it can even lead us to dead ends.

En las otras opciones, es un poco menos inconveniente. Además de cambiar la signatura lo único que tenemos que modificar es la pregunta (`empty?` por `nil?`) y el valor por defecto que, en lugar de un `string`, pasa a ser un `array` de `string`. Por supuesto, para finalizar tenemos que hacer un `join` de la colección para poder mostrarlo en el saludo.

```ruby
def greet(*name)
  if name.empty?
    name = ['my friend']
  end

  names = name.join(', ')

  "Hello, #{names}"
end
```

O la versión *rubyficada*:

```ruby
def greet(*name)
  name = ['my friend'] if name.empty?

  names = name.join(', ')

  "Hello, #{names}"
end
```

Aparte de eso, sería necesario en este punto un refactor del nombre del parámetro que exprese más claramente su nuevo significado:

```ruby
def greet(*people)
  people = ['my friend'] if people.empty?

  names = people.join(', ')

  "Hello, #{names}"
end
```

Así que como recomendación general es conveniente buscar un equilibrio entre los refactors que nos ayudan a mantener el código limpio y legible de aquellos que podríamos considerar como sobreingeniería. Una implementación un poco menos refinada puede ser más fácil de cambiar a medida que se introducen nuevos tests que una muy evolucionada.

No *sobre refactorices* antes de tiempo.

## Cuando es el momento de hacer refactor

Para hacer refactor la condición *sine qua non* es que todos los tests existentes estén pasando. En este momento nos interesa analizar el estado de la implementación y aplicar los refactors que mejor le vayan.

Si un test está en rojo nos indica que una parte de la especificación no está conseguida y, por lo tanto, debemos trabajar en eso y no en el refactor.

Pero hay un caso especial: cuando añadimos un nuevo test que falla y nos damos cuenta de que necesitamos un refactor previo para poder implementar la solución más obvia o sencilla para ese test.

¿Cómo actuamos en este caso? Pues tenemos que dar un paso atrás.

### El paso atrás en el ciclo Red-Green-Refactor

Supongamos un ejemplo sencillo. Vamos a iniciar la [Greeting kata de testdouble](https://github.com/testdouble/contributing-tests/wiki/Greeting-Kata). Empezamos con un test con el que definir la interfaz:

```ruby
require 'rspec'

RSpec.describe 'A simple greeting' do
  it 'should greet a person' do
    expect(greet('Fran')).to eq('Hello, Fran')
  end
end
```

Nuestro siguiente paso es crear la implementación más sencilla para que el test pase, cosa que podríamos hacer así:

```ruby
def greet(name)
  'Hello, Fran'
end
```

El siguiente requerimiento es que maneje el caso de que no se proporcione nombre, en cuyo caso debe ofrecer alguna fórmula anónima como la que ponemos de ejemplo en este test:

```ruby
require 'rspec'

def greet(name)
  'Hello, Fran'
end

RSpec.describe 'A simple greeting' do
  it 'should greet a person' do
    expect(greet('Fran')).to eq('Hello, Fran')
  end

  it 'should greet even if no name provided' do
    expect(greet).to eq('Hello, my friend')
  end
end
```

El test falla en primer lugar porque el argumento no es opcional. Pero es que además no se usa en la implementación actual y necesitamos usarlo para hacer lo más obvio que requiere este test. Tenemos que ejecutar varios pasos preparatorios antes de poder realizar la implementación, a saber:

* Hacer opcional el parámetro `name`
* Usar el parámetro en el valor de retorno

El caso es que con el nuevo requerimiento tenemos nueva información que nos sería útil para refactorizar lo desarrollado gracias al primer test. Sin embargo, como tenemos un nuevo test que falla, no deberíamos hacer refactor, por lo que eliminamos o anulamos el test anterior. Por ejemplo, comentándolo:

```ruby
require 'rspec'

def greet(name)
  'Hello, Fran'
end

RSpec.describe 'A simple greeting' do
  it 'should greet a person' do
    expect(greet('Fran')).to eq('Hello, Fran')
  end
  
  # it 'should greet even if no name provided' do
  #   expect(greet).to eq('Hello, my friend')
  # end
end
```

Al hacer así, volvemos a tener los tests en verde y podemos aplicar los cambios necesarios, que no alteran el comportamiento implementado hasta el momento. 

Hacemos opcional el parámetro del nombre.

```ruby
def greet(name = nil)
  'Hello, Fran'
end
```

Aquí empezamos a dar uso al parámetro:

```ruby
def greet(name)
  "Hello, #{name}"
end
```

Esto nos ha permitido pasar de nuestra primera implementación tosca a una lo bastante flexible con la que el test sigue pasando y estamos en mejores condiciones para volver a introducir el siguiente test:

```ruby
require 'rspec'

def greet(name = nil)
  "Hello, #{name}"
end

RSpec.describe 'A simple greeting' do
  it 'should greet a person' do
    expect(greet('Fran')).to eq('Hello, Fran')
  end

  it 'should greet even if no name provided' do
    expect(greet).to eq('Hello, my friend')
  end
end
```

Obviamente, el test falla, pero la razón del fallo es justamente que nos falta código que resuelva el requerimiento. Lo único que tenemos que hacer es comprobar si recibimos un nombre o no, y actuar en consecuencia.

```ruby
def greet(name = nil)
  if name.nil?
    name = 'my friend'
  end
  
  "Hello, #{name}"
end
```

En cierto modo, resulta que la *información del futuro*, o sea, el nuevo test que planteamos para introducir la siguiente funcionalidad, *afecta al pasado*, es decir al estado adecuado del código para poder continuar, y nos obliga a considerar la profundidad del refactor necesario antes de afrontar el nuevo ciclo. En esta situación, lo mejor es volver al último test que pasaba, anulando el nuevo, y trabajar en el refactor hasta estar mejor preparadas para continuar avanzando.

