# Solving the NIF kata

In this kata we're going to follow an approach that tackles the *sad paths* first, that is, we're going to handle the cases that would cause an error first. Thus, we'll first develop the validation of the input structure, and then move on to the algorithm.

It's usual that the kata ignore issues such as validation, but in this case we've decided to go for a more realistic example, in the sense that it's a situation with which we have to deal quite often. In the code of a project in production, the validation of input data is essential, and it's worth practicing with an exercise that focuses almost exclusively on it.

Besides, we'll see a couple of interesting techniques to transform a public interface without breaking the tests.

## Problem statement of the kata

Create a Nif class, which will be a Value Object to represent the Spanish Tax Identification Number. It's a string of eight numeric characters, with a final letter that acts as a control character.

This control letter is obtained by calculating the remainder of diving the numeric part of the NIF by 23 (mod 23). The result indicates us in which row of the following table to look up the control letter. In this table I've also included some simple examples of valid NIF so you can use them in the tests.

| Numeric part | Remainder | Letter | Valid NIF example |
|----|------|-------|----|
| 00000023 | 0 | T | 00000023T |
| 00000024 | 1 | R | 00000024R |
| 00000025 | 2 | W | 00000025W |
| 00000026 | 3 | A | 00000026A |
| 00000027 | 4 | G | 00000027G |
| 00000028 | 5 | M | 00000028M |
| 00000029 | 6 | Y | 00000029Y |
| 00000030 | 7 | F | 00000030F |
| 00000031 | 8 | P | 00000031P |
| 00000032 | 9 | D | 00000032D |
| 00000033 | 10 | X | 00000033X |
| 00000034 | 11 | B | 00000034B |
| 00000035 | 12 | N | 00000035N |
| 00000036 | 13 | J | 00000036J |
| 00000037 | 14 | Z | 00000037Z |
| 00000038 | 15 | S | 00000038S |
| 00000039 | 16 | Q | 00000039Q |
| 00000040 | 17 | V | 00000040V |
| 00000041 | 18 | H | 00000041H |
| 00000042 | 19 | L | 00000042L |
| 00000043 | 20 | C | 00000043C |
| 00000044 | 21 | K | 00000044K |
| 00000045 | 22 | E | 00000045E |

You can create invalid NIF simply by choosing a numeric part and adding a letter that doesn't correspond it.

| Invalid example |
|----|
| 00000000S |
| 00000001M |
| 00000002H |
| 00000003Q |
| 00000004E |

There's an exception: the NIF for foreigners (or NIE) may start by the letters `X`, `Y`or `Z`, which for the purposes of the calculations are replaced by the numbers `0`, `1` and `2`, respectively. In this case, `X0000000T` is equivalent to `00000000T`.

To prevent confusion we've excluded the letters `U`, `I`, `O` and `Ñ`.

A string that starts with a letter other than `X`, `Y`, `Z`, or that contains alphabetic characters in the central positions is also invalid.

## Language and focus

We're going to solve this kata using Go, so we're going to clarify its result a bit. In this example we're going to create a data type `Nif`, which will basically be a `string`, and a factory function `NewNif` which will allow us to build validated NIF starting from an input `string`.

On the other hand, testing in Go is also a bit peculiar. Even though the language includes support for testing as a standard feature, it doesn't include common utilities such as `asserts`.

### Disclaimer

To solve this kata I'm going to take advantage of the way in which Go handles errors. These can be returned as one of the responses of a function, which forces you to always handle them explicitly.

Designing tests based on error messages is not a good practice, as they can easily change, making tests fail even when there hasn't really been an alteration of the functionality. However, in this kata we're going to use the error messages as a sort of temporary wildcard on which to rely, making them go from more specific to more general. By the end of the exercise, we'll be handling only two possible errors.

## Create the constructor function

In this kata, we want to start by focusing on the *sad paths*, the cases in which we won't be able to use the argument that's been passed to the constructor function. From all the innumerable string combinations that the function could receive, let's first give an answer to those that we know won't be of use because they don't meet the requirements. This answer will be an error.

We'll start by rejecting the strings that are too long, those that have more than nine characters. We can describe this with the following test:

In the **nif/nif_test.go** file

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	NewNif()
}
```

For now we'll ignore the function's responses, just to force ourselves to implement the minimum amount of code.

As expected, the test will fail because it doesn't compile. So we'll implement the minimum necessary code, which can be as small as this:

**nif/nif.go** file

```go
package nif

func NewNif() {

}
```

With this, we get a foundation on which to build.

Now we can go a step further. The function should accept a parameter:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	NewNif("01234567891011")
}
```

We make the test pass again with:

```go
package nif

func NewNif(candidate string) {

}
```

And finally return:

* the NIF, when the one we've passed is valid.
* an error in the case it's not possible.

In **Go**, a function can return multiple values and, by convention, errors are also returned as the last return value.

This provides a flexibility that is not common to find in other languages, and let us play with some ideas that are at least curious. For example, for now we're going to ignore the response on the function and focus exclusively on the errors. Our next test is going to ask the function to return only the error without doing anything with it. The `if` is there, for now, to keep the compiler from complaining.

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err != nil {}
}
```

This test tells us that we must return something, so for now we indicate that we're going to return an error, which can be `nil`.

```go
package nif

func NewNif(candidate string) error {
	return nil
}
```

Let's go a step further by expecting a specific error when the condition defined by the test is met: the string is too long. With this, we'll have a proper first test:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err.Error() != "too long" {
		t.Errorf("Expected too long, got %s", err.Error())
	}
}
```

Again, the test will fail, and to make it pass we return the error unconditionally:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	return errors.New("too long")
}
```

And with this, we've already completed our first test and made it pass. We could be a little more strict in the handling of the response to contemplate the case in which `err` is `nil`, but it's something that doesn't have to affect us for the time being.

At this point, I'd like to draw your attention to the fact that we're not solving anything yet: the error is returned unconditionally, so we're postponing this validation for later.

## Implement the first validation

Our second test has the goal of forcing the implementation of the validation we've just postponed. It may sound a little weird, but it showcases that one the great benefits of TDD is the ability to postpone decisions. By doing so we'll have a little more information, which is always an advantage.

This test is very similar to the previous one:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err.Error() != "too long" {
		t.Errorf("Expected too long, got %s", err.Error())
	}
}

func TestShouldFailWhenStringIsTooShort(t *testing.T) {
	err := NewNif("0123456")

	if err.Error() != "too short" {
		t.Errorf("Expected too short, got %s", err.Error())
	}
}
```

This test already forces us to act differently in each case, so we're going to implement the validation that limits the strings that are too long:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("too long")
	}

	return errors.New("too short")
}
```

Again, I point out that at the moment we're not implementing what the test says. We'll do it in the next cycle, but the test is fulfilled by returning the expected error unconditionally.

There's not much else we can do in the production code, but looking at the tests we can see that it would be possible to unify their structure a bit. After all, we're going to make a series of them to which we pass a value and expect a specific error in response.

## A test to rule them all

In **Go** there is a test structure similar to the one provided by the use of *Data Providers* in other languages: `Table Test`.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
``` 


With this, it's now very easy and fast to add tests, especially if they are from the same family, like in this case in which we pass invalid candidate strings and check for the error. Also, if we make changes to the constructor's interface, we only have a place in which to apply them.

With this, we'd have everything ready to continue developing.

## Complete the validation of the length and start examining the structure

With the two previous tests we verify that the string that we're examining meets the specification of having exactly nine characters, although that's not implemented yet. We'll do it now.

However, you may be asking yourself why don't we simply test that the function rejects the `strings` that don't fulfill it, something that we could do in just one test.

The reason is that there are actually two possible ways in which the specification may not be met: the `string` has more than nine characters, or the `string` has less. If we do a single test, we'll have to choose one of the two cases, so we cannot guarantee that the other is fulfilled.

In this specific example, in which we're interested in just one value, we could raise the dichotomy between `strings` with length nine and `strings` with lengths other than nine. However, it's common for us to have to work with interval of values that, moreover, can be open or closed. In that situation, the strategy of having two or even more tests is far safer.

In any case, in the point at which we are, we need to add another requirement in the form of a test in order to drive the development. The two existing tests define the `string`'s valid length. The next test asks about its structure.

And with the refactoring that we've just made, adding a test is extremely simple.

We'll start at the beginning. Valid NIF begin with a number, except a for a subset of the that begin with one of the letters `X`, `Y`, and `Z`. One way of defining the test is the following:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

To make the test pass, we first solve the pending problem of the previous one: 

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("too long")
	}

	if len(candidate) < 9 {
		return errors.New("too short")
	}

	return errors.New("bad start format")
}
```

Here we have a pretty clear refactoring opportunity that would consist in joining the conditionals that evaluate the lengths of the `string`. However, that will cause the test to fail since we would at least have to change an error message.

## The not very clean way of changing the test and production code a the same time 

One possibility is to temporarily "skip" our self-imposed condition of only doing refactorings with all tests in green, and making changes in both production and test code at the same time. Let's see what happens.

The first thing would be to change the test so it expects a different error message, which will be more generic and the same for all of the cases that we want to consolidate in this step:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

This will cause the test to fail. An issue that can be solved by changing the production code in the same way:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("bad format")
	}

	if len(candidate) < 9 {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

The test passes again and we are ready to refactor. But we're not going to do that.

### The safe way

Other option is to make a temporary refactoring in the test in order to make it more tolerant. We just make it possible to return a more generic error apart from the specific one.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

This change allows us to make the change in production without breaking anything:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("bad format")
	}

	if len(candidate) < 9 {
		return errors.New("bad format")
	}

	return errors.New("bad end format")
}
```

The test keeps passing, and now we can perform the refactoring.

## Unify the `string` length validation


Unifying the conditionals is easy now. This is the first step, which I include here to have a reference of how to do this in case we were working with an interval of valid lengths.

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 || len(candidate) < 9 {
		return errors.New("bad format")
	}
	
	return errors.New("bad start format")
}
```

But it can be done better:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) != 9 {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

And a little more expressive:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	const maxlength = 9
	
	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

Finally, a new refactoring of the test to contemplate these changes. We remove our temporary change, although it's possible that we need it again in the future.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

```

Note that we've been able to make all these changes without the tests failing.

## Moving forward with the structure

The code is pretty compact, so we're going to add a new test that lets us move forward with the validity of the structure. The central fragment of the NIF is composed only of numbers, exactly seven:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

We run it to make sure that it fails for the right reason. To pass the test, we have to solve the previous test first, so we'll add code to verify that the first symbol is either a number or a letter in the `X`, `Y` and `Z` set. We'll do it with a regular expression:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	invalid := regexp.MustCompile(`(?i)^[^0-9XYZ].*`)

	if invalid.MatchString(candidate) {
		return errors.New("bad start format")
	}
	
	return errors.New("bad middle format")
}
```

This code is enough to make the test pass, but we're going to make a refactoring.

## Invert the conditional

It makes sense that, instead of *matching* a regular expression that excludes the non-valid strings, we *match* an expression that detects them. If we do that, we'll have to invert the conditional. To be honest, the change is pretty small:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad start format")
	}
	
	return errors.New("bad middle format")
}
```

## The end of the structure

We're reaching the end of the structural validation of the NIF, we need a test that tells us which candidates to reject depending on its last symbol, which leads us to solving the pending problem from the previous test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

From the four non-valid letters we take the `U` as an example, but it could be `I`, `Ñ`, or `O`.

However, to make the test pass, what we do is make sure that the previous one is fulfilled. It's easier to implement that separately:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad start format")
	}

	valid = regexp.MustCompile(`(?i)^.\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad middle format")
	}

	return errors.New("invalid end format")
}
```

## Compacting the algorithm

This passes the test, and we are met by a familiar situation which we've already solved before: we have to make the errors more generic with the temporary help of some extra control in the test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

We change the error messages in the production code:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i)^.\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Now we unify the regular expression and the conditionals:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}
	
	return errors.New("invalid end format")
}
```

We can still make a small but important change. The last part of the regular expression, `.*`, is there to fulfill the requirement of matching the whole string. However, we don't really need the quantifier as one character is enough:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

And this reveals a detail, the regular expression only *matches* strings that have exactly nine characters, so the initial length validation is unnecessary:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

We've walked so far... only to retrace our steps. However, we didn't know this in the beginning, and that's where the value of the process lies.

Lastly, we change the test to reflect the changes and, again, remove our temporary support:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

## Finishing the structural validation

We need a new test to finish the structural validation part. The existing tests guarantee that the `strings` are correct, but the following validation already involves the algorithm that calculates the control letter.

This test should ensure that we can't use a structurally valid NIF with an incorrect control letter.  

El test que necesitamos ahora controla que no podemos usar un NIF estructuralmente válido, pero en el que la letra de control sea incorrecta. Al enunciar la kata pusimos algunos ejemplos, como `00000000S`. Este es el test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Y he aquí el código que lo hace pasar:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i).*[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("invalid end format")
	}
	
	return errors.New("bad control letter")
}
```

Y, cómo no, toca refactorizar.

## Compactando la validación

Este refactor es bastante obvio, pero tenemos que volver a proteger el test temporalmente:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Hacemos más general el error para poder unificar las expresiones regulares y las condicionales:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i).*[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Y hacemos ahora la unificación, mientras los tests siguen pasando:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Con esto terminamos la validación de la estructura y nos quedaría implementar el algoritmo **mod23**. Pero para eso necesitamos un pequeño cambio de enfoque.

## Seamos optimistas

El algoritmo es, de hecho, muy sencillo: obtener un resto (de dividir por 23) y buscar la posición indicada por el resultado en una tabla. Es fácil de implementar en una sola iteración. Sin embargo, vamos a hacerlo más lentamente.

Hasta ahora nuestros tests eran pesimistas porque esperaban ejemplos incorrectos de NIF para poder pasar. Nuestros tests ahora tienen que ser optimistas, es decir, van a esperar que le pasemos ejemplos de NIF válidos.

En este punto introduciremos un cambio. Si recuerdas, de momento sólo estamos devolviendo el error y la interfaz final de la función devolverá el `string` validado como un tipo NIF que vamos a crear para la ocasión.

Es decir, tenemos que cambiar el código para que devuelva algo, y que ese algo sea de un tipo que todavía no existe.

Para hacer este cambio sin romper los tests vamos a hacer una técnica de refactor un tanto rebuscada.

## Cambiando la interfaz pública

En primer lugar, extraemos el cuerpo de `NewNif` a otra función:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	return FullNewNif(candidate)
}

func FullNewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Los tests siguen pasando. Ahora introducimos una variable:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	err := FullNewNif(candidate)
	return err
}

func FullNewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Con esto podemos hacer que `FullNewNif` devuelva el `string` sin afectar al test porque queda encapsulado dentro de `NewNif`.

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	_, err := FullNewNif(candidate)
	return err
}

func FullNewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

Los tests siguen pasando y casi hemos acabado. En el test cambiamos el uso de `NewNif` por `FullNewNif`.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := FullNewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Siguen pasando los tests. Ahora la función devuelve los dos parámetros que queríamos y no hemos roto los tests. Podemos eliminar la función `NewNif` original.

```go
package nif

import (
	"errors"
	"regexp"
)

func FullNewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

Y usar las herramientas del IDE para cambiar el nombre de la función `FullNewNif` a `NewNif`.

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

## Ahora sí

Nuestro objetivo ahora es empujar la implementación el algoritmo **mod23**. Esta vez los tests esperan que la cadena sea válida. Además, queremos forzar que se devuelva el tipo `Nif` en lugar de `string`.

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000023T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)
			
			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}
			
			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

En un primer paso cambiamos el código de producción para introducir y usar el tipo `Nif`:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return "", errors.New("bad control letter")
}
```

Ahora el test estará fallando porque no hemos validado nada todavía. Para hacerlo pasar añadimos un condicional:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate == "00000023T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Una nota sobre **Go** es que los tipos *custom* no pueden tener valor `nil`, sino vacío. Por eso en caso de error devolvemos `string` vacío.

## Avanzando el algoritmo

De momento no hay muchos motivos para hacer refactor, así que vamos a introducir un test que nos ayude a avanzar un poco. En principio, queremos lograr que nos impulse a separar la parte numérica de la letra de control.

Una posibilidad sería testear otro NIF que acabe con la letra `T`, como el `00000046T`.

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000023T"},
		{"should accept mod23 being 0 letter T", "00000046T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Para hacer pasar el test, podemos hacer esta implementación sencilla:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate == "00000023T" {
		return Nif(candidate), nil
	}

	if candidate == "00000046T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Y ahora empezamos a refactorizar.

## Más refactor

En el código de producción podemos ver lo que hay de diferente y de común entre los ejemplos. En ambos la letra de control es `T` y la parte numérica es divisible entre 23, por lo que su **mod23** será 0.

Ahora podemos hacer el refactor. Un primer paso.

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	if control == "T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Y, después de ver pasar los tests, el segundo paso:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23
	
	if control == "T" && modulus == 0 {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Con este cambio los tests pasan y acepta todos los NIF válidos acabados en `T`.

## Validando más letras de control

En este tipo de algoritmos no tiene mucho sentido intentar validar todas las letras de control, pero podemos introducir una más para forzarnos a entender cómo debería evolucionar el código ahora. Probaremos con una nueva letra:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Ya tenemos este test fallando, así que vamos a hacer una implementación muy sencilla:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == "T" && modulus == 0 {
		return Nif(candidate), nil
	}

	if control == "R" && modulus == 1 {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Esto ya nos da una idea de por dónde van los tiros: un mapa entre letras de control y el resto al dividir por 23. Sin embargo, es frecuente que los `strings` puedan funcionar como `arrays` en muchos lenguajes, por lo que nos basta tener un `string` con todas las letras de control ordenadas y acceder a la letra en la posición indicada por el módulo para saber cual es la correcta.

## Un refactor para más simplicidad

Primero implementamos una versión simple de esta idea:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	controlMap := "TR"

	control := candidate[8]

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == controlMap[modulus] {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Ya tenemos una primera versión. Luego añadiremos la lista completa de letras, pero podemos intentar arreglar un poco el código actual. Primero hacemos que `controlMap` sea constante:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	const controlMap = "TR"

	control := candidate[8]

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == controlMap[modulus] {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

En realidad podríamos extraer toda la parte del cálculo del módulo a otra función. Primero reorganizamos el código para controlar mejor la extracción:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := candidate[8]
	
	const controlMap = "TR"
	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23
	shouldBe := controlMap[modulus]
	
	if control == shouldBe {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Recuerda verificar que pasan los tests. Ahora extraemos la función:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := candidate[8]

	if control == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TR"
	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23
	
	return controlMap[modulus]
}
```

Y podemos compactar el código un poco más, mientras que añadimos las demás letras de control. A primera vista parece "trampa", pero en el fondo no es más que generalizar un algoritmo que se podría enunciar como "toma la letra que hay en la posición dada por el **mod23** de la parte numérica".

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23

	return controlMap[modulus]
}
```

Con esto ya podemos validar todos los NIF, excepto los NIE, que empiezan por las letras `X`, `Y` ó `Z`.

## Dar soporte a NIE

Ahora que hemos implementado el algoritmo general vamos a tratar sus excepciones, que no son tanto. Los NIE comienzan con una letra que a efectos del cálculo se reemplaza con un número.

El test que parece más evidente en este punto es el siguiente:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000023T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

El caso `X0000023T` es equivalente a `00000023T`, ¿afectará eso al resultado del test?

Ejecutamos el test y… ¿sorpresa? El test pasa. Esto ocurre porque la conversión que hacemos en esta línea genera un error que actualmente estamos ignorando, pero permite que la parte numérica siga siendo equivalente a 23, cuyo **mod23** es 0 y le corresponde igualmente la letra `T`.

```go
	numeric, _ := strconv.Atoi(candidate[0:8])
```

En otro lenguajes la conversión no falla, pero asume la X como 0 al realizar la conversión.

En cualquier caso eso nos abre dos posible caminos:

* anular este test y refactorizar el código de producción para tratar el error y que el test falle cuando lo volvamos a incluir
* probar otro ejemplo que sí pueda fallar (`Y0000000Z`) y hacer el cambio después 

Posiblemente para este caso la segunda opción sería más que suficiente ya que con nuestras validaciones estructurales ya garantizaríamos que el error no tiene posibilidad de aparecer una vez que la función esté completamente desarrollada.

Sin embargo, podría ser interesante introducir la gestión del error. Manejar los errores, incluyendo los que *nunca podrían llegar a pasar*, es siempre una buena práctica.

Así que, anulemos el test e introduzcamos un refactor para manejar el error:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		//{"should accept NIE starting with X", "X0000023X"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Aquí el refactor. En este caso, gestiono el error provocando un `panic`, que no es la mejor manera de gestionar un error, pero que nos permite hacer que el test pueda fallar y obligarnos a implementar la solución.

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	numeric, err := strconv.Atoi(candidate[0:8])

	if err != nil {
		panic("Numeric part contains letters")
	}
	
	modulus := numeric % 23

	return controlMap[modulus]
}
```

Al ejecutar los tests, comprobamos que siguen en verde. Pero si reactivamos el último test vemos cómo falla:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000023X"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Y esto ya nos obliga a introducir un tratamiento para estos casos. Básicamente es reemplazar la `X` por `0`:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	if string(candidate[0]) == "X" {
		numPart = strings.Replace(numPart, "X", "0", 1)
	}

	numeric, err := strconv.Atoi(numPart)

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

Se puede refactorizar usando un `Replacer`:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	re := strings.NewReplacer("X", "0")
	
	numeric, err := strconv.Atoi(re.Replace(numPart))

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

En este punto podríamos hacer un test para forzarnos a introducir el resto de reemplazos. Es barato, aunque en el fondo no es muy necesario por lo que comentamos antes, podemos interpretar esta parte del algoritmo como "reemplazar las letras iniciales X, Y y Z por los números 0, 1 y 2, respectivamente":

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000000T"},
		{"should accept NIE starting with Y", "Y0000000Z"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Sólo es necesario añadir los pares correspondientes:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	re := strings.NewReplacer("X", "0", 
	                          "Y", "1", 
	                          "Z", "2")

	numeric, err := strconv.Atoi(re.Replace(numPart))

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

Después de un rato de refactor, esta sería una posible solución:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] != controlLetterFor(candidate) {
		return "", errors.New("bad control letter")
	}

	return Nif(candidate), nil
}

func controlLetterFor(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	position, err := controlPosition(candidate[0:8])

	if err != nil {
		panic("Numeric part contains letters")
	}

	return controlMap[position]
}

func controlPosition(numPart string) (int, error) {
	re := strings.NewReplacer("X", "0", "Y", "1", "Z", "2")

	numeric, err := strconv.Atoi(re.Replace(numPart))

	return numeric % 23, err
}
```

## Qué hemos aprendido con esta kata

* Utilizar sad paths para mover el desarrollo
* Utilizar table tests en Go para reduciendo el coste de añadir nuevos tests
* Una técnica para cambiar los errores devueltos por otro más general sin romper los tests
* Una técnica para cambiar la interfaz pública del código de producción sin romper los tests

## Referencias

* [Is Go object oriented?](https://flaviocopes.com/golang-is-go-object-oriented/)[^fn37]


[^fn37]: https://flaviocopes.com/golang-is-go-object-oriented/
