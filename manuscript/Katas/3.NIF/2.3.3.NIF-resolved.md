# Solving the NIF kata

In this kata we're going to follow an approach that tackles the *sad paths* first, that is, we're going to handle the cases that would cause an error first. Thus, we'll first develop the validation of the input structure, and then move on to the algorithm.

It's usual that the kata ignore issues such as validation, but in this case we've decided to go for a more realistic example, in the sense that it's a situation with which we have to deal quite often. In the code of a project in production, the validation of input data is essential, and it's worth practicing with an exercise that focuses almost exclusively on it.

Besides, we'll see a couple of interesting techniques to transform a public interface without breaking the tests.

## Problem statement of the kata

Create a Nif class, which will be a Value Object to represent the Spanish Tax Identification Number. It's a string of eight numeric characters, with a final letter that acts as a control character.

This control letter is obtained by calculating the remainder of diving the numeric part of the NIF by 23 (mod 23). The result indicates us in which row of the following table to look up the control letter. In this table I've also included some simple examples of valid NIF so you can use them in the tests.

| Numeric part | Remainder | Letter | Valid NIF example |
|----|------|-------|----|
| 00000023 | 0 | T | 00000023T |
| 00000024 | 1 | R | 00000024R |
| 00000025 | 2 | W | 00000025W |
| 00000026 | 3 | A | 00000026A |
| 00000027 | 4 | G | 00000027G |
| 00000028 | 5 | M | 00000028M |
| 00000029 | 6 | Y | 00000029Y |
| 00000030 | 7 | F | 00000030F |
| 00000031 | 8 | P | 00000031P |
| 00000032 | 9 | D | 00000032D |
| 00000033 | 10 | X | 00000033X |
| 00000034 | 11 | B | 00000034B |
| 00000035 | 12 | N | 00000035N |
| 00000036 | 13 | J | 00000036J |
| 00000037 | 14 | Z | 00000037Z |
| 00000038 | 15 | S | 00000038S |
| 00000039 | 16 | Q | 00000039Q |
| 00000040 | 17 | V | 00000040V |
| 00000041 | 18 | H | 00000041H |
| 00000042 | 19 | L | 00000042L |
| 00000043 | 20 | C | 00000043C |
| 00000044 | 21 | K | 00000044K |
| 00000045 | 22 | E | 00000045E |

You can create invalid NIF simply by choosing a numeric part and adding a letter that doesn't correspond it.

| Invalid example |
|----|
| 00000000S |
| 00000001M |
| 00000002H |
| 00000003Q |
| 00000004E |

There's an exception: the NIF for foreigners (or NIE) may start by the letters `X`, `Y`or `Z`, which for the purposes of the calculations are replaced by the numbers `0`, `1` and `2`, respectively. In this case, `X0000000T` is equivalent to `00000000T`.

To prevent confusion we've excluded the letters `U`, `I`, `O` and `Ñ`.

A string that starts with a letter other than `X`, `Y`, `Z`, or that contains alphabetic characters in the central positions is also invalid.

## Language and focus

We're going to solve this kata using Go, so we're going to clarify its result a bit. In this example we're going to create a data type `Nif`, which will basically be a `string`, and a factory function `NewNif` which will allow us to build validated NIF starting from an input `string`.

On the other hand, testing in Go is also a bit peculiar. Even though the language includes support for testing as a standard feature, it doesn't include common utilities such as `asserts`.

### Disclaimer

To solve this kata I'm going to take advantage of the way in which Go handles errors. These can be returned as one of the responses of a function, which forces you to always handle them explicitly.

Designing tests based on error messages is not a good practice, as they can easily change, making tests fail even when there hasn't really been an alteration of the functionality. However, in this kata we're going to use the error messages as a sort of temporary wildcard on which to rely, making them go from more specific to more general. By the end of the exercise, we'll be handling only two possible errors.

## Create the constructor function

In this kata, we want to start by focusing on the *sad paths*, the cases in which we won't be able to use the argument that's been passed to the constructor function. From all the innumerable string combinations that the function could receive, let's first give an answer to those that we know won't be of use because they don't meet the requirements. This answer will be an error.

We'll start by rejecting the strings that are too long, those that have more than nine characters. We can describe this with the following test:

In the **nif/nif_test.go** file

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	NewNif()
}
```

For now we'll ignore the function's responses, just to force ourselves to implement the minimum amount of code.

As expected, the test will fail because it doesn't compile. So we'll implement the minimum necessary code, which can be as small as this:

**nif/nif.go** file

```go
package nif

func NewNif() {

}
```

With this, we get a foundation on which to build.

Now we can go a step further. The function should accept a parameter:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	NewNif("01234567891011")
}
```

We make the test pass again with:

```go
package nif

func NewNif(candidate string) {

}
```

And finally return:

* the NIF, when the one we've passed is valid.
* an error in the case it's not possible.

In **Go**, a function can return multiple values and, by convention, errors are also returned as the last return value.

This provides a flexibility that is not common to find in other languages, and let us play with some ideas that are at least curious. For example, for now we're going to ignore the response on the function and focus exclusively on the errors. Our next test is going to ask the function to return only the error without doing anything with it. The `if` is there, for now, to keep the compiler from complaining.

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err != nil {}
}
```

This test tells us that we must return something, so for now we indicate that we're going to return an error, which can be `nil`.

```go
package nif

func NewNif(candidate string) error {
	return nil
}
```

Let's go a step further by expecting a specific error when the condition defined by the test is met: the string is too long. With this, we'll have a proper first test:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err.Error() != "too long" {
		t.Errorf("Expected too long, got %s", err.Error())
	}
}
```

Again, the test will fail, and to make it pass we return the error unconditionally:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	return errors.New("too long")
}
```

And with this, we've already completed our first test and made it pass. We could be a little more strict in the handling of the response to contemplate the case in which `err` is `nil`, but it's something that doesn't have to affect us for the time being.

At this point, I'd like to draw your attention to the fact that we're not solving anything yet: the error is returned unconditionally, so we're postponing this validation for later.

## Implement the first validation

Our second test has the goal of forcing the implementation of the validation we've just postponed. It may sound a little weird, but it showcases that one the great benefits of TDD is the ability to postpone decisions. By doing so we'll have a little more information, which is always an advantage.

This test is very similar to the previous one:

```go
package nif

import "testing"

func TestShouldFailWhenStringIsTooLong(t *testing.T) {
	err := NewNif("01234567891011")

	if err.Error() != "too long" {
		t.Errorf("Expected too long, got %s", err.Error())
	}
}

func TestShouldFailWhenStringIsTooShort(t *testing.T) {
	err := NewNif("0123456")

	if err.Error() != "too short" {
		t.Errorf("Expected too short, got %s", err.Error())
	}
}
```

This test already forces us to act differently in each case, so we're going to implement the validation that limits the strings that are too long:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("too long")
	}

	return errors.New("too short")
}
```

Again, I point out that at the moment we're not implementing what the test says. We'll do it in the next cycle, but the test is fulfilled by returning the expected error unconditionally.

There's not much else we can do in the production code, but looking at the tests we can see that it would be possible to unify their structure a bit. After all, we're going to make a series of them to which we pass a value and expect a specific error in response.

## A test to rule them all

In **Go** there is a test structure similar to the one provided by the use of *Data Providers* in other languages: `Table Test`.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
``` 


With this, it's now very easy and fast to add tests, especially if they are from the same family, like in this case in which we pass invalid candidate strings and check for the error. Also, if we make changes to the constructor's interface, we only have a place in which to apply them.

With this, we'd have everything ready to continue developing.

## Completar la validación de la longitud y empezar a examinar la estructura

Con los dos tests anteriores verificamos si la cadena que vamos a examinar cumple la especificación de tener exactamente nueve caracteres, aunque de momento eso no está implementado. Lo haremos ahora.

Sin embargo, puede que te preguntes por qué no testear simplemente que la función rechaza los `strings` que no la cumplan, algo que podríamos hacer en un único test.

La razón es que en realidad hay dos posibles formas de que no se cumpla la especificación: el `string` tiene más de nueve caracteres o el `string` tiene menos. Si hacemos un sólo test elegiremos uno de los dos casos, con lo cual no estamos garantizando que se cumpla el otro.

En este ejemplo concreto en que hay un único valor que nos interesa podríamos plantear la disyuntiva entre `strings` con longitud nueve y `strings` con longitud distinta de nueve. Sin embargo, es frecuente que tengamos que trabajar con intervalos de valores que, además, pueden estar abiertos o cerrados. En esa situación la estrategia de dos, o incluso más tests, es muchísimo más segura.

En cualquier caso, en el punto en el que estamos, para mover el desarrollo necesitamos añadir otro requisito en forma de test. Los dos tests existentes nos definen la longitud válida del `string`. El siguiente test pregunta por su estructura.

Y con el refactor que acabamos de hacer añadir un test es tremendamente sencillo.

Empezaremos por el principio. Los NIF válidos comienzan con un número, excepto un subconjunto de ellos que lo hace por alguna de las letras `X`, `Y` y `Z`. Una forma de definir el test es de la siguiente forma:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Para hacer pasar el test, resolvemos primero el problema pendiente del anterior:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("too long")
	}

	if len(candidate) < 9 {
		return errors.New("too short")
	}

	return errors.New("bad start format")
}
```

Aquí tenemos una oportunidad de refactor bastante clara que consistiría en unir las condicionales que evalúan la longitud del `string`. Sin embargo, esa va a hacer que el test falle ya que al menos tendríamos que cambiar un mensaje de error.

### La vía no muy limpia de cambiar a la vez test y código de producción

Una posibilidad es "saltarnos" temporalmente la condición de que el refactor sea con los tests en verde y hacer cambios a la vez en prod y test. Veamos qué pasa.

Lo primero sería cambiar el test para esperar un mensaje de error distinto, que será más genérico e igual para todos los casos que queremos consolidar en este paso:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Esto hará fallar el test. Cosa que se puede arreglar cambiando el código de producción del mismo modo:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("bad format")
	}

	if len(candidate) < 9 {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

El test vuelve a pasar y estamos listas para el refactor. Pero no vamos a hacer eso.

### La vía segura

Otra opción es hacer un refactor temporal en el test para hacerlo más tolerante. Simplemente hacemos que sea posible devolver un error más genérico aparte del error específico.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "too long"},
		{"should fail if too short", "01234", "too short"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Este cambio nos permite ahora hacer el cambio en producción sin romper nada:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 {
		return errors.New("bad format")
	}

	if len(candidate) < 9 {
		return errors.New("bad format")
	}

	return errors.New("bad end format")
}
```

El test sigue pasando y ahora sí podemos hacer el refactor.

## Unificar la validación por longitud del `string`


Unificar las condicionales es fácil en este momento. Este es el primer paso, que incluyo aquí para tener un modelo de cómo hacer esto en caso de que fuese un intervalo de longitudes válidas.

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) > 9 || len(candidate) < 9 {
		return errors.New("bad format")
	}
	
	return errors.New("bad start format")
}
```

Pero se puede hacer mejor:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	if len(candidate) != 9 {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

Y un poco más expresivo:

```go
package nif

import "errors"

func NewNif(candidate string) error {
	const maxlength = 9
	
	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	return errors.New("bad start format")
}
```

Finalmente, un nuevo refactor del test para contemplar estos cambios. Retiramos nuestro cambio temporal aunque es posible que tengamos que volver a utilizarlo en el futuro.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

```

Fíjate que hemos podido hacer todos estos cambios sin que fallaran los tests.

## Avanzando en la estructura

El código está bastante compacto, así que vamos a añadir un nuevo test que nos permita avanzar con la validez de la estructura. El fragmento central del NIF está compuesto sólo por números, exactamente siete:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Lo lanzamos para asegurarnos de que falla por la razón adecuada. Para hacer pasar el test tenemos que resolver primero el test anterior, por lo que añadiremos código para verificar que el primer símbolo es un número o una letra en el conjunto `X`, `Y` y `Z`. Lo haremos con una expresión regular:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	invalid := regexp.MustCompile(`(?i)^[^0-9XYZ].*`)

	if invalid.MatchString(candidate) {
		return errors.New("bad start format")
	}
	
	return errors.New("bad middle format")
}
```

Con este código hacemos pasar el test, pero vamos a hacer un refactor.

## Invertir la condicional

Tiene sentido que en vez de hacer *match* contra una expresión regular que excluya los string no válidos, hagamos *match* contra una expresión que los detecte. Con eso tendremos que invertir la condicional. Lo cierto es que el cambio es bastante pequeño:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad start format")
	}
	
	return errors.New("bad middle format")
}
```

## El final de la estructura

Nos estamos acercando al final de la validación estructural del NIF, necesitamos un test que nos diga cuáles rechazar en función de su último símbolo, lo que nos llevará a resolver el problema que quedaba pendiente del test anterior:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

De las cuatro letras no válidas tomamos la `U` como ejemplo, pero podrían ser la `I`, la `Ñ` y la `O`.

Sin embargo, para hacer pasar el test, lo que hacemos es asegurarnos que el anterior se va a cumplir. Lo más fácil es implementar eso de forma separada:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad start format")
	}

	valid = regexp.MustCompile(`(?i)^.\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad middle format")
	}

	return errors.New("invalid end format")
}
```

## Compactando el algoritmo

Con esto pasa el test y nos encontramos con una situación familiar que ya hemos resuelto antes: tenemos que convertir los errores en más genéricos con la ayuda temporal de un control extra en el test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad start format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad middle format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Hacemos el cambio en los mensajes de error en el código de producción:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ].*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i)^.\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Ahora unificamos la expresión regular y las condicionales:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.*`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}
	
	return errors.New("invalid end format")
}
```

Todavía podemos hacer un cambio pequeño pero importante. La última parte de la expresión regular `.*` está para cumplir el requisito de que se haga match de toda la cadena, pero realmente no necesitamos el cuantificador ya que nos basta un carácter:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	const maxlength = 9

	if len(candidate) != maxlength {
		return errors.New("bad format")
	}

	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Y esto nos revela un detalle, la expresión regular hace *match* únicamente en cadenas de exactamente nueve caracteres, por lo que la validación inicial de la longitud resulta innecesaria:

```
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("invalid end format")
}
```

Tanto camino recorrido para desandarlo. Sin embargo, al principio no sabíamos esto y es ahí donde está el valor del proceso.

Por último, cambiamos el test para reflejar los cambios y volver a quitar nuestro apoyo temporal:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

## Terminando la validación estructural

Necesitamos un nuevo test para terminar la parte de la validación estructural. Los tests existentes nos garantizarían la corrección de los `strings`, pero la siguiente validación ya implica el algoritmo para calcular la letra de control. 

El test que necesitamos ahora controla que no podemos usar un NIF estructuralmente válido, pero en el que la letra de control sea incorrecta. Al enunciar la kata pusimos algunos ejemplos, como `00000000S`. Este es el test:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Y he aquí el código que lo hace pasar:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i).*[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("invalid end format")
	}
	
	return errors.New("bad control letter")
}
```

Y, cómo no, toca refactorizar.

## Compactando la validación

Este refactor es bastante obvio, pero tenemos que volver a proteger el test temporalmente:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Hacemos más general el error para poder unificar las expresiones regulares y las condicionales:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}.$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	valid = regexp.MustCompile(`(?i).*[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Y hacemos ahora la unificación, mientras los tests siguen pasando:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Con esto terminamos la validación de la estructura y nos quedaría implementar el algoritmo **mod23**. Pero para eso necesitamos un pequeño cambio de enfoque.

## Seamos optimistas

El algoritmo es, de hecho, muy sencillo: obtener un resto (de dividir por 23) y buscar la posición indicada por el resultado en una tabla. Es fácil de implementar en una sola iteración. Sin embargo, vamos a hacerlo más lentamente.

Hasta ahora nuestros tests eran pesimistas porque esperaban ejemplos incorrectos de NIF para poder pasar. Nuestros tests ahora tienen que ser optimistas, es decir, van a esperar que le pasemos ejemplos de NIF válidos.

En este punto introduciremos un cambio. Si recuerdas, de momento sólo estamos devolviendo el error y la interfaz final de la función devolverá el `string` validado como un tipo NIF que vamos a crear para la ocasión.

Es decir, tenemos que cambiar el código para que devuelva algo, y que ese algo sea de un tipo que todavía no existe.

Para hacer este cambio sin romper los tests vamos a hacer una técnica de refactor un tanto rebuscada.

## Cambiando la interfaz pública

En primer lugar, extraemos el cuerpo de `NewNif` a otra función:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	return FullNewNif(candidate)
}

func FullNewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Los tests siguen pasando. Ahora introducimos una variable:

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	err := FullNewNif(candidate)
	return err
}

func FullNewNif(candidate string) error {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return errors.New("bad format")
	}

	return errors.New("bad control letter")
}
```

Con esto podemos hacer que `FullNewNif` devuelva el `string` sin afectar al test porque queda encapsulado dentro de `NewNif`.

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) error {
	_, err := FullNewNif(candidate)
	return err
}

func FullNewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

Los tests siguen pasando y casi hemos acabado. En el test cambiamos el uso de `NewNif` por `FullNewNif`.

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := FullNewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}
```

Siguen pasando los tests. Ahora la función devuelve los dos parámetros que queríamos y no hemos roto los tests. Podemos eliminar la función `NewNif` original.

```go
package nif

import (
	"errors"
	"regexp"
)

func FullNewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

Y usar las herramientas del IDE para cambiar el nombre de la función `FullNewNif` a `NewNif`.

```go
package nif

import (
	"errors"
	"regexp"
)

func NewNif(candidate string) (string, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return candidate, errors.New("bad control letter")
}
```

## Ahora sí

Nuestro objetivo ahora es empujar la implementación el algoritmo **mod23**. Esta vez los tests esperan que la cadena sea válida. Además, queremos forzar que se devuelva el tipo `Nif` en lugar de `string`.

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000023T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)
			
			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}
			
			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

En un primer paso cambiamos el código de producción para introducir y usar el tipo `Nif`:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	return "", errors.New("bad control letter")
}
```

Ahora el test estará fallando porque no hemos validado nada todavía. Para hacerlo pasar añadimos un condicional:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate == "00000023T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Una nota sobre **Go** es que los tipos *custom* no pueden tener valor `nil`, sino vacío. Por eso en caso de error devolvemos `string` vacío.

## Avanzando el algoritmo

De momento no hay muchos motivos para hacer refactor, así que vamos a introducir un test que nos ayude a avanzar un poco. En principio, queremos lograr que nos impulse a separar la parte numérica de la letra de control.

Una posibilidad sería testear otro NIF que acabe con la letra `T`, como el `00000046T`.

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000023T"},
		{"should accept mod23 being 0 letter T", "00000046T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Para hacer pasar el test, podemos hacer esta implementación sencilla:

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate == "00000023T" {
		return Nif(candidate), nil
	}

	if candidate == "00000046T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Y ahora empezamos a refactorizar.

## Más refactor

En el código de producción podemos ver lo que hay de diferente y de común entre los ejemplos. En ambos la letra de control es `T` y la parte numérica es divisible entre 23, por lo que su **mod23** será 0.

Ahora podemos hacer el refactor. Un primer paso.

```go
package nif

import (
	"errors"
	"regexp"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	if control == "T" {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Y, después de ver pasar los tests, el segundo paso:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23
	
	if control == "T" && modulus == 0 {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Con este cambio los tests pasan y acepta todos los NIF válidos acabados en `T`.

## Validando más letras de control

En este tipo de algoritmos no tiene mucho sentido intentar validar todas las letras de control, pero podemos introducir una más para forzarnos a entender cómo debería evolucionar el código ahora. Probaremos con una nueva letra:

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Ya tenemos este test fallando, así que vamos a hacer una implementación muy sencilla:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := string(candidate[8])

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == "T" && modulus == 0 {
		return Nif(candidate), nil
	}

	if control == "R" && modulus == 1 {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Esto ya nos da una idea de por dónde van los tiros: un mapa entre letras de control y el resto al dividir por 23. Sin embargo, es frecuente que los `strings` puedan funcionar como `arrays` en muchos lenguajes, por lo que nos basta tener un `string` con todas las letras de control ordenadas y acceder a la letra en la posición indicada por el módulo para saber cual es la correcta.

## Un refactor para más simplicidad

Primero implementamos una versión simple de esta idea:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	controlMap := "TR"

	control := candidate[8]

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == controlMap[modulus] {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Ya tenemos una primera versión. Luego añadiremos la lista completa de letras, pero podemos intentar arreglar un poco el código actual. Primero hacemos que `controlMap` sea constante:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	const controlMap = "TR"

	control := candidate[8]

	numeric, _ := strconv.Atoi(candidate[0:8])

	modulus := numeric % 23

	if control == controlMap[modulus] {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

En realidad podríamos extraer toda la parte del cálculo del módulo a otra función. Primero reorganizamos el código para controlar mejor la extracción:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := candidate[8]
	
	const controlMap = "TR"
	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23
	shouldBe := controlMap[modulus]
	
	if control == shouldBe {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}
```

Recuerda verificar que pasan los tests. Ahora extraemos la función:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	control := candidate[8]

	if control == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TR"
	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23
	
	return controlMap[modulus]
}
```

Y podemos compactar el código un poco más, mientras que añadimos las demás letras de control. A primera vista parece "trampa", pero en el fondo no es más que generalizar un algoritmo que se podría enunciar como "toma la letra que hay en la posición dada por el **mod23** de la parte numérica".

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	numeric, _ := strconv.Atoi(candidate[0:8])
	modulus := numeric % 23

	return controlMap[modulus]
}
```

Con esto ya podemos validar todos los NIF, excepto los NIE, que empiezan por las letras `X`, `Y` ó `Z`.

## Dar soporte a NIE

Ahora que hemos implementado el algoritmo general vamos a tratar sus excepciones, que no son tanto. Los NIE comienzan con una letra que a efectos del cálculo se reemplaza con un número.

El test que parece más evidente en este punto es el siguiente:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000023T"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

El caso `X0000023T` es equivalente a `00000023T`, ¿afectará eso al resultado del test?

Ejecutamos el test y… ¿sorpresa? El test pasa. Esto ocurre porque la conversión que hacemos en esta línea genera un error que actualmente estamos ignorando, pero permite que la parte numérica siga siendo equivalente a 23, cuyo **mod23** es 0 y le corresponde igualmente la letra `T`.

```go
	numeric, _ := strconv.Atoi(candidate[0:8])
```

En otro lenguajes la conversión no falla, pero asume la X como 0 al realizar la conversión.

En cualquier caso eso nos abre dos posible caminos:

* anular este test y refactorizar el código de producción para tratar el error y que el test falle cuando lo volvamos a incluir
* probar otro ejemplo que sí pueda fallar (`Y0000000Z`) y hacer el cambio después 

Posiblemente para este caso la segunda opción sería más que suficiente ya que con nuestras validaciones estructurales ya garantizaríamos que el error no tiene posibilidad de aparecer una vez que la función esté completamente desarrollada.

Sin embargo, podría ser interesante introducir la gestión del error. Manejar los errores, incluyendo los que *nunca podrían llegar a pasar*, es siempre una buena práctica.

Así que, anulemos el test e introduzcamos un refactor para manejar el error:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		//{"should accept NIE starting with X", "X0000023X"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Aquí el refactor. En este caso, gestiono el error provocando un `panic`, que no es la mejor manera de gestionar un error, pero que nos permite hacer que el test pueda fallar y obligarnos a implementar la solución.

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	numeric, err := strconv.Atoi(candidate[0:8])

	if err != nil {
		panic("Numeric part contains letters")
	}
	
	modulus := numeric % 23

	return controlMap[modulus]
}
```

Al ejecutar los tests, comprobamos que siguen en verde. Pero si reactivamos el último test vemos cómo falla:

```go
func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000023X"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Y esto ya nos obliga a introducir un tratamiento para estos casos. Básicamente es reemplazar la `X` por `0`:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	if string(candidate[0]) == "X" {
		numPart = strings.Replace(numPart, "X", "0", 1)
	}

	numeric, err := strconv.Atoi(numPart)

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

Se puede refactorizar usando un `Replacer`:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	re := strings.NewReplacer("X", "0")
	
	numeric, err := strconv.Atoi(re.Replace(numPart))

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

En este punto podríamos hacer un test para forzarnos a introducir el resto de reemplazos. Es barato, aunque en el fondo no es muy necesario por lo que comentamos antes, podemos interpretar esta parte del algoritmo como "reemplazar las letras iniciales X, Y y Z por los números 0, 1 y 2, respectivamente":

```go
package nif

import "testing"

func TestShouldFailIfCandidateIsInvalid(t *testing.T) {
	tests := []struct {
		name string
		example string
		expected string
	}{
		{"should fail if too long", "01234567891011", "bad format"},
		{"should fail if too short", "01234", "bad format"},
		{"should fail if starts with a letter other than X, Y, Z", "A12345678", "bad format"},
		{"should fail if doesn't have 7 digit in the middle", "0123X567R", "bad format"},
		{"should fail if doesn't end with a valid control letter", "01234567U", "invalid end format"},
		{"should fail if doesn't end with the right control letter", "00000000S", "bad control letter"},

	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewNif(test.example)

			if err.Error() != test.expected  && err.Error() != "bad format" {
				t.Errorf("Expected %s, got %s", test.expected, err.Error())
			}
		})
	}
}

func TestShouldCreateNifTypeWithValidCandidate(t *testing.T) {
	tests := []struct {
		name string
		example string
	}{
		{"should accept mod23 being 0", "00000000T"},
		{"should accept mod23 being 0 letter T", "00000023T"},
		{"should accept mod23 being 1 letter R", "00000024R"},
		{"should accept NIE starting with X", "X0000000T"},
		{"should accept NIE starting with Y", "Y0000000Z"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			nif, err := NewNif(test.example)

			if nif != Nif(test.example) {
				t.Errorf("Expected Nif(%s), got %s", test.example, nif)
			}

			if err != nil {
				t.Errorf("Unexpected error %s", err.Error())
			}
		})
	}
}
```

Sólo es necesario añadir los pares correspondientes:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] == shouldHaveControl(candidate) {
		return Nif(candidate), nil
	}

	return "", errors.New("bad control letter")
}

func shouldHaveControl(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	var numPart = candidate[0:8]

	re := strings.NewReplacer("X", "0", 
	                          "Y", "1", 
	                          "Z", "2")

	numeric, err := strconv.Atoi(re.Replace(numPart))

	if err != nil {
		panic("Numeric part contains letters")
	}

	modulus := numeric % 23

	return controlMap[modulus]
}
```

Después de un rato de refactor, esta sería una posible solución:

```go
package nif

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

type Nif string

func NewNif(candidate string) (Nif, error) {
	valid := regexp.MustCompile(`(?i)^[0-9XYZ]\d{7}[^UIOÑ0-9]$`)

	if !valid.MatchString(candidate) {
		return "", errors.New("bad format")
	}

	if candidate[8] != controlLetterFor(candidate) {
		return "", errors.New("bad control letter")
	}

	return Nif(candidate), nil
}

func controlLetterFor(candidate string) uint8 {
	const controlMap = "TRWAGMYFPDXBNJZSQVHLCKE"

	position, err := controlPosition(candidate[0:8])

	if err != nil {
		panic("Numeric part contains letters")
	}

	return controlMap[position]
}

func controlPosition(numPart string) (int, error) {
	re := strings.NewReplacer("X", "0", "Y", "1", "Z", "2")

	numeric, err := strconv.Atoi(re.Replace(numPart))

	return numeric % 23, err
}
```

## Qué hemos aprendido con esta kata

* Utilizar sad paths para mover el desarrollo
* Utilizar table tests en Go para reduciendo el coste de añadir nuevos tests
* Una técnica para cambiar los errores devueltos por otro más general sin romper los tests
* Una técnica para cambiar la interfaz pública del código de producción sin romper los tests

## Referencias

* [Is Go object oriented?](https://flaviocopes.com/golang-is-go-object-oriented/)[^fn37]


[^fn37]: https://flaviocopes.com/golang-is-go-object-oriented/
