# Solving the Prime Factors kaka

## Statement of the kata

Our objective will be to write a program that decomposes a natural number into its prime factors. For the sake of simplicity, we won't group the factors as powers. We'll leave that as a posterior exercise, if you wish to advance a bit further.

## Language and approach

We're going to solve this kata in Javascript, using the Jest testing *framework*. We'll create a `primefactors` function to which we'll pass the number that we wish to decompose, obtaining as a response an array of its prime factors sorted from lowest to highest.

```js
var primesOf18 = primefactors(18);
// -> [2, 3, 3]
```

## Define the function

Our first test expects the `primefactors` function to exist:

```js
describe('Calculate prime factors', function () {
    it ('should exist', () => {
       expect(primefactors())
    });
});
```

Which, as we already know, hasn't been defined yet:

```
ReferenceError: primefactors is not defined
```

We introduce it without further ado. For now, in the test file itself:

```js
function primefactors() {
    
}
```

A> Normally at this point, once we've made the test pass, we would move it to its own file. We don't need to do so in an exercise, but it's a nice habit.

We haven't yet communicated with the function in the test, so we're going to introduce that idea, passing it a first example of a number to decompose, along the result that we expect. The first thing that should draw our attention is, that due to the peculiarities of the definition and distribution of primes among natural numbers, we have a very intuitive way of organizing the examples and writing the test. It's almost enough to start with number one and advance incrementally.

Number one, moreover, is a particular case (it doesn't have any prime factor), so it suits us especially well as a first test.

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it ('should exist', () => {
       expect(primefactors())
    });
	
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });
});
```

To pass the test we need a minimal implementation of the function:

```js
function primefactors() {
    return [];
}

export default primefactors;
```

Note that we don't even implement the function's necessity for a parameter. We're gonna make the test be the one that asks for it first. Meanwhile, we delete the first test, given that it has become redundant.

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {	
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });
});
```


## Define the function's signature

The second test should help us define the function's signature. To do so, we need a case in which we expect a response different than `[]`, something we'll be able to do if we receive a parameter that introduces the necessary variation. Number 2 is a good example with which to achieve this:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('2 is a prime number', () => {
        expect(primefactors(2)).toEqual([2])
    })
});
```

To solve this case we need to take into account the parameter defined by the function, which forces us to introduce and use it. In our solution, we handle the case that the previous test states, and we make an obvious implementation to pass the test that we've just introduced. We're postponing the implementation of the algorithm until we have more information:

```js
function primefactors(numberToDecompose) {
    if (numberToDecompose === 1) {
        return [];
    }

    return [2];
}

export default primefactors;
```

## Obtaining more imformation about the problem

The next case that we're going to try is decomposing number 3, which is prime like number 2. This test will help us to better understand how to handle these cases:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('2 is a prime number', () => {
        expect(primefactors(2)).toEqual([2])
    })

    it ('3 is also a prime number', () => {
        expect(primefactors(3)).toEqual([3])
    })
});
```

Now that we have this failing test we'll make an obvious implementation, such as returning the passed number itself. Since it's a prime number, this is perfectly correct. There's not much else to do here.

```js
function primefactors(numberToDecompose) {
    if (numberToDecompose === 1) {
        return [];
    }

    return [numberToDecompose];
 
}

export default primefactors;
```

## Introducing a test that doesn't fail

In the presentation of the kata we've divided the cases into categories. Let's review:

* Edge or special cases, such as 1
* Prime numbers, like 2, 3, or 5
* Nonprime numbers, like 4, 6, or 8

We've already covered the first category, since there are no more edge cases to consider.

We haven't begun to treat the third category yet, and we haven't done any test with any of its examples.

The second category is the one that we've been testing until now. At this point, we could keep selecting examples from this category and trying new cases. But, what would happen? Let's see it.

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('2 is a prime number', () => {
        expect(primefactors(2)).toEqual([2])
    })

    it ('3 is also a prime number', () => {
        expect(primefactors(3)).toEqual([3])
    })

    it ('5 is also a prime number', () => {
        expect(primefactors(5)).toEqual([5])
    })
    
});
```

The test passes without implementing anything!

It was pretty obvious, wasn't it? At this moment, the so-called algorithm, doesn't do anything else than consider all numbers as primes. For this reason, if we keep using prime numbers as examples, nothing will force us to make changes to the implementation.

When we add a test that doesn't fail, it means that the algorithm that we're developing is already general enough to solve every case from that category, and therefore, it's time to move on to a different category that we cannot yet successfully handle. Or, if we've already discovered all of the possible categories, it means that we've already finished!

We're going to start using example from the nonprime category. But, we're also going to refactor the solution to be able to see these categories in a more explicit manner:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })
});

```

## Questioning our algorithm

The first nonprime that we have is number 4, and it's the simplest of them all for many reasons. So, this time we write a test that will fail:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })
});
```

There are many ways of approaching this implementation. For example, we have this one that, while especially naive, is effective:

```js
function primefactors(numberToDecompose) {
    if (numberToDecompose === 1) {
        return [];
    }

    if (numberToDecompose === 4) {
        return [2, 2];
    }

    return [numberToDecompose];
}

export default primefactors;
```

In spite of its simpleness, it's interesting. It help us understand that we have to distinguish between primes and nonprimes in order to develop the algorithm.

Nevertheless, it has a very unkept look. Let's try to organize it a bit more neatly:

```js
function primefactors(numberToDecompose) {
    if (numberToDecompose > 1) {
        if (numberToDecompose === 4) {
            return [2, 2];
        }
    
        return [numberToDecompose];
    }

    return [];
}

export default primefactors;
```

It basically says: if a number is higher than 1 we try to decompose it. If it's 4, we return its factorization. And if it's not, we return the same number, for it will be prime. Which is true for all of our current examples.

## Discovering the multiples of 2

The next number that we can decompose is 6. A nice thing about this kata is that every nonprime number gives us a different response, and that means that every test is going to provide us with some information. Here it is:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })

    it ('6 is 2 * 3', () => {
        expect(primefactors(6)).toEqual([2, 3])
    })
});

```

Let's begin with the naive implementation:

```js
function primefactors(numberToDecompose) {
    if (numberToDecompose > 1) {
        if (numberToDecompose === 4) {
            return [2, 2];
        }
    
        if (numberToDecompose === 6) {
            return [2, 3];
        }

        return [numberToDecompose];
    }

    return [];
}

export default primefactors;
```

There's nothing wrong with doing it this way. On the contrary, this way of solving the problem starts highlighting regularities. 4 and 6 are multiples of 2, so we want to introduce this knowledge in the shape of a refactoring. And we could do this thanks to our tests, that demonstrate that the function already decomposes them correctly. So, we're going to modify the code without changing the behavior that we've already defined through tests.

Our first try relies on the fact that the first factor is 2 and is common between them. That is, we can design an algorithm that processes multiples of 2 and, for now, we assume that the remainder of that first division by 2 is the second of its factors, whichever it is.

To do so we have to introduce an array-type variable with which to deliver the response, to which we'll be adding the factors as we discover them.

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose > 1) {
        if (numberToDecompose === 4) {
            factors.push(2);
            factors.push(2);

            return factors;
        }
    
        if (numberToDecompose === 6) {
            factors.push(2);
            factors.push(3);
            
            return factors;
        }

        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

This has been a first step, now it's clearer how it would work, and we can generalize it by expressing it like this:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose > 1) {
        if (numberToDecompose % 2 === 0) {
            factors.push(2);
            factors.push(Math.floor(numberToDecompose/2));

            return factors;
        }
    
        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

This refactoring almost works, but the test for number 2 has stopped passing. We fix it, and we advance a step further.

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose > 1) {
        if (numberToDecompose % 2 === 0 && numberToDecompose > 2) {
            factors.push(2);
            numberToDecompose = Math.floor(numberToDecompose/2);
        }
    
        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

This new implementation passes all the tests, and we're ready to force a new change.

## Introducing more factors



Dentro de los números no primos podríamos considerar varias agrupaciones a la hora de seleccionar ejemplos. Tenemos casos en que los números se descomponen en el producto de dos factores primos, y casos en los que se descomponen en el producto de 3 ó más factores. Esto viene a cuenta porque nuestros próximos ejemplos son 8 y 9. El 8 es 2 * 2 * 2, mientras que 9 es 3 * 3. El caso del 8 nos obliga a considerar los casos en que podemos descomponer un número en más de dos factores, y el del 9, aquellos casos en los que se introducen nuevos divisores.

En principio puede darnos igual empezar por cualquiera de los dos. Quizá la clave sea escoger el caso que te parezca más fácil de abordar. Aquí vamos a empezar por descomponer el número 8. De este modo, mantenemos el divisor 2 que, en este momento, nos parece algo más fácil de abordar.

Hagamos un test:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })

    it ('6 is 2 * 3', () => {
        expect(primefactors(6)).toEqual([2, 3])
    })

    it ('8 is 2 * 2 * 2', () => {
        expect(primefactors(8)).toEqual([2, 2, 2])
    })
});

```

Para implementar tenemos que cambiar un `if` por un `while`. Es decir, tenemos que seguir dividiendo el número por 2 hasta que ya no podamos más:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose > 1) {
        while (numberToDecompose % 2 === 0 && numberToDecompose > 2) {
            factors.push(2);
            numberToDecompose = Math.floor(numberToDecompose/2);
        }
    
        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

Este cambio es muy espectacular porque es muy pequeño y muy potente. Aplicándolo podemos descomponer cualquier número que sea potencia de 2, ni más ni menos. Pero no es éste el objetivo final, sino que queremos descomponer cualquier número y para eso tenemos que poder introducir nuevos divisores.

## Nuevos divisores

En este punto necesitamos un ejemplo que nos obligue a introducir nuevos divisores. Antes hemos dejado aparcado el 9, y ahora nos toca retomarlo. El 9 es un buen ejemplo porque es múltiplo de 3, sin serlo de 2. Vamos a hacer un test que sabemos que fallará:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })

    it ('6 is 2 * 3', () => {
        expect(primefactors(6)).toEqual([2, 3])
    })

    it ('8 is 2 * 2 * 2', () => {
        expect(primefactors(8)).toEqual([2, 2, 2])
    })

    it ('9 is 3 * 3', () => {
        expect(primefactors(9)).toEqual([3, 3])
    })
});
```

De nuevo, empecemos con una implementación muy ingenua, pero que funciona. Lo importante es que el test pase, prueba de que hemos implementado el comportamiento.

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose > 1) {
        while (numberToDecompose % 2 === 0 && numberToDecompose > 2) {
            factors.push(2);
            numberToDecompose = Math.floor(numberToDecompose/2);
        }

        while (numberToDecompose % 3 === 0 && numberToDecompose > 3) {
            factors.push(3);
            numberToDecompose = Math.floor(numberToDecompose / 3);
        }
    
        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

Con el código anterior, todos los tests están en verde. En este punto parece claro que cada nuevo divisor que queramos introducir, como el 5, necesitará una repetición del bloque así que vamos a refactorizar a una solución general.

```js
function primefactors(numberToDecompose) {

    let factors = [];

    let divisor = 2;

    while (numberToDecompose > 1) {
        while (numberToDecompose % divisor === 0) {
            factors.push(divisor);
            numberToDecompose = Math.floor(numberToDecompose / divisor);
        }
        divisor++;
    }

    return factors;
}

export default primefactors;
```

Este algoritmo tiene pinta de ser bastante general. Así que probemos un par de casos:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('2 is a prime number', () => {
        expect(primefactors(2)).toEqual([2])
    })

    it ('3 is also a prime number', () => {
        expect(primefactors(3)).toEqual([3])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })
    
    it ('6 is 2 * 3', () => {
        expect(primefactors(6)).toEqual([2, 3])
    })

    it ('8 is 2 * 2 * 2', () => {
        expect(primefactors(8)).toEqual([2, 2, 2])
    })

    it ('9 is 3 * 3', () => {
        expect(primefactors(9)).toEqual([3, 3])
    })

    it ('10 is 2 * 5', () => {
        expect(primefactors(10)).toEqual([2, 5])
    })
        
    it ('12 is 2 * 2 * 3', () => {
        expect(primefactors(12)).toEqual([2, 2, 3])
    })
});
```

Hemos añadido dos tests que pasan. Por lo que parece, hemos resuelto el problema. Pero, ¿no te queda la sensación de haber saltado demasiado en este último paso?

## El camino más corto no siempre es el más rápido

El camino de desarrollo en TDD no siempre es fácil. El siguiente test a veces es bastante evidente y otras veces tenemos varias alternativas. Escoger mal el camino nos puede llevar a un callejón sin salida o, como en este caso, a un punto en que tengamos que implementar mucho de golpe. Y como hemos visto, los cambios que añadamos al código de producción deberían ser lo más pequeños posibles.

En el sexto test preferimos explorar la vía de las repeticiones del mismo factor en lugar de forzar que aparecieran otros factores primos. ¿Hubiera sido mejor seguir esta ramificación del problema? Probémoslo, rebobinamos y volvemos a la situación antes del sexto test.

## Introduciendo nuevos factores, segundo intento

Esta es la versión del código de producción en la que estábamos al llegar al sexto test:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose % 2 === 0) {
        factors.push(2);
        numberToDecompose = Math.floor(numberToDecompose / 2);
    }
    
    if (numberToDecompose > 1) {
        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

Ahora sigamos por la otra ruta:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })

    it ('6 is 2 * 3', () => {
        expect(primefactors(6)).toEqual([2, 3])
    })
    
    it ('9 is 3 * 3', () => {
        expect(primefactors(9)).toEqual([3, 3])
    })
});
```

El siguiente código de producción nos permite pasar el nuevo test y todos los anteriores:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    if (numberToDecompose % 2 === 0) {
        factors.push(2);
        numberToDecompose = Math.floor(numberToDecompose / 2);
    }

    if (numberToDecompose % 3 === 0) {
        factors.push(3);
        numberToDecompose = Math.floor(numberToDecompose / 3);
    }
    
    if (numberToDecompose > 1) {
        factors.push(numberToDecompose);
    }

    return factors;
}

export default primefactors;
```

Ahora podríamos refactorizar:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    let divisor = 2;

    while (divisor < numberToDecompose) {
        if (numberToDecompose % divisor === 0) {
            factors.push(divisor);
            numberToDecompose = Math.floor(numberToDecompose / divisor);
        }
        divisor++;
    }
    
    if (numberToDecompose > 1) {
        factors.push(numberToDecompose);
    }
    
    return factors;
}

export default primefactors;
```


## Más de dos factores

Para introducir más de dos factores necesitamos un test:

```js
import primefactors from "../src/primefactors";

describe('Calculate prime factors', function () {
    it('1 should not have factors', () => {
        expect(primefactors(1)).toEqual([]);
    });

    it ('prime numbers cannot be decomposed', () => {
        expect(primefactors(2)).toEqual([2])
        expect(primefactors(3)).toEqual([3])
        expect(primefactors(5)).toEqual([5])
    })

    it ('4 is 2 * 2', () => {
        expect(primefactors(4)).toEqual([2, 2])
    })

    it ('6 is 2 * 3', () => {
        expect(primefactors(6)).toEqual([2, 3])
    })

    it ('9 is 3 * 3', () => {
        expect(primefactors(9)).toEqual([3, 3])
    })

    it ('8 is 2 * 2 * 2', () => {
        expect(primefactors(8)).toEqual([2, 2, 2])
    })
});
```

El cambio necesario es sencillo:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    let divisor = 2;

    while (divisor < numberToDecompose) {
        while (numberToDecompose % divisor === 0) {
            factors.push(divisor);
            numberToDecompose = Math.floor(numberToDecompose / divisor);
        }
        divisor++;
    }
    
    if (numberToDecompose > 1) {
        factors.push(numberToDecompose);
    }
    
    return factors;
}

export default primefactors;
```

Y podemos librarnos del último `if` puesto que queda cubierto por el while que acabamos de introducir:

```js
function primefactors(numberToDecompose) {

    let factors = [];

    let divisor = 2;

    while (divisor <= numberToDecompose) {
        while (numberToDecompose % divisor === 0) {
            factors.push(divisor);
            numberToDecompose = Math.floor(numberToDecompose / divisor);
        }
        divisor++;
    }
    
    return factors;
}

export default primefactors;
```

Si añadimos nuevos tests veremos que podemos factorizar cualquier número sin problemas. Es decir, con este último cambio y su refactor hemos terminado el desarrollo de la clase. ¿Ha sido mejor este camino? En parte sí. Hemos llegado a un algoritmo casi idéntico, pero diría que el recorrido ha sido más suave, los saltos de código de producción menos pronunciados y todo ha ido mejor hilado.

## ¿Tenemos criterios para elegir buenos ejemplos?

Desde el punto de vista de QA tradicional existen una serie de métodos para elegir los casos de test. Sin embargo, estos métodos no son necesariamente aplicables en TDD. Recuerda cómo empezábamos este libro: QA y TDD no son lo mismo pese a usar las mismas herramientas y solaparse mucho ambas disciplinas. TDD es una metodología para guiar el desarrollo de software y los tests más adecuados para hacerlo pueden ser sutilmente diferentes de los que usaríamos para verificar el funcionamiento de un software.

Por ejemplo, la categorización que hemos hecho de los números en primos y no primos puede ser más que suficiente en QA, pero en TDD los casos de números no primos podrían subdividirse:

* Potencias de un factor primo, como el 4, el 8 o el 9, que implican un único primo multiplicado varias veces por sí mismo.
* Producto de diferentes primos, como el 6, el 10, que implican varios números primos.
* Productos de n factores primos, con n mayor que dos.

Cada una de estas categorías nos fuerza a implementar distintas partes del algoritmo, lo que puede plantearnos problemas más o menos fáciles de resolver. Incluso, una mala elección podría llevarnos a un callejón sin salida.

Sin embargo, nada nos impide volver atrás si nos quedamos estancados. Cuando tengamos una duda razonable de si tomar un curso u otro en TDD, lo mejor es tomar nota de cuál es el estado del desarrollo y ese punto, marcándolo como un punto de retorno en caso de que nos metamos en algún cenagal de código. Marcha atrás y pensar de nuevo. Haberse equivocado es también información.

## Qué hemos aprendido con esta kata

* Con esta kata hemos aprendido cómo a medida que añadimos tests y estos son más específicos, el algoritmo se hace más general
* También hemos visto que obtenemos mejores resultados priorizando las transformaciones (cambios en el código de producción) más sencillas
