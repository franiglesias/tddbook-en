# TDD approaches

The Test Driven Development methodology is based on a relatively small set of rules or principles. But an aspect that isn't explicitly defined is the way in which this can be applied to different development situations.

Thus, for example, the way in which we can direct the development of a class or a function through tests is very evident. A good deal of the kata in this book and, in general, the entry-level TDD kata in general, do exactly that. The problem arrives when we jump to the *real world*, a point at which many people fail to find benefits in the introduction of TDD in their development process.

The key issue here is that a user story doesn't usually consist of developing a class and integrating it within the existing code, but rather, the usual is developing features that involve a set of components including some kind of interface to the outside world (UI, API), as well as use cases, entities and domain services, among others.

This leads to a very simple question: where to start?

The different ways of answering this questions could be reduced to three, not as distant between them as one might think. In fact, they're not mutually exclusive.

## Classic TDD or Detroit School

This approach goes by both names because it its, so to speak, the TDD original model propose by the founders of the Extreme Programming paradigm (Kent Beck, Ward Cunningham, Ron Jeffries), born in the context of the Chrysler Comprehensive Compensation System project in Detroit.

Following this philosophy, a complex project would usually be approached by defining the necessary software units and creating each one of them through a standard TDD process. 

Taking a very simplistic example: imagine that our task is designing an API endpoint.

This would mean creating, at least, a controller, a use case, one or two entities, and their corresponding repositories.

In this classic TDD approach, one the necessary components have been determined, we would begin creating them in dependency order, starting from the domain entities and advancing outwards. That is to say, if to build a unit I need another unit, I will build the latter first. Since the dependencies point to the domain, it would be appropriate to start solving the problem in the domain layer and advance by going out towards the outermost layers.

Some of the features that characterize this model are:

* It's tested against the units' public APIs, using *black box testing*. This implies that we don't make assumptions in the test about the way the unit is implemented.
* Special emphasis on the refactoring phase, in which the design is introduced. We must refactor as soon as we have green tests, as small as the opportunity may look.
* Keeps the use of test doubles to a minimum, essentially limiting them to architectural boundaries.
* Development from the inside and outwards. Prioritizes the identification and development of domain logic.
* It focuses on the state and outcomes of objects and their methods.

This approach provides TDD's expected benefits:

* Work in small and manageable increments.
* Generate a safety net with many regression tests.
* Possibility of refactoring the implementation with great safety.

As for drawbacks, it should be noted:

* Tests don't really help drive the design, but rather the implementation of the units. The design is done during the refactoring phase and can lead to the extraction of unit collaborators that are tested through the unit's public interface.
* We run the risk of creating software units that are too large, something that can be addressed by applying refactoring intensively, specially extracting to private methods and collaborators when possible.
* Also, we run the risk of creating unnecessary functionality in the innermost units by not being clear about the requirements of the components that depend on them. It contradicts a bit the principle of interface segregation, which precisely promotes that they are defined by their customers' needs.
* Problems may arise when integrating the components.

## Outside-in, London School or *mockist*

It's origin also lies within the *extreme programming* community, but in this case, the Londoner one. It owes its name to the fact that it favors a methodology based on starting from the needs of the customers of a system.

In general, the *outside-in* methodology states that a complex project would be approached by defining its outermost interface and working inwards, discovering and defining the necessary units on the way with the help of doubles.

Some features that characterize this model are:

* The interactions between the units are tested, also called *white box testing*. That is, the assertions verify the messages that some components send to others.
* The refactoring phase is less important, and the design is done while tests are red.
* Test doubles are heavily used, 


* Se testean las interacciones entre las unidades, lo que conocemos como *white box testing*. Es decir las  aserciones verifican los mensajes que unos componentes envían a otros.
* La fase de refactor es menos importante y el diseño se hace con el test en rojo.
* Los dobles de tests se usan de manera generosa, en cada momento se decide qué colaboradores maneja una unidad y se crean dobles para descubrir y establecer sus interfaces. Las clases reales se implementan posteriormente mediante un proceso TDD clásico en el que las dependencias se doblan primero y se implementan después. Por esta razón también se conoce este enfoque como *Mockist TDD*.
* El desarrollo va desde fuera hacia dentro, protegido por un test de aceptación.
* Se centra en la comunicación entre objetos, por lo que se podría considerar incluso un enfoque más OOP, en el sentido original de Alan Kay.

Beneficios

* Nos proporciona un enfoque de trabajo que encaja especialmente bien en equipos multidisciplinares y tiene más orientación a negocio.
* Reduce o elimina los problemas de integración del producto final.
* Reduce la probabilidad de escribir código innecesario, las interfaces son más compactas.
* Introduce la consideración del diseño desde el principio del proceso de desarrollo.
* Prestamos más atención a las interacciones entre objetos. Tener que usar primero los dobles para diseñar sus interfaces nos ayuda a que sean más concisas y fáciles de manejar.
* Encaja muy bien en la metodología *Behavior Driven Development*.

Inconvenientes

* El coste del refactor es más alto porque se centra en interacciones y los tests tienden a ser más frágiles por acoplamiento a la implementación. Sin embargo, hay que pensar que estas interacciones son necesarias y, sobre todo, han sido diseñadas y decididas por nosotras, por lo que son implementaciones razonablemente estables.

## Behavior Driven Development

Se podría decir que si empezamos Outside-in development desde un paso más externo, nos encontramos con [Behavior Driven Development](https://franiglesias.github.io/bdd-business-devel/).

TDD en sus dos escuelas principales es una metodología centrada en el proceso técnico de desarrollar software. Pero BDD da un paso más allá integrando el negocio en el desarrollo.

Esquemáticamente sigue siendo TDD. Se comienza con un test y el desarrollo es impulsado por nuevos tests. La diferencia es que en BDD nos preguntamos por comportamientos o features en los que estamos interesadas y las describimos en lenguaje de negocio con ejemplos. De hecho, existe un lenguaje estructurado para ello: *gherkin*.

Estas descripciones se traducen en forma de tests de aceptación y se desarrollan a partir de ahí, utilizando una metodología bastante similar a *Outside-in* que, a su vez, puede utilizar el enfoque clásico de TDD cuando toca implementar las unidades concretas de software. Con todo, el tipo de tests unitarios favorecidos por BDD tienden a usar un estilo "especificación mediante ejemplos" en oposición a aserciones.

En la práctica BDD es Outside-in TDD pero tomando como punto de partida a las personas interesadas en el software y sus necesidades, no los contratos o requisitos técnicos de la implementación.

Existen herramientas específicas para este enfoque, siendo la más conocida Cucumber, en Ruby, y que tiene *ports* para otros lenguajes. Estas herramientas sirven para convertir los documentos Gherkin en tests ejecutables. Pero a partir de este punto ya entramos en metodología *outside-in*.

## Entonces, ¿qué enfoque seguir? Y ¿Cómo aprender TDD a la luz de estos enfoques?

Como se decía al principio del capítulo, el aprendizaje de TDD clásico mediante katas puede ser difícil de transferir a la práctica cotidiana en un problema real de desarrollo. Sin embargo, es un aprendizaje necesario antes de introducirse al enfoque Outside-in que resulta mucho más realista en varios aspectos.

Outside-in no excluye el enfoque clásico, pero lo pone en contexto, mientras nos proporciona un enfoque de diseño dirigido por tests al que se podrían aplicar *grosso modo* los mismos principios de TDD: empezar con un test, escribir el mínimo código de producción para que el test pase y refactorizar la solución si hay oportunidad.

Al fin y al cabo se trata de herramientas y lo importante es tenerlas a mano para utilizarlas cuando nos resulten más apropiadas. En el trabajo real,  diría que lo importante es poder mezclar estilos a conveniencia. En una tarea concreta puede que empecemos con un estilo clásico, pero al llegar a cierto punto introduzcamos Mocks para no salirnos del foco de un determinado flujo y poder centrarnos en los detalles más tarde.

Es más difícil encontrar katas en las que se pueda usar un enfoque *outside-in*. Por lo general son más largas y complejas, aunque también es posible adaptar algunas katas clásicas para practicar este enfoque.

Un plan de formación en TDD podría estructurarse de la siguiente forma:

* Iniciación con katas clásicas
* Perfeccionamiento con katas en forma agile-kata
* Katas *outside-in*
* Perfeccionamiento con agile-kata complejas

## Referencias

* [Does TDD lead to good design](https://codurance.com/2015/05/12/does-tdd-lead-to-good-design/)[^fn43]
* [A case for Outside-in Development](https://codurance.com/2017/10/23/outside-in-design/)[^fn44]
* [Detroit School TDD](https://github.com/testdouble/contributing-tests/wiki/Detroit-school-TDD)[^fn45]
* [London school TDD](https://github.com/testdouble/contributing-tests/wiki/London-school-TDD)[^fn46]
* [Extreme programming: origins](https://en.wikipedia.org/wiki/Extreme_programming#Origins)[^fn47]
* [The failures of "intro to TDD"](http://blog.testdouble.com/posts/2014-01-25-the-failures-of-intro-to-tdd/)[^fn48]
* [Endo-Testing: Unit Testing with Mock Objects (PDF)](https://www2.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF)[^fn49]
* [The London School of Test Driven Development](http://coding-is-like-cooking.info/2013/04/the-london-school-of-test-driven-development/)[^fn50]
* [Outside-In development with Double Loop TDD](http://coding-is-like-cooking.info/2013/04/outside-in-development-with-double-loop-tdd/)[^fn51]
* ["Tell, Don’t Ask" Object Oriented Design](http://coding-is-like-cooking.info/2013/05/tell-dont-ask-object-oriented-design/)[^fn52]


[^fn43]: https://codurance.com/2015/05/12/does-tdd-lead-to-good-design/
[^fn44]: https://codurance.com/2017/10/23/outside-in-design/
[^fn45]: https://github.com/testdouble/contributing-tests/wiki/Detroit-school-TDD
[^fn46]: https://github.com/testdouble/contributing-tests/wiki/London-school-TDD
[^fn47]: https://en.wikipedia.org/wiki/Extreme_programming#Origins
[^fn48]: http://blog.testdouble.com/posts/2014-01-25-the-failures-of-intro-to-tdd/
[^fn49]: https://www2.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF
[^fn50]: http://coding-is-like-cooking.info/2013/04/the-london-school-of-test-driven-development/
[^fn51]: http://coding-is-like-cooking.info/2013/04/outside-in-development-with-double-loop-tdd/
[^fn52]: http://coding-is-like-cooking.info/2013/05/tell-dont-ask-object-oriented-design/



