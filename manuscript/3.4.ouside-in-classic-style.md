# Classic *outside-in* TDD

It's possible to follow an *outside-in* methodology while we keep the classic TDD cycle. As you might already know, in this approach the design is applied during the refactoring phase, so once that we've developed a rough version of the desired functionality, we start identifying responsibilities and extracting them to different objects with which to compose the system.

In the classic style kata that we've presented in the second part of the book we haven't reached this stage of extraction to collaborators, although we have suggested it several times, and it would be a perfectly feasible thing to do. In fact, it's a recommended exercise.

However, when we talk about *outside-in*, it's frequent that we rather think about more complex projects than the simple problems proposed in the kata. That is to say, the development of a real-world software product as seen by its consumers.

Our to-do list application backend example would fit this category. In the previous chapter we've developed the project using the *mockist* approach, whose main feature is that we start from an acceptance test and we then *enter* each application component, which which develop with the help of a unit test, *mocking* the innermost components that we've not yet developed.

In classic TDD, it's usual to make an *up-front* design to get a rough idea about the necessary components, each of which is then developed and integrated later.

But classic *outside-in* is a little bit different. We would also start with a test at the acceptance level and with the goal of writing the login that makes it pass. In the refactoring phases, we would start extracting objects capable of handling the various identified responsibilities.

![The classicist outside-in cycle](images/print/classic-cycle.jpeg)


For this example we will write a new version of our to-do list application, this time in Ruby. The HTTP *framework* will be Sinatra, and the testing *framework* RSpec.

## Posing the problem

Our starting point will also be an acceptance test as consumers of the API. In a way, we could consider the system as one big *object* with which we communicate via *requests* to its *endpoints*.

It being classic TDD, we won't be using *mocks* unless we need to define an architecture boundary. Obviously, in order to define these kinds of things, we need to have some minimum amount of *up-front* design, so we expect that at some point we'll have use cases, domain entities, and repositories.

In our example, the architecture boundary will be the repository. As we won't define the specific persistence technology yet, we will *mock* it when the time comes. Then we'll see how we can develop an implementation.

I> Other examples of architecture boundaries could be everything that has to do with dates and times, as well as randomness, remote service access, etc. In classic TDD we would use doubles in order to abstract them.

### Kicking off development

My first test proposal is the following:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

This test tries to instantiate a `TodoListApp` object, which is the class in which we will define the `sinatra` application that will respond in the first instance. It requires installing `rspec` if we don't already have it, and it will fail with this error:

```
     NameError:
       uninitialized constant TodoListApp
     # ./spec/todo_list_acceptance_spec.rb:10:in `block (2 levels) in <top (required)>'
```

Which tells us that the class isn't defined anywhere. To make it pass, I will introduce the class in the same file as the test, and when I manage to turn it green, I'll move it to its proper location.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

class TodoListApp

end

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

This is enough to make the test pass, so I will make the most obvious refactoring, which is to move `TodoListApp` to a more adequate place in the project.

A> Remember that, in classic TDD, the refactoring must always be done with all existing tests in green.

The refactoring phase is the stage in which we make design decisions within the classic approach. The controllers belong to the infrastructure layer, so it will be there where I place this class. With that, the test looks like this:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end

```

And we verify that it still passes.

For the next point I need to take a bit of a longer leap and prepare the client that will execute the *requests* against the *endpoints*. Using rack-test, I can create an API client. Since I'm green, I will introduce it and start it. We'll have to install `rack-test` first.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )
    
  end
end
```

This refactoring doesn't change the test result, so we're doing pretty fine.

Now we're going to make sure that we can make a `POST /api/todo` call and that someone answers.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

  end
end
```

Now the test fails, because the application is not able to route the call to any method. It's the moment of implementing something in `TodoListApp` until we manage to make the test pass. This will require introducing and installing `sinatra`.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base

end
```

The truth is that this is enough to make the test pass, since we don't have any expectation about the answer. We need a bit more resolution to force us to implement an action associated to the *endpoint*, so we change the test to be more precise and explicit.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

    expect(@client.last_response.status).to eq(201)
  end
end
```

And this test, which is already a *real test*, shows us that the desired route isn't found:

```
  1) As a user I want to add a new task to the list
     Failure/Error: expect(@client.last_response.status).to eq(201)

       expected: 201
            got: 404
```

With which we can already implement an action that responds.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  post '/api/todo' do
    [201]
  end
end
```

Now we've made the test pass, returning a fixed response, and we now have the assurance that our application is answering to the *endpoint*. It would be time to introduce the call with its *payload*, which will be the description of the new task.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

  RSpec.describe 'As a user I want to' do

    it "add a new task to the list" do
      todo_application = TodoListApp.new

      @client = Rack::Test::Session.new(
        Rack::MockSession.new(
          todo_application
        )
      )

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

The test doesn't add any new information. If we want to move forward with the development we'll have to introduce another test that questions the current implementation, forcing us to make a change in the direction of achieving whatever the test is expected to do.

This *endpoint* is use to create tasks and save them to the list, which means that an effect (*side effect*) is produced in the system. It's a command and doesn't offer any response. In order to test it, we have to check the effect by verifying that there's a created task somewhere.

One possibility is to assume that the task will persist in a `TaskRespository`, which would be a `TodoListApp` collaborator. Repositories are objects in the architecture boundaries and they are based on a specific technology. This assumes a certain level of prior design, but I think that it's an acceptable compromise within the classic approach.

This implies modifying the way in which `TodoListApp` is instantiated so we can pass collaborators to it. Therefore, before anything else, we're going to refactor the test so that the creation of new examples is easier and the test becomes more expressive.

It would end up looking like this:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

After this redesign the test keeps passing. Now, we have to introduce a double of the repository. The minimum that we need to force ourselves to create something is:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

With which we'd have to introduce the definition of the class. By now, we'll do it in the same file.

```ruby

# ...

class TaskRepository
  
end

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

# ...

```

And we pass it to `TodoListApp` as a construction parameter.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

class TaskRepository

end

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    [201]
  end
end
```

En principio estos cambios no afectan al resultado del test.  Así que vamos a mover `TaskRepository` a su sitio, en la capa de dominio.

A continuación, necesitamos definir el efecto que esperamos obtener, lo cual hacemos fijando una expectativa sobre el mensaje que vamos a enviar a task repository.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
  require_relative '../src/domain/task_repository'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do

      expect(@task_repository)
        .to receive(:store)
              .with(instance_of(Task))

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
end
```

El test falla inicialmente porque hemos introducido `Task`, así que lo añadimos ya en su ubicación en la capa de dominio, porque lo necesitaremos enseguida. Al hacerlo, conseguimos que el test falle por el motivo adecuado:

```
1) As a user I want to add a new task to the list
   Failure/Error:
     expect(@task_repository)
       .to receive(:store)
             .with(instance_of(Task))

     (Double TaskRepository).store(an_instance_of(Task))
         expected: 1 time with arguments: (an_instance_of(Task))
         received: 0 times
```

Añadiendo este código en `TodoListApp`, hacemos que pase el test.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new
    @task_repository.store(task)
    [201]
  end
end
```

Ahora necesitamos que un nuevo test nos pida implementar que se instancie una `Task` con los valores deseados. Esto es, queremos que `Task` se inicie con el id `1` y la descripción que le pasamos. Para que el test funcione tenemos que implementar una inicialización en `Task`, que aún no tenemos y alguna forma de comparar objetos `Task`.

A> En Ruby, dos objetos son iguales si tienen el mismo identificador interno de objeto, por lo que la `Task` que creemos en el test como esperada y la que se genere en el código de producción nunca serán iguales.Para verificarlo tenemos varias opciones, aunque una de las más sencillas es introducir un *matcher* en el test que nos permita hacer alguna comparación.

Por otro lado, tenemos que implementar alguna manera de inicializar `Task`. Esta creación puede ser cubierta por el propio test de aceptación. Otro modo de hacerlo sería desarrollando `Task` con un test unitario, pero la verdad es que, de momento, no lo veo necesario.

Al introducir esto en el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Empezará a fallar, por lo que tenemos que implementar la inicialización:

```ruby
class Task
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

El test falla ahora porque en el `TodoListApp` no estamos inicializando bien `Task` ya que no le pasábamos argumentos. Con este pequeño cambio, el test ya pasa.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new 1, 'Write a test that fails'
    @task_repository.store(task)
    [201]
  end
end
```

Se puede decir que aquí estamos usando constantes para satisfacer el test, por lo que tenemos que evolucionar el código y obtener una implementación más flexible. Empezaré con un pequeño refactor que ponga de manifiesto lo que tenemos que lograr a continuación.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task_id = 1
    task_description = 'Write a test that fails'
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Así de simple, tenemos que obtener valores para las variables que acabamos de introducir. Pero ahora mismo no lo estamos comprobando. Es el momento de introducir un *matcher*.

```ruby
RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end
```

Para usarlo, cambiaremos el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

En este momento el test no pasará porque `Task` no expone métodos para acceder a sus propiedades, por lo que añadiremos `attr_reader`:

```ruby
class Task
  attr_reader :description, :id
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

Y con esto el test pasa.

`task_description` viene en la *payload* de la *request*. Puesto que ya está definida en el test ahora mismo podríamos simplemente usarla.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']
    
    task_id = 1
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

En cuanto al id de `task`, necesitaremos un generador de identidades. En nuestro diseño hemos puesto esta responsabilidad en `TaskRepository`, que tendría un método *next_id*. En este caso, tendremos que especificarlo en el test mediante un stub.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Tal y como está el código de producción el test pasa, por lo que no nos dice qué tendríamos que hacer a continuación, así que voy a hacer una pequeña trampa y forzar un fallo del test:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = 0
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Ahora sí tiene sentido introducir la llamada a `next_id`:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = @task_repository.next_id
	
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

## Extracción del caso de uso

Ahora el test ya pasa y podríamos decir que la implementación del *end point* está completa. Sin embargo, tenemos varios problemas:

* `TaskRepository` es un *mock*. Sabemos que interfaz debería tener, pero no tenemos ninguna implementación concreta que pueda funcionar en producción.
* En el controlador hay un montón de lógica de negocio que no debería estar ahí.
* De hecho tenemos objetos de dominio en el controlador: `Task` y `TaskRepostory`.

En resumen, ahora mismo, el controlador está haciendo más cosas de las debidas. Además de su tarea como controlador, que es gestionar la *request* que viene del exterior, está haciendo tareas de la capa de aplicación, coordinando objetos del dominio.

Por tanto, tendríamos que extraer esta parte de la implementación a un nuevo objeto, que será el caso de uso `AddTaskHandler`.

Lo primero que hago es extraer la funcionalidad a un método privado

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private
  
  def add_task(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

Crearé una clase `AddTaskHandler` en la capa de aplicación que encapsule la misma funcionalidad:

```ruby
class AddTaskHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

Y reemplazo la implementación del método por una llamada:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private

  def add_task(task_description)
    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
  end
end
```

Hago un *inline* del método:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
    [201]
  end
end
```

Y refactorizo un poco la solución, moviendo la inicialización al constructor y eliminando alguna variable temporal:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
    @add_task_handler = AddTaskHandler.new @task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    
    @add_task_handler.execute payload['task']
    
    [201]
  end
end
```

El siguiente paso es inyectar la dependencia de `AddTaskHandler` en lugar de la del repositorio. Para ello cambio primero el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)
  @add_task_handler = AddTaskHandler.new @task_repository
  TodoListApp.new @add_task_handler
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

Esto hará que el test falle porque el código de producción sigue esperando al repositorio como dependencia, así que lo cambiamos de este modo:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end
end
```

Y ya tenemos esta parte resuelta.

## Implementando un repositorio

Para arrancar el desarrollo hemos empezado con un `TaskRepository` que es un *mock*. Hemos introducido una clase vacía para poder doblarla, pero esta version *real* no puede recibir mensajes siquiera. Esto ha sido una licencia que me he permitido para no empezar a desarrollar *desde dentro*, creando componentes de la capa de dominio como este repositorio, antes de saber cómo iban a ser usados.

El repositorio es uno de esos objetos que viven en el límite de arquitectura, por así decir, por lo que es bastante aceptable usar un doble. Sin embargo, ahora vamos a tratar de implementar una versión que pueda servirnos para testear.

I> En Ruby no tenemos el concepto de interfaz explícita. Esto no es un obstáculo para tener diversas implementaciones de repositorio que podamos usar en distintos entornos. Así, por ejemplo, para tests unitarios podríamos usar un repositorio en memoria, mientras que para pruebas de aceptación es posible que necesitemos una persistencia más duradera, aunque en este ejemplo sólo necesitaremos la implementación en memoria.

Esto supone un pequeño problema si consideramos que `TaskRepository` es un objeto del dominio, por lo que no queremos tener implementaciones concretas en esta capa. Una forma sencilla de hacerlo es mediante composición: en dominio tendríamos una clase `TaskRepository` que simplemente delegaría en la implementación concreta que inyectemos. Este es el enfoque que vamos a adoptar en este caso, implementando las versiones del repositorio que puedan ser necesarias a partir de un test unitario extrayendo las implementaciones a partir de una genérica.

En esta ocasión empezamos por la capacidad del repositorio de atender un mensaje `next_id`, que debería ser 1 cuando el repositorio está vacío.

```ruby
require 'rspec'

describe 'TaskRepository' do
    it 'should provide empty collection of tasks' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end
end
```

Este método aún no existe y el test fallará. Implementamos una versión inicial.

```ruby
class TaskRepository
  def next_id
    1
  end
end
```

Con el test en verde, vamos a hacer un refactor. `next_id `debería proporcionarnos un número que es el resultado de sumar uno a la cantidad de tareas almacenada. Así que vamos a representar esto en código primero.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end
  def next_id
    @tasks.count + 1
  end
end
```

Lo suyo sería poder añadir elementos y ver si las cosas realmente funcionan, así que vamos a permitir que el repositorio se pueda inicializar con algún contenido.

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end
end
```

Con esto, podemos testear que si iniciamos el repositorio con algún elemento nos devuelve el identificador correcto. Por ejemplo, así:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'
      
      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end
end
```

Esto ya debería ser suficiente para fiarnos de `next_id`. Puede que estés pensando que la generación de identidades con este algoritmo no es precisamente robusta, pero de momento nos llega para el ejemplo. En cualquier caso, podríamos implementar cualquier otra estrategia.

Ahora podríamos usar `next_id` como una manera indirecta de saber si hemos añadido tareas en el repositorio, por lo que ya podemos testear el método `store`.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'

      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end


    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

De momento, el test falla porque no tenemos un método que atienda el mensaje `store`, así que lo añadimos es implementamos la solución más simple:

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Que, por lo demás, es suficiente para hacer pasar el test. El último test se superpone al anterior test de `next_id`, así que lo vamos a quitar.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

Y también podemos quitar la inicialización, ya que no la necesitamos realmente.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Podríamos asegurarnos de que podemos introducir más tareas:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end

    it 'should add several tasks' do
      task_repository = TaskRepository.new

      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

      expect(task_repository.next_id).to eq(4)
    end
end
```

Puesto que queremos separar la tecnología concreta de persistencia, usaré estos tests para extraer un repositorio en memoria. Nos queda así:

```ruby
require_relative '../infrastructure/persistence/memory_storage'

class TaskRepository
  def initialize
    @storage = MemoryStorage.new
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end
end
```

Ahora podemos inyectarlo, para ello modificamos primero el test:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
  before() do
    @task_repository = TaskRepository.new
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(@task_repository.next_id, 'Task Description')
    @task_repository.store Task.new(@task_repository.next_id, 'Another Task')
    @task_repository.store Task.new(@task_repository.next_id, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end
end
```

Y ahora que sólo tenemos un lugar para inicializar el repositorio...

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end
	
  # ...
end
```

El test fallará, pero sólo es necesario hacer este cambio:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

Con el cual tenemos un `TaskRepository` que podremos configurar para usar distintas tecnologías de persistencia y que podríamos empezar a usar en nuestro test de aceptación.

Un cambio posible es este, aunque luego seguiremos evolucionándolo:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end
end
```

## Obtener la lista de las tareas

Una vez que podemos añadir tareas, sería interesante poder acceder a ellas. Nuestro siguiente test de aceptación describiría esta acción, introduciendo una o más tareas y obteniendo una lista con todas las que tengamos.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)
    
    expected_list = [
      '[ ] 1. Write a test that fails'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end
```

Lanzamos este test y vemos que falla, ya que no hay controlador que se encargue de esta ruta. 

```
  1) As a user I want to get a list with all the tasks I've introduced
     Failure/Error: expect(@client.last_response.status).to eq(200)

       expected: 200
            got: 404
````

Así que añadimos uno:

```ruby
  # frozen_string_literal: true

  require 'sinatra'
  require_relative '../../domain/task'
  require_relative '../../domain/task_repository'
  require_relative '../../application/add_task_handler'

  class TodoListApp < Sinatra::Base
    def initialize(add_task_handler)
      @add_task_handler = add_task_handler
    end

    post '/api/todo' do
      payload = JSON.parse request.body.read.to_s

      @add_task_handler.execute payload['task']

      [201]
    end

    get '/api/todo' do
      
    end

  end
```

Esta vez el error es que no se devuelve nada. Podemos arreglarlo fácilmente con esta implementación constante:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = [
      '[ ] 1. Write a test that fails'
    ]
    [200, tasks.to_json]
  end

end
```

Por supuesto, lo suyo sería obtener las tareas del repositorio y generar la respuesta a partir de ahí. Para ello vamos a modificar un poco el test, introduciendo una tarea más y esperando una lista más larga en consecuencia.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.post '/api/todo',
                 { task: 'Write Production code that makes the test pass' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end

```

El test fallará porque no coinciden la lista generada y la esperada. Para hacerlo pasar necesitaremos volver a inyectar el repositorio, de modo que podamos recuperar las tareas guardadas.

De momento, podemos hacerlo en el test, pero antes tendríamos que anular este segundo test para volver a verde y hacer los cambios que necesitamos. Este es el test que quedaría:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    # @client.post '/api/todo',
    #              { task: 'Write Production code that makes the test pass' }.to_json,
    #              { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      # '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end

```

El código de producción:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = [
      '[ ] 1. Write a test that fails'
    ]
    [200, tasks.to_json]
  end
end
```

Ahora nos encontramos un par de problemas:

* No tenemos un método en el repositorio para obtener las tareas
* Tenemos que gestionar la transformación de `Task` en su representación

Personalmente creo que me interesa abordar antes este último. Puestos a devolver una respuesta *hard-coded*, puedo empezar con la transformación desde el objeto `Task` y luego ya continuaré el desarrollo de `TaskRepository`.

De hecho tiene sentido esto como refactor en la situación actual, mientras el test está en verde. Así que vamos a ello:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = {
      1 => Task.new(1, 'Write a test that fails')
  }
    representation = tasks.map do |key, task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, representation.to_json]
  end

end
```

Esta solución es muy sencilla en Ruby y nos permite hacer pasar el test.

Para el siguiente paso necesitaremos implementar el método `find_all` en el repositorio, por lo que tenemos que cambiar de foco y movernos a su test. De momento, empezamos con un test sencillo:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end

  it 'should find all tasks stored' do
      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.find_all.count).to eq(3)
  end
end
```

Para hacerlo pasar necesitamos:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end

  def find_all
    @storage.find_all
  end
end
```

Y como no está implementado en `memory_storage`, pues se lo añadimos:

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end

  def find_all
    @objects
  end
end
```

Esto hace pasar el test, podríamos añadir aquí tests para verificar que las tareas almacenadas son las que hemos guardado. Después de toquetear un poco:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(1, 'Task Description')
    @task_repository.store Task.new(2, 'Another Task')
    @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end

  it 'should find all tasks stored' do
    examples = [
      Task.new(1, 'Task Description'),
      Task.new(2, 'Another Task'),
      Task.new(3, 'Third Task')
    ].each { |task| @task_repository.store task }

    tasks = @task_repository.find_all

    expect(tasks.count).to eq(3)
    expect(tasks[1]).to eq(examples[0])
    expect(tasks[2]).to eq(examples[1])
    expect(tasks[3]).to eq(examples[2])
  end

end
```

Con lo que ya tendríamos lo que necesitamos en el repositorio. Por tanto, podemos introducir su uso en el código de producción después de recuperar el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.post '/api/todo',
                 { task: 'Write Production code that makes the test pass' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end
```

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @task_repository.find_all

    representation = tasks.map do |key, task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, representation.to_json]
  end

end
```

Del mismo modo que hicimos en la historia anterior, ahora sería el momento de extraer la lógica de negocio que contiene el controlador a un caso de uso. Hay que recordar que la condición es que sea el controlador quien decida la representación que necesita.

Seguiremos el mismo procedimiento que antes, extrayendo un método privado con la funcionalidad que vamos a mover al caso de uso. Aquí hemos dado un salto bastante grande de código, implementando la estrategia de transformación mediante un **block**.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = get_tasks_list do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end

end
```

Es ahora cuando creamos el caso de uso:

```ruby
class GetTaskListHandler
  def initialize(task_repository)
    @task_repository = task_repository
  end
  
  def execute

  end
end
```

Y lo usamos dentro del código.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute  do |task|
      "[ ] #{task.id}. #{task.description}"
    end
    tasks = get_tasks_list do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

Con estos cambios el test pasa. La ejecución del caso de uso no tiene ningún efecto en el test, así que vamos a mover el código con los siguientes pasos:

Primero, copiamos el método privado `get_tasks_list` en el `execute` del caso de uso:

```ruby
class GetTaskListHandler
  def initialize(task_repository)
    @task_repository = task_repository
  end

  def execute
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

Ejecutamos el test para asegurarnos de que este cambio no tiene efectos indeseados. Ahora quitamos la llamada al método privado y volvemos a probar:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute  do |task|
      "[ ] #{task.id}. #{task.description}"
    end
    
    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

Con esto ya nos aseguramos de que es el caso de uso el que ejecuta la acción y, por tanto, está haciendo que el test siga pasando.

Sólo nos queda borrar el método privado.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end
end
```

Y ya está. La segunda historia de usuario está implementada. Nos queda todavía un poco de refactor. Vamos a inyectar el caso de uso que acabamos de crear. Por otro lado, dejaremos aún la dependencia de `TaskRepository` porque es previsible que la necesitemos de nuevo.


```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end
end
```

Y aplicamos esto en el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  @get_tasks_list_handler = GetTaskListHandler.new @task_repository
  TodoListApp.new @add_task_handler, @get_tasks_list_handler, @task_repository
end

# ...
```

Ruby es bastante conciso, aún así, voy a hacer algún refactor en el test de aceptación extrayendo a métodos las llamadas a la API:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    api_post_task('Write a test that fails')

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    
    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

## Marcar una tarea completada

La última funcionalidad que vamos a implementar es marcar una tarea como completada. Nos toca seguir los pasos que hemos realizado hasta ahora:

* Añadir un ejemplo al test de aceptación
* Implementar la funcionalidad en el controlador
* Extraerla a un caso de uso

Si necesitamos desarrollar algo nuevo en algún objeto, como ha ocurrido con el `TaskRepository`, lo hacemos con el test de aceptación en verde, de modo que luego podamos usarlo sin problemas en el código.

A> Es la principal diferencia con *outside-in mockista*: en TDD clásico sólo puede estar fallando un test cada vez, para que nos guíe en aquello que tenemos que implementar.

Así que vamos allá. Empecemos con el test de aceptación que, gracias a los refactors anteriores, debería ser fácil de escribir. Aquí está:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  # ...
  
  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[√] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

El principal punto de interés en este test es que vamos a comprobar que ha funcionado recuperando la lista y viendo si ya se representa la tarea como marcada. En muchos aspectos, podríamos considerar que este test sería suficiente para validar toda la funcionalidad de la lista ya que para que para llegar al resultado final todas las demás acciones, que hemos desarrollado con otros tests, funcionan.

Así que vamos a empezar a añadir código de producción hasta lograr que el test pase. Por supuesto, el primer problema es que no hay una ruta ni un controlador asociado.

Con este primer paso conseguimos resolver este problema y el fallo del test ya tiene que ver con el contenido de la respuesta.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  #...

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Este es el error:

```
  1) As a user I want to mark a task completed
     Failure/Error: expect(@client.last_response.body).to eq(expected_list.to_json)

       expected: "[\"[√] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
            got: "[\"[ ] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
```

Y este error ya es que la tarea completada aparece sin marcar, que es exactamente donde queremos estar.

Una forma de solucionarlo es con este código:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.id == 1 ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Y este código hace pasar nuestro test actual. Sin embargo, hace fallar el test anterior de obtener todas las tareas ya que en ese test se asume que no hay ninguna completada.

Por supuesto, lo que necesitamos es que una tarea pueda decir que está completada. Necesitamos añadir algún comportamiento en `Task`, pero también que los tests de aceptación anteriores pasen. Por tanto, vamos a quitar este test temporalmente, revertir este último cambio y trabajar en añadir en `Task` la capacidad de ser marcada como completa.

De momento, me basta con anular la última aserción, que es la que controla el cambio de comportamiento en `Task`:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  #...

  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    api_get_tasks

    expected_list = [
      '[√] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    # expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end

```

Y también tengo que neutralizar el cambio en el código de producción, temporalmente:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Vamos a ver entonces cómo marcar tareas completadas:

```ruby
require 'rspec'

require_relative '../../src/domain/task'

describe 'Task' do

  it 'should be incomplete on creation' do
    task = Task.new 1, 'Task Description'
    expect(task.completed).to be_falsey
  end
end
```

Esto nos basta para introducir la propiedad, iniciarla como `false`, y exponer un método para acceder a ella.

```ruby
class Task
  attr_reader :description, :id, :completed
  def initialize(id, description)

    @id = id
    @description = description
    @completed = false
  end
end
```

Por otra parte, necesitamos poder marcar la tarea como completada:

```ruby
require 'rspec'

require_relative '../../src/domain/task'

describe 'Task' do

  it 'should be incomplete on creation' do
    task = Task.new 1, 'Task Description'
    expect(task.completed).to be_falsey
  end

  it 'should be able to be completed' do
    task = Task.new 1, 'Task Description'
    task.mark_completed
    expect(task.completed).to be_truthy
  end
end
```

Lo cual es bastante sencillo de lograr:

```ruby
class Task
  attr_reader :description, :id, :completed
  def initialize(id, description)

    @id = id
    @description = description
    @completed = false
  end

  def mark_completed
    @completed = true
  end
end
```

Por esta parte ya tenemos lo que necesitamos.

Ahora, vamos a hacer un refactor para usar algunas de estas capacidades. Con este refactor mantenemos el comportamiento actual y estamos preparados para atender al cambio importante:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...
  
  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  # ...
end
```

Así que recuperamos el test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    api_post_task('Write a test that fails')

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end

  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    api_get_tasks

    expected_list = [
      '[√] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

Que falla por el motivo deseado. No deja de tener cierta gracia que nos interese que fallen cosas por una buena razón:

```
  1) As a user I want to mark a task completed
     Failure/Error: expect(@client.last_response.body).to eq(expected_list.to_json)

       expected: "[\"[√] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
            got: "[\"[ ] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
```

Ahora es cuando implementamos una solución tentativa:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...

  patch '/api/todo/:task_id' do | task_id |
    task = Task.new 1, 'Write a test that fails'
    task.mark_completed
    
    @task_repository.store task

    [200]
  end
end
```

Y esto hace pasar el test. Obviamente necesitamos recuperar primero la tarea para poder actualizarla, pero es algo que no tenemos todavía en nuestro `TaskRepository`. Pero como tenemos todos los tests pasando podemos añadir la funcionalidad.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  # ...

  it 'should retrieve a task by id' do
    examples = [
      Task.new(1, 'Task Description'),
      Task.new(2, 'Another Task'),
      Task.new(3, 'Third Task')
    ].each { |task| @task_repository.store task }

    task = @task_repository.retrieve 1

    expect(task).to eq(examples[0])
  end
end
```

Lo implementamos así:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end

  def find_all
    @storage.find_all
  end

  def retrieve(task_id)
    @storage.retrieve task_id
  end
end
```

Junto con:

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end

  def find_all
    @objects
  end

  def retrieve(object_id)
    @objects[object_id]
  end
end
```

Ahora posamos usarlo en nuestra implementación, reemplazando la asignación directa de `task`, que tenemos ahora.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task

    [200]
  end
end
```

Y ya casi estamos. El test de aceptación sigue pasando. Lo único que nos queda es introducir el caso de uso, para lo que seguimos el proceso de refactor que ya conocemos. Primero extraemos la funcionalidad a un método privado.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...
  
  patch '/api/todo/:task_id' do | task_id |
    mark_task_completed task_id

    [200]
  end

  def self.mark_task_completed(task_id)
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task
  end
end
```

Introducimos la nueva clase, que simplemente usa el mismo código que ya está testado.

```ruby
class MarkTaskCompletedHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_id)
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task
  end
end
```

Y ahora, introducimos su uso. Como esta acción es idempotente, podemos hacer esto de modo que probamos si funciona antes de eliminar el código que hemos movido:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...

  patch '/api/todo/:task_id' do | task_id |
    mark_task_completed task_id
    
    @mark_task_completed = MarkTaskCompletedHandler.new @task_repository
    @mark_task_completed.execute task_id
    [200]
  end

  # ...
end
```

Y el test sigue pasando, como era de esperar. Así que podemos eliminar el método extraído antes. Después tendremos que cambiar la construcción para inyectar el caso de uso. Pero vamos por partes:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @mark_task_completed = MarkTaskCompletedHandler.new @task_repository

    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end


  patch '/api/todo/:task_id' do | task_id |
    @mark_task_completed.execute task_id
    
    [200]
  end

end
```

El cambio de la construcción lo vamos a dirigir desde el test, iniciando la aplicación con los servicios que realmente necesita

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  @get_tasks_list_handler = GetTaskListHandler.new @task_repository
  @mark_task_completed = MarkTaskCompletedHandler.new @task_repository

  TodoListApp.new @add_task_handler, @get_tasks_list_handler, @mark_task_completed
end

# ...

```

Los test fallarán estrepitosamente, pero el cambio es fácil de aplicar. Así queda la aplicación:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  
  def initialize(add_task_handler, get_tasks_list_handler, mark_task_completed)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @mark_task_completed = mark_task_completed
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '√' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    @mark_task_completed.execute task_id

    [200]
  end
end
```

## Qué hemos aprendido con esta kata

* Es perfectamente posible aplicar un enfoque *outside-in* con la metodología clásica de TDD.
* La modalidad *outside-in clásica* require que tengamos los tests en verde para introducir el diseño porque lo hacemos en la fase de refactor.
* En algunos momentos podríamos necesitar dobles de test, aunque preferiremos usar implementaciones *fake* o específicas para test (como los repositorios en memoria), o en su caso *stubs* antes que *mocks*.


