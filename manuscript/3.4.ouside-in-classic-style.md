# Classic *outside-in* TDD

It's possible to follow an *outside-in* methodology while we keep the classic TDD cycle. As you might already know, in this approach the design is applied during the refactoring phase, so once that we've developed a rough version of the desired functionality, we start identifying responsibilities and extracting them to different objects with which to compose the system.

In the classic style kata that we've presented in the second part of the book we haven't reached this stage of extraction to collaborators, although we have suggested it several times, and it would be a perfectly feasible thing to do. In fact, it's a recommended exercise.

However, when we talk about *outside-in*, it's frequent that we rather think about more complex projects than the simple problems proposed in the kata. That is to say, the development of a real-world software product as seen by its consumers.

Our to-do list application backend example would fit this category. In the previous chapter we've developed the project using the *mockist* approach, whose main feature is that we start from an acceptance test and we then *enter* each application component, which which develop with the help of a unit test, *mocking* the innermost components that we've not yet developed.

In classic TDD, it's usual to make an *up-front* design to get a rough idea about the necessary components, each of which is then developed and integrated later.

But classic *outside-in* is a little bit different. We would also start with a test at the acceptance level and with the goal of writing the login that makes it pass. In the refactoring phases, we would start extracting objects capable of handling the various identified responsibilities.

![The classicist outside-in cycle](images/print/classic-cycle.jpeg)


For this example we will write a new version of our to-do list application, this time in Ruby. The HTTP *framework* will be Sinatra, and the testing *framework* RSpec.

## Posing the problem

Our starting point will also be an acceptance test as consumers of the API. In a way, we could consider the system as one big *object* with which we communicate via *requests* to its *endpoints*.

It being classic TDD, we won't be using *mocks* unless we need to define an architecture boundary. Obviously, in order to define these kinds of things, we need to have some minimum amount of *up-front* design, so we expect that at some point we'll have use cases, domain entities, and repositories.

In our example, the architecture boundary will be the repository. As we won't define the specific persistence technology yet, we will *mock* it when the time comes. Then we'll see how we can develop an implementation.

I> Other examples of architecture boundaries could be everything that has to do with dates and times, as well as randomness, remote service access, etc. In classic TDD we would use doubles in order to abstract them.

### Kicking off development

My first test proposal is the following:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

This test tries to instantiate a `TodoListApp` object, which is the class in which we will define the `sinatra` application that will respond in the first instance. It requires installing `rspec` if we don't already have it, and it will fail with this error:

```
     NameError:
       uninitialized constant TodoListApp
     # ./spec/todo_list_acceptance_spec.rb:10:in `block (2 levels) in <top (required)>'
```

Which tells us that the class isn't defined anywhere. To make it pass, I will introduce the class in the same file as the test, and when I manage to turn it green, I'll move it to its proper location.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

class TodoListApp

end

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end
```

This is enough to pass the test, so I will make the most obvious refactoring, which is to move `TodoListApp` to a more adequate place in the project.

A> Remember that, in classic TDD, the refactoring must always be done with all existing tests in green.

The refactoring phase is the stage in which we make design decisions within the classic approach. The controllers belong to the infrastructure layer, so it will be there where I place this class. With that, the test looks like this:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    TodoListApp.new
  end
end

```

And we verify that it still passes.

For the next point I need to take a bit of a longer leap and prepare the client that will execute the *requests* against the *endpoints*. Using rack-test, I can create an API client. Since I'm green, I will introduce it and start it. We'll have to install `rack-test` first.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )
    
  end
end
```

This refactoring doesn't change the test result, so we're doing pretty fine.

Now we're going to make sure that we can make a `POST /api/todo` call, and that someone answers.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

  end
end
```

Now the test fails because the application is not able to route the call to any method. It's time to work on the implementation in `TodoListApp` until we manage to make the test pass. This will require introducing and installing `sinatra`.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base

end
```

The truth is that this is enough to pass the test, since we don't have any expectation about the answer. We need a bit more resolution to force us to implement an action associated to the *endpoint*, so we change the test to be more precise and explicit.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

RSpec.describe 'As a user I want to' do

  it "add a new task to the list" do
    todo_application = TodoListApp.new

    @client = Rack::Test::Session.new(
      Rack::MockSession.new(
        todo_application
      )
    )

    @client.post '/api/todo'

    expect(@client.last_response.status).to eq(201)
  end
end
```

And this test, which is already a *real test*, shows us that the desired route isn't found:

```
  1) As a user I want to add a new task to the list
     Failure/Error: expect(@client.last_response.status).to eq(201)

       expected: 201
            got: 404
```

With which we can already implement an action that responds.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  post '/api/todo' do
    [201]
  end
end
```

Now we've made the test pass, returning a fixed response, and we now have the assurance that our application is answering to the *endpoint*. It would be time to introduce the call with its *payload*, which will be the description of the new task.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

  RSpec.describe 'As a user I want to' do

    it "add a new task to the list" do
      todo_application = TodoListApp.new

      @client = Rack::Test::Session.new(
        Rack::MockSession.new(
          todo_application
        )
      )

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

The test doesn't add any new information. If we want to move forward with the development we'll have to introduce another test that questions the current implementation, forcing us to make a change in the direction of achieving whatever the test is expected to do.

This *endpoint* is use to create tasks and save them to the list, which means that an effect (*side effect*) is produced in the system. It's a command and doesn't offer any response. In order to test it, we have to check the effect by verifying that there's a created task somewhere.

One possibility is to assume that the task will persist in a `TaskRespository`, which would be a `TodoListApp` collaborator. Repositories are objects in the architecture boundaries and they are based on a specific technology. This assumes a certain level of prior design, but I think that it's an acceptable compromise within the classic approach.

This implies modifying the way in which `TodoListApp` is instantiated so we can pass collaborators to it. Therefore, before anything else, we're going to refactor the test so that the creation of new examples is easier and the test becomes more expressive.

It would end up looking like this:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

After this redesign the test keeps passing. Now, we have to introduce a double of the repository. The minimum that we need to force ourselves to create something is:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

With which we'd have to introduce the definition of the class. By now, we'll do it in the same file.

```ruby

# ...

class TaskRepository
  
end

def todo_application
  double(TaskRepository)

  TodoListApp.new
end

# ...

```

And we pass it to `TodoListApp` as a construction parameter.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'

class TaskRepository

end

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do
      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
```

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    [201]
  end
end
```

In principle, these changes don't affect the test result. So, let's move `TaskRepository` to where it belongs, the domain layer.

Then, we need to define the effect that we expect to obtain, which we do by setting an expectation about the message that we're going to send to the task repository.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

  ENV['APP_ENV'] = 'test'

  require 'rspec'
  require 'rack/test'

  require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
  require_relative '../src/domain/task_repository'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

    before do
      @client = build_client
    end

    it "add a new task to the list" do

      expect(@task_repository)
        .to receive(:store)
              .with(instance_of(Task))

      @client.post '/api/todo',
                   {task: 'Write a test that fails'}.to_json,
                   { 'CONTENT_TYPE' => 'application/json' }

      expect(@client.last_response.status).to eq(201)
    end
  end
end
```

The test initially fails because we have introduced `Task`, so we add it now to its place in the domain layer: we'll need it soon. By doing so, we get the test to fail for the right reason.

```
1) As a user I want to add a new task to the list
   Failure/Error:
     expect(@task_repository)
       .to receive(:store)
             .with(instance_of(Task))

     (Double TaskRepository).store(an_instance_of(Task))
         expected: 1 time with arguments: (an_instance_of(Task))
         received: 0 times
```

By adding this code to `TodoListApp` we get the test to pass.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new
    @task_repository.store(task)
    [201]
  end
end
```

Now we need a new test to ask us to implement the instantiation of a `Task` with the desired values. That is, we want `Task` to be initialized with the id `1` and our specified description. In order for the test to work, we have to implement a initialization in `Task`, which we don't have yet, and some way to compare `Task` objects.

A> In Ruby, two objects are the same if they have the same internal object identifier, so the expected `Task` that we generate in the test and the one that is generated in the production code will never be the same. We have several options to verify it, although one of the simplest is to introduce a *matcher* in the test that allows us to make comparisons.

On the other hand, we have to implement a way of initializing `Task`. This creation may be covered by the acceptance test itself. Another way to do it would be to develop `Task` with a unit test, but to be honest I don't think it's necessary at the time.

When we insert this in the test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

It will start to fail, so we have to implement the initialization.

```ruby
class Task
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

Now the test fails because we weren't initializing `Task` properly in `TodoListApp`, as we weren't passing it any arguments. With this small change, the test starts passing.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task = Task.new 1, 'Write a test that fails'
    @task_repository.store(task)
    [201]
  end
end
```

We could say that we're using constants here in order to satisfy the test, so we have to evolve the code and obtain a more flexible implementation. I'll start with a small refactor that reveals what we have to achieve next.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    task_id = 1
    task_description = 'Write a test that fails'
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

It's that simple, we have to obtain values for the variables that we've just introduced. But right now we aren't checking. It's time to introduce a *matcher*.

```ruby
RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end
```

To use it, we'll change the test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

At this moment the test won't pass because `Task` doesn't expose any methods that allow us to access its attributes, so we'll add `attr_reader`:

```ruby
class Task
  attr_reader :description, :id
  def initialize(id, description)

    @id = id
    @description = description
  end
end
```

And with this, the test passes.

`task_description` comes in the *request* *payload*. Since it's already defined in the test, we could simply use it right now.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']
    
    task_id = 1
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

As for the `task` id, we'll need an identity generator. In our design, we have placed this responsibility on `TaskRepository`, which would have a *next_id* method. In this case, we'll have to specify it in the test by using a stub.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)

  TodoListApp.new @task_repository
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(instance_of(Task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

With the production code just as it is now, the test passes, so it doesn't tell us what we would have to do next. So, I'm going to cheat a little and force a test failure:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = 0
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

Now, introducing the call to `next_id` finally makes sense:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    task_id = @task_repository.next_id
	
    task = Task.new task_id, task_description
    @task_repository.store(task)
    [201]
  end
end
```

## Extraction of the use case

Now the test is passing and we could say that the *endpoint* implementation is complete. However, we face many problems:

* `TaskRepository` is a *mock*. We know which interface it should have, but we don't have any concrete implementation that can work in production.
* There's a lot of business logic in the controller that shouldn't be there.
* In fact, we have domain objects in the controller: `Task` and `TaskRepository`.

Summarizing, right now, the controller is doing more things that it should. On top of its job as a controller, which is handling the *requests* that arrive from the outside, it's performing tasks that belong to the application layer, coordinating domain objects.

Therefore, we would have to extract this part of the implementation to a new object, which will be the use case `AddTaskHandler`.

The first thing that I do is extract the functionality to a private method.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private
  
  def add_task(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

I will create an `AddTaskHandler` class in the application layer that encapsulates the same functionality:

```ruby
class AddTaskHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_description)
    task_id = @task_repository.next_id
    task = Task.new task_id, task_description
    @task_repository.store(task)
  end
end
```

And I replace the method implementation for a call:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    add_task(task_description)
    [201]
  end

  private

  def add_task(task_description)
    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
  end
end
```

I make a method *inline*:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    task_description = payload['task']

    @add_task_handler = AddTaskHandler.new @task_repository
    @add_task_handler.execute task_description
    [201]
  end
end
```

And I refactor the solution a bit, moving the initialization to the constructor and removing some temporal variables:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(task_repository)
    @task_repository = task_repository
    @add_task_handler = AddTaskHandler.new @task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s
    
    @add_task_handler.execute payload['task']
    
    [201]
  end
end
```

The next step is to inject the `AddTaskHandler` dependency in place of the repository one. To do that, I first change the test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

ENV['APP_ENV'] = 'test'

require 'rspec'
require 'rack/test'
require 'json'

require_relative '../src/infrastructure/entry_point/todo_list_app.rb'
require_relative '../src/domain/task_repository'
require_relative '../src/domain/task'

def todo_application
  @task_repository = double(TaskRepository)
  @add_task_handler = AddTaskHandler.new @task_repository
  TodoListApp.new @add_task_handler
end

def build_client
  Rack::Test::Session.new(
    Rack::MockSession.new(
      todo_application
    )
  )
end

RSpec::Matchers.define :has_same_data do |expected|
  match do |actual|
    expected.id == actual.id && expected.description == actual.description
  end
end


RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    task = Task.new 1, 'Write a test that fails'

    allow(@task_repository)
      .to receive(:next_id)
            .and_return(1)

    expect(@task_repository)
      .to receive(:store)
            .with(has_same_data(task))

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
  end
end
```

This will cause the test to fail because the production code is still expecting the repository as a dependency, so we change it in the following way:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end
end
```

And we may now consider this part solved.

## Implementing a repository

To kick off the design we have started with a *mock* `TaskRepository`. We have introduced an empty class to be able to double it, but this *real* version can't even receive messages. This is a liberty I've taken in order to avoid having to start developing *from the inside*, creating domain layer components -like this repository- before knowing how they were going to be used.

The repository is one of those objects that live in the architecture boundary, so to speak, so using a double is acceptable enough. However, now we're going to try to implement a version that can be used for testing.

I> We don't have an explicit interface concept in Ruby. This isn't an obstacle to having diverse repository implementations that we can use in different environments. Thus, for example, we could use an in-memory repository for unit tests, while for acceptance tests we might need a more durable persistence. Although in this example we'll only need the in-memory implementation.

This poses a little problem if we consider `TaskRepository` to be a domain object, so we don't want to have concrete implementations of this layer. A simple way to do it is by using composition: we would have a `TaskRepository` class in domain that would simply delegate to the concrete implementation that we injected. This is the approach that we're going to adopt in this case, implementing the versions of the repository that may be needed, starting from a unit test extracting the implementations from a generic one.

This time, we start by the repositories' ability to attend a `next_id` message, which should be one when the repository is empty.

```ruby
require 'rspec'

describe 'TaskRepository' do
    it 'should provide empty collection of tasks' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end
end
```

This method doesn't exist yet and the test will fail. We implement a first version.

```ruby
class TaskRepository
  def next_id
    1
  end
end
```

With a green test, we're going to perform a refactoring. `next_id` should provide us with a number: the result of adding one to the amount of stored tasks. So we're going to represent this using code first.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end
  def next_id
    @tasks.count + 1
  end
end
```

It would be nice to be able to add elements and check if things are really working, so we're going to allow the repository to be initialized with some contents.

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end
end
```

With this, we can test that if we initialize the repository with some element, it returns the correct identifier. For example, like this:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'
      
      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end
end
```

This should be enough for us to trust `next_id`. You might be thinking that generating identities using this algorithm isn't precisely robust, but it's sufficient and satisfies our example for now. In any case, we could implement any other strategy.

Now we could use `next_id` as an indirect way of knowing if we've added tasks to the repository, so we can already test the `store` method.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should have next_id = n+1 if contains n tasks' do
      task = Task.new 1, 'Description'

      task_repository = TaskRepository.new task

      expect(task_repository.next_id).to eq(2)
    end


    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

For now, the test fails because we don't have a method that handles the `store` message, so we add it and implement the simplest solution:

```ruby
class TaskRepository
  def initialize(*tasks)
    tasks.empty? ? @tasks = {} : (@tasks = Hash[tasks.collect { |task| [task.id, task] }] unless tasks.empty?)
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

Which, moreover, is enough to get the test to pass. The last test overlaps the previous `next_id` test, so we're going to remove it.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end
end
```

And we can also remove the initialization, since we don't really need it.

```ruby
class TaskRepository
  def initialize
    @tasks = {}
  end

  def next_id
    @tasks.count + 1
  end

  def store(task)
    @tasks.store task.id, task
  end
end
```

We could make sure that we're able to introduce more tasks:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
    it 'first identity should be 1' do
      task_repository = TaskRepository.new

      result = task_repository.next_id

      expect(result).to eq(1)
    end

    it 'should add a Task' do
      task_repository = TaskRepository.new

      task = Task.new 1, 'Task Description'

      task_repository.store task

      expect(task_repository.next_id).to eq(2)
    end

    it 'should add several tasks' do
      task_repository = TaskRepository.new

      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

      expect(task_repository.next_id).to eq(4)
    end
end
```

Since we want to separate the specific persistence technology, I will use these tests to extract an in-memory repository. It ends up looking like this:

```ruby
require_relative '../infrastructure/persistence/memory_storage'

class TaskRepository
  def initialize
    @storage = MemoryStorage.new
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end
end
```

Now we can inject it, to do it we modify the test first:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'

describe 'TaskRepository' do
  before() do
    @task_repository = TaskRepository.new
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(@task_repository.next_id, 'Task Description')
    @task_repository.store Task.new(@task_repository.next_id, 'Another Task')
    @task_repository.store Task.new(@task_repository.next_id, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end
end
```

And now that we only have one place to initialize the repository...

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end
	
  # ...
end
```

The test will fail, but now we only need to make this change:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end
end
```

With which we have a `TaskRepository` that we will be able to configure so it uses different persistence technologies, and that we could start using in our acceptance test.

A possible change is this one, although we'll continue to evolve it later:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end
end
```

## Obtaining the to-do list

Once we're able to add tasks, it would be interesting to also be able to access them. Our next acceptance test would describe this action, introducing one or more tasks and obtaining a list with all that we have.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)
    
    expected_list = [
      '[ ] 1. Write a test that fails'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end
```

We run this test and see that it fails, since there isn't any controller handling this route.

```
  1) As a user I want to get a list with all the tasks I've introduced
     Failure/Error: expect(@client.last_response.status).to eq(200)

       expected: 200
            got: 404
````

So we add one:

```ruby
  # frozen_string_literal: true

  require 'sinatra'
  require_relative '../../domain/task'
  require_relative '../../domain/task_repository'
  require_relative '../../application/add_task_handler'

  class TodoListApp < Sinatra::Base
    def initialize(add_task_handler)
      @add_task_handler = add_task_handler
    end

    post '/api/todo' do
      payload = JSON.parse request.body.read.to_s

      @add_task_handler.execute payload['task']

      [201]
    end

    get '/api/todo' do
      
    end

  end
```

This time the error is that it doesn't return anything. We can easily fix it with this constant implementation:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler)
    @add_task_handler = add_task_handler
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = [
      '[ ] 1. Write a test that fails'
    ]
    [200, tasks.to_json]
  end

end
```

Of course, it would be best to recover the tasks from the repository and generate the response from there. To do it we're going to change the test a bit, introducing an extra task and expecting a longer list as a result.


```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.post '/api/todo',
                 { task: 'Write Production code that makes the test pass' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end

```

The test will fail as the generated and expected lists don't match. To get it to pass we would need to inject the repository again, so that we can recover the saved tasks.

For now we can do it in the test, but first we would have to cancel this second test to go back to green, and then make the changes that we needed. This is the test that would remain:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    # @client.post '/api/todo',
    #              { task: 'Write Production code that makes the test pass' }.to_json,
    #              { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      # '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end

```

The production code:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = [
      '[ ] 1. Write a test that fails'
    ]
    [200, tasks.to_json]
  end
end
```

Now we run into a couple of problems:

* We don't have a method in the repository to obtain the tasks
* We have to handle the transformation of `Task`into its representation

Personally, I like I'm interested in tackling the latter first. Set to return a *hard-coded* answer, I can start with the transformation from the `Task` object, and then I'll resume the development of `TaskRepository`.

In fact, this makes sense as a refactoring in the current situation, while the test is still green. So we get to it:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = {
      1 => Task.new(1, 'Write a test that fails')
  }
    representation = tasks.map do |key, task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, representation.to_json]
  end

end
```

This solution is very simple in Ruby and lets us pass the test.

For the next step we'll need to implement the `find_all` method in the repository, so we have to change focus and move to its test. For now, we start with a simple test:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end

  it 'should find all tasks stored' do
      @task_repository.store Task.new(1, 'Task Description')
      @task_repository.store Task.new(2, 'Another Task')
      @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.find_all.count).to eq(3)
  end
end
```

To make it pass we need:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end

  def find_all
    @storage.find_all
  end
end
```

And as it's not implemented in `memort_storage`, we add it to it:

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end

  def find_all
    @objects
  end
end
```

This passes the test. We could add some tests here to verify that the stored tasks are, in fact, the ones that we have saved. After tinkering a bit:

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  it 'first identity should be 1' do

    result = @task_repository.next_id

    expect(result).to eq(1)
  end

  it 'should add a Task' do
    task = Task.new 1, 'Task Description'

    @task_repository.store task

    expect(@task_repository.next_id).to eq(2)
  end

  it 'should add several tasks' do

    @task_repository.store Task.new(1, 'Task Description')
    @task_repository.store Task.new(2, 'Another Task')
    @task_repository.store Task.new(3, 'Third Task')

    expect(@task_repository.next_id).to eq(4)
  end

  it 'should find all tasks stored' do
    examples = [
      Task.new(1, 'Task Description'),
      Task.new(2, 'Another Task'),
      Task.new(3, 'Third Task')
    ].each { |task| @task_repository.store task }

    tasks = @task_repository.find_all

    expect(tasks.count).to eq(3)
    expect(tasks[1]).to eq(examples[0])
    expect(tasks[2]).to eq(examples[1])
    expect(tasks[3]).to eq(examples[2])
  end

end
```

With which we'd have everything we need in the repository. Therefore, we can introduce its use in the production code after recovering the test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    @client.post '/api/todo',
                 { task: 'Write a test that fails' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }

    @client.post '/api/todo',
                 { task: 'Write Production code that makes the test pass' }.to_json,
                 { 'CONTENT_TYPE' => 'application/json' }


    @client.get '/api/todo'

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    expect(@client.last_response.body).to eq(expected_list.to_json)

  end
end
```

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @task_repository.find_all

    representation = tasks.map do |key, task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, representation.to_json]
  end

end
```

Similarly to how we did in the previous story, now would be the moment to extract the business logic that the controller contains to a use case. We have to remember that the rule is to let the controller be the one who decides which representation it needs.

We'll follow the same procedure as before, extracting a private method with the functionality that we're going to move to the use case. Here we've taken quite a long leap of code, implementing the transformation strategy by using a **block**.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = get_tasks_list do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end

end
```

It's now when we create the use case:

```ruby
class GetTaskListHandler
  def initialize(task_repository)
    @task_repository = task_repository
  end
  
  def execute

  end
end
```

And we use it within the code.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute  do |task|
      "[ ] #{task.id}. #{task.description}"
    end
    tasks = get_tasks_list do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

With these changes the test passes. Executing the use case doesn't have any effect on the test, so we're going to move the code with the following steps:

First, we copy the private method `get_tasks_list` in the `execute` of the use case:

```ruby
class GetTaskListHandler
  def initialize(task_repository)
    @task_repository = task_repository
  end

  def execute
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

We run the test to make sure that this change doesn't carry any undesired effects. Now we remove the call to the private method and we try again:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute  do |task|
      "[ ] #{task.id}. #{task.description}"
    end
    
    [200, tasks.to_json]
  end

  private

  def get_tasks_list
    tasks = @task_repository.find_all
    return tasks unless block_given?

    representations = []
    tasks.each do |key, task|
      representations << yield(task)
    end

    representations
  end
end
```

With this we make sure that it's the use case the one that is executing the action, and therefore, is causing the test to keep passing.

Now it's only a matter of deleting the private method.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, task_repository)
    @add_task_handler = add_task_handler
    @task_repository = task_repository
    @get_tasks_list_handler = GetTaskListHandler.new task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end
end
```

And that's it. The second user story is implemented. We still have a bit of refactoring left. We're going to inject the use case that we've just created. Also, we're still going to leave the `TaskRepository` dependency, as it's foreseeable that we'll need it again.


```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../domain/task'
require_relative '../../domain/task_repository'
require_relative '../../application/add_task_handler'
require_relative '../../application/get_task_list_handler'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end
end
```

And we apply this in the test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  @get_tasks_list_handler = GetTaskListHandler.new @task_repository
  TodoListApp.new @add_task_handler, @get_tasks_list_handler, @task_repository
end

# ...
```

Ruby is pretty concise, but even so, I'm going to do some refactoring in the acceptance test extracting the API calls to methods:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    api_post_task('Write a test that fails')

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]
    
    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

## Mark a task as completed

The last piece of functionality that we're going to implement is to mark a task as completed. We have to perform the steps that we've been following until now:

* Add and example to the acceptance test
* Implement the functionality in the controller
* Extract it to a use case

If we need to develop anything new in an object, like it happened with `TaskRepository`, we do it with a green acceptance test, so that we can later use it in the code without problems.

A> It's the main difference with *mockist outside-in*: in classic TDD only one test can be allowed to fail at a time, so that it guides what we have to implement.

So let's go. Let's start with the acceptance test, which thanks to the previous refactorings should be easy to write. Here it is:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  # ...
  
  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

The main point of interest in this test is that we're going to check that it has worked by recovering the list and seeing if the task is already being represented as marked. In  many respects, we could consider that this test would be sufficient to validate all of the list functionality, since in order to reach the final result, all of the other actions -that we've developed with other tests- work.

So we're going to start adding production production code until we get the test to pass. Of course, the first problem is that there's neither a route nor an associated controller.

With this first step we solve this problem, and the test failure now has to do with the content of the response.

```ruby
# frozen_string_literal: true

require 'sinatra'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  #...

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

This is the error:

```
  1) As a user I want to mark a task completed
     Failure/Error: expect(@client.last_response.body).to eq(expected_list.to_json)

       expected: "[\"[] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
            got: "[\"[ ] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
```

This means that the completed task appears unmarked, which is exactly where we want to be.

A way of solving it is using this code:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.id == 1 ? '' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

And this code makes our current test pass. However, it makes the previous test fail -the one that retrieves all of the tasks- as in that test we assume that none of them are completed.

Of course, what we need is that a task can say that it's completed. We need to add some behavior to `Task`, but also keep the previous acceptance tests passing. Therefore, we're going to temporarily remove this test, revert this last change, and work to add the capacity of being marked as completed to `Task`.

For now, it's enough to remove the last assertion, which is the one that controls the behavior change in `Task`:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  #...

  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    api_get_tasks

    expected_list = [
      '[] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    # expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end

```

And I also have to neutralize the change in the production code, temporarily:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[ ] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    [200]
  end
end
```

Let's see, then, how to mark completed tasks:

```ruby
require 'rspec'

require_relative '../../src/domain/task'

describe 'Task' do

  it 'should be incomplete on creation' do
    task = Task.new 1, 'Task Description'
    expect(task.completed).to be_falsey
  end
end
```

This suffices to introduce the property, initialize it as `false`, and expose a method to access it.

```ruby
class Task
  attr_reader :description, :id, :completed
  def initialize(id, description)

    @id = id
    @description = description
    @completed = false
  end
end
```

On the other hand, we need to be able to mark the task as completed:

```ruby
require 'rspec'

require_relative '../../src/domain/task'

describe 'Task' do

  it 'should be incomplete on creation' do
    task = Task.new 1, 'Task Description'
    expect(task.completed).to be_falsey
  end

  it 'should be able to be completed' do
    task = Task.new 1, 'Task Description'
    task.mark_completed
    expect(task.completed).to be_truthy
  end
end
```

Which is pretty easy to achieve:

```ruby
class Task
  attr_reader :description, :id, :completed
  def initialize(id, description)

    @id = id
    @description = description
    @completed = false
  end

  def mark_completed
    @completed = true
  end
end
```

For this part, we got everything we need.

Now, we're going to perform a refactoring in order to use some of these capabilities. With this refactoring we keep the current behavior and get ready to handle the important change:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...
  
  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  # ...
end
```

So we recover the test:

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def api_post_task(description)
  @client.post '/api/todo',
               { task: description }.to_json,
               { 'CONTENT_TYPE' => 'application/json' }
end

def api_get_tasks
  @client.get '/api/todo'
end

RSpec.describe 'As a user I want to' do

  before do
    @client = build_client
  end

  it "add a new task to the list" do

    api_post_task('Write a test that fails')

    expect(@client.last_response.status).to eq(201)
    expect(@task_repository.next_id).to eq(2)
  end

  it 'get a list with all the tasks I\'ve introduced' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    api_get_tasks

    expect(@client.last_response.status).to eq(200)

    expected_list = [
      '[ ] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end

  it 'mark a task completed' do
    api_post_task('Write a test that fails')
    api_post_task('Write Production code that makes the test pass')

    @client.patch '/api/todo/1',
                  { completed: true }.to_json,
                  { 'CONTENT_TYPE' => 'application/json' }

    expect(@client.last_response.status).to eq(200)

    api_get_tasks

    expected_list = [
      '[] 1. Write a test that fails',
      '[ ] 2. Write Production code that makes the test pass'
    ]

    expect(@client.last_response.body).to eq(expected_list.to_json)
  end
end
```

Which fails for the desired reason. The fact that we're interested in things failing for good reasons never stops being kind of funny:

```
  1) As a user I want to mark a task completed
     Failure/Error: expect(@client.last_response.body).to eq(expected_list.to_json)

       expected: "[\"[] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
            got: "[\"[ ] 1. Write a test that fails\",\"[ ] 2. Write Production code that makes the test pass\"]"
```

Now is when we implement a tentative solution:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...

  patch '/api/todo/:task_id' do | task_id |
    task = Task.new 1, 'Write a test that fails'
    task.mark_completed
    
    @task_repository.store task

    [200]
  end
end
```

And this passes the test. Obviously we need to recover the task first so we can update it, but it's something that we don't have in our `TaskRepository` yet. But since all our test are passing, we can add the functionality.

```ruby
require 'rspec'

require_relative '../../src/domain/task_repository'
require_relative '../../src/domain/task'
require_relative '../../src/infrastructure/persistence/memory_storage'

describe 'TaskRepository' do
  before() do
    memory_storage = MemoryStorage.new
    @task_repository = TaskRepository.new memory_storage
  end

  # ...

  it 'should retrieve a task by id' do
    examples = [
      Task.new(1, 'Task Description'),
      Task.new(2, 'Another Task'),
      Task.new(3, 'Third Task')
    ].each { |task| @task_repository.store task }

    task = @task_repository.retrieve 1

    expect(task).to eq(examples[0])
  end
end
```

We implement it like this:

```ruby
class TaskRepository
  def initialize(storage)
    @storage = storage
  end

  def next_id
    @storage.next_id
  end

  def store(task)
    @storage.store task
  end

  def find_all
    @storage.find_all
  end

  def retrieve(task_id)
    @storage.retrieve task_id
  end
end
```

Together with:

```ruby
class MemoryStorage
  def initialize
    @objects = {}
  end

  def next_id
    @objects.count + 1
  end

  def store(object)
    @objects.store object.id, object
  end

  def find_all
    @objects
  end

  def retrieve(object_id)
    @objects[object_id]
  end
end
```

Now we can use it in our implementation, replacing the direct assignation of `task` that we had until now.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task

    [200]
  end
end
```

And we're almost done! The acceptance test is still passing. The only thing that remains is to introduce the use case, for which we follow the refactoring process that we already know well. First we extract the functionality to a private method.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...
  
  patch '/api/todo/:task_id' do | task_id |
    mark_task_completed task_id

    [200]
  end

  def self.mark_task_completed(task_id)
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task
  end
end
```

We introduce the new class, which simply uses the same code that's already tested.

```ruby
class MarkTaskCompletedHandler
  def initialize(task_repository)

    @task_repository = task_repository
  end

  def execute(task_id)
    task = @task_repository.retrieve task_id
    task.mark_completed

    @task_repository.store task
  end
end
```

And now, we introduce its use. Since this action is idempotent, we can do this in such a way that we make sure that it works before deleting the code that we've just moved.

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @task_repository = task_repository
  end

  # ...

  patch '/api/todo/:task_id' do | task_id |
    mark_task_completed task_id
    
    @mark_task_completed = MarkTaskCompletedHandler.new @task_repository
    @mark_task_completed.execute task_id
    [200]
  end

  # ...
end
```

And the continues to pass as expected. So we can delete the previously extracted method. Later we'll have to change the construction so as to inject the use case. But let's do it bit by bit:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  def initialize(add_task_handler, get_tasks_list_handler, task_repository)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @mark_task_completed = MarkTaskCompletedHandler.new @task_repository

    @task_repository = task_repository
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end


  patch '/api/todo/:task_id' do | task_id |
    @mark_task_completed.execute task_id
    
    [200]
  end

end
```

We're going to direct the change in the construction from the test, starting the application with the services that it really needs.

```ruby
# todo_list_acceptance_spec.rb
# frozen_string_literal: true

# ...

def todo_application
  @task_repository = TaskRepository.new MemoryStorage.new
  @add_task_handler = AddTaskHandler.new @task_repository
  @get_tasks_list_handler = GetTaskListHandler.new @task_repository
  @mark_task_completed = MarkTaskCompletedHandler.new @task_repository

  TodoListApp.new @add_task_handler, @get_tasks_list_handler, @mark_task_completed
end

# ...

```

The tests will fail disastrously, but the change is easy to apply. This is how the application will look like:

```ruby
# frozen_string_literal: true

require 'sinatra'
require_relative '../../../src/domain/task'

class TodoListApp < Sinatra::Base
  
  def initialize(add_task_handler, get_tasks_list_handler, mark_task_completed)
    @add_task_handler = add_task_handler
    @get_tasks_list_handler = get_tasks_list_handler
    @mark_task_completed = mark_task_completed
  end

  post '/api/todo' do
    payload = JSON.parse request.body.read.to_s

    @add_task_handler.execute payload['task']

    [201]
  end

  get '/api/todo' do
    tasks = @get_tasks_list_handler.execute do |task|
      "[#{task.completed ? '' : ' '}] #{task.id}. #{task.description}"
    end

    [200, tasks.to_json]
  end

  patch '/api/todo/:task_id' do | task_id |
    @mark_task_completed.execute task_id

    [200]
  end
end
```

## What have we learned in this kata

* It's perfectly possible to apply an *outside-in* approach with TDD's classic methodology.
* The *classic outside-in* methodology requires all tests to be green to introduce the design, because we do it in the refactoring phase.
* At some moments we might need test doubles, although we'll prefer to use *fake* or test-specific implementations (such as in-memory repositories), or, where appropriate, *stubs* before *mocks*.


