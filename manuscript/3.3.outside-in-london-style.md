# Mockist *outside-in*

Outside-in TDD, also known as *mockist* or *London school*, is a TDD approach that seeks to implement software *features* starting from an acceptance test and advancing towards the interior of the software.

Instead of designing the system in the refactoring phase, as the classic approach would, the *outside-in* approach does it during the *red* phase, that is, when the acceptance test is still failing. Development will end when the acceptance test finally passes. As the need to implement new components arises, they're developed in a classic style. 

Thus, for example, in the development of an API, first an acceptance test against the API would be written, as if it were another of its consumers. The next step would be to design and test the controller, then the use case, and then the services and entities handled by that use case, until reaching the application domain. In all cases we would *mock* the dependencies, so that we'd be testing the messages between the application's objects.

The methodology to do this is based on two cycles:

* **Acceptance test cycle**. It's a test that described the complete feature at the *end to end* level, using real implementation of the system's components, except for those that define its limits. At this level, the test failures serve as a guide to know what we have to develop next.
* **Unit test cycle**. Once we have a failure in the acceptance test that tells us what to develop, we'll take a step towards the inside of the system and use unit test to develop the corresponding component, *mocking* those collaborators or dependencies that it may need.  When we're finished, we return to the acceptance test cycle in order to find our next objective.


![The mockist outside-in cycle](images/print/outside-in-cycle.jpeg)


## Development

This time we'll develop the kata in PHP, using [this repository](https://github.com/franiglesias/tb) since it comes with PHP and Symfony already installed, which provides us with an HTTP *framework* with which to start developing.

`https://github.com/franiglesias/tb`

I> In the PHP examples I will omit both the `<?php` opening tag and the `declare(strict_types=1);` declaration, so as to save space.

We already have a basic test in the repository that we'll use as a starting point:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class TodoListAcceptanceTest extends WebTestCase
{

    protected function setUp(): void
    {
        $this->resetRepositoryData();
    }

    protected function tearDown(): void
    {
        $this->resetRepositoryData();
    }

    private function resetRepositoryData(): void
    {
        if (file_exists('repository.data')) {
            unlink('repository.data');
        }
    }
}
```

I> The `setUp` and `tearDown` methods handle a data file that's necessary for the implementation of a very simple persistence system (`FileStorageEngine`), which we'll need to implement the complete feature. We don't need to take them into account in the tests.

## Designing the acceptance test

We need an acceptance test that describes how the application has to work. We have an example for that. These are the tasks that we're going to put in our list:

```
1. Write a test that fails (done)
2. Write Production code that makes the test pass
3. Refactor if there is opportunity
```

Therefore, the steps that the test has to execute are to annotate the three tasks, mark the first one as done, and be able to show us the list. These operations are:

```
POST /api/todo
payload: [task:Write a test that fails]

POST /api/todo
payload: [task:Write Production code that makes the test pass]

POST /api/todo
payload: [task:Refactor if there is opportunity]

PATCH /api/todo/1
payload: [done:true]

GET /api/todo
Response:
[√] 1. Write a test that fails
[ ] 2. Write Production code that makes the test pass
[ ] 3. Refactor if there is opportunity
```

For the sake of simplicity, the response will be a representation of each task in one line of text with the above format.

### Starting at the end: what will the expected result be?

To start designing our test we begin at the end, that is, from the call to recover the task list that represents the result that we expect to achieve at the end of the process. From there, we will reproduce the previous steps that would have been needed to reach that state.

```php
    /** @test */
    public function shouldAllowAddingTaskCompleteAndRetrieveTheList(): void
    {
        $expectedList = [
            '[√] 1. Write a test that fails',
            '[ ] 2. Write Production code that makes the test pass',
            '[ ] 3. Refactor if there is opportunity',
        ];

        $client = self::createClient();
        $client->request('GET', '/api/todo');
        $response = $client->getResponse();
        $list = json_decode($response->getContents(), true);
        
        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        self::assertEquals($list, $expectedList);
    }
```

To reach this point, we would have needed to make one petition to the API for each of the tasks, and one more to mark a task as completed. Thereby, the complete test would look like this:

```php
    /** @test */
    public function shouldAllowAddingTaskCompleteAndRetrieveTheList(): void
    {
        $expectedList = [
            '[√] 1. Write a test that fails',
            '[ ] 2. Write Production code that makes the test pass',
            '[ ] 3. Refactor if there is opportunity',
        ];

        $client = self::createClient();

        $taskDescription = 'Write a test that fails';
        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription])
        );

        $taskDescription = 'Write Production code that makes the test pass';
        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription])
        );

        $taskDescription = 'Refactor if there is opportunity';
        $client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => $taskDescription])
        );

        $taskId = 1;
        $client->request(
            'PATCH',
            '/api/todo/'.$taskId,
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['done' => true])
        );

        $client->request('GET', '/api/todo');
        $response = $client->getResponse();
        $list = json_decode($response->getContent(), true);

        self::assertEquals($list, $expectedList);
    }
```

If we execute it we'll start seeing errors about *framework* configuration problems. The first thing we have to do is get the test to fail for the right reason, which is none other than, when asking for the task list, receiving a `$list` response that's not the one that we expect. Therefore, we'll start by addressing these problems until we get the test to run.

### Solving the necessary details in the *framework*

The first error tells us that there ins't any controller in the location expected by the *framework*. In our case, on top of that, we want to build a solution with a clean architecture. According to that, the API controllers should be in the Infrastructure layer, so we'll change the configuration of Symfony's **services.yaml** so that it expects to find the controllers in another path. Specifically, I prefer to put them in:

`src/Infrastructure/EntryPoint/Api/Controller`

Therefore, **services.yaml** will look like this:

```yaml
    # controllers are imported separately to make sure services can be injected
    # as action arguments even if you don't extend any base controller class
    App\Infrastructure\EntryPoint\Api\Controller\:
        resource: '../src/Infrastructure/EntryPoint/Api/Controller'
        tags: ['controller.service_arguments']

```

If we run the test again, we will see that the error message has change, which indicates a good intervention on our part. Now it tells us that there aren't any controllers in the newly defined location, so we'll create a `TodoListController` in the path: `\App\Infrastructure\EntryPoint\Api\Controller\TodoListController`.

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


class TodoListController
{

}
```

And for now, we leave it like this. We run the test to see what it says. We have two kinds of messages. On the one hand, several exceptions that indicate us that the *endpoint* routes can't be found, which we haven't defined yet.

On the other hand, the test tells us that the call to the *endpoint* returns `null` and, therefore, we don't have the task list yet.

So we need out controller to be able to handle these routes before anything else. The first route that it cannot find is `POST /api/todo`, which we would use to add new tasks to the list. To solve this, we will introduce an entry in the **routes.yaml** file.

```yaml
api_add_task:
  path: /api/todo
  controller: App\Infrastructure\EntryPoint\Api\Controller\TodoListController::addTask
  methods: ['POST']

```

Once this route has been added, we run the acceptance test again. The appropriate thing is to run the test after each change †o confirm that if fails for the expected reason. In this case, we expect it to tell us that we don't have an `addTask` method in `TodoListController`, and we have to add it in order to advance.

I> You will notice that I'm not following the usual Symfony conventions.

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


class TodoListController
{

    public function addTask()
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

As you can see, in the method I throw an exception that will allow me to see when the real controller is being called. This way, I will be sure about whether it is what I have to implement next. I've gotten this technique from Sandro Mancuso in his *Outside-in* video, and I think it's really useful. In some occasions, the compiler or interpreter could point this lack of implementation itself, but doing it explicitly will make things easier for us.

When re-running the test, the first error literally tells us that we have to implement `addTask`.

And this leads us to the unit test cycle.

## First unit test

The first unit test introduces us a step further towards the interior of the application. The acceptance test executes the code from the *outside* of the application, while the controller is located in the Infrastructure layer. What we are going to do is develop the controller as a unit test, but instead of using the classic approach, which consists in implementing a solution and then using the refactoring stage to design the components, we'll start by this latter point.

That is, what we want to do is to design which components we want the controller to use in order to return a response, *mock* them in the test, implementing only the controller's own code.

In this example, I will assume that each controller invokes a use case in the application layer. So that it's more easily understood, I won't be using a command bus as I would in a real application, but I'll invoke the use cases directly instead.

This is my first unit test:

```php
namespace App\Tests\Infrastructure\EntryPoint\Api\Controller;

use App\Infrastructure\EntryPoint\Api\Controller\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListControllerTest extends TestCase
{

    /** @test */
    public function shouldAddTask(): void
    {
        $addTask = $this->createMock(AddTaskHandler::class);
        $addTask
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');
            
        $todoListController = new TodoListController($addTask);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );
        
        $response = $todoListController->addTask($request);
        
        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }
}
```

On the one hand, in the test we simulate a *request* with a JSON payload, which will be the one that provides us with the necessary data. The `AddTaskHandler` mock simulates that we simply call its `execute` method, passing it -as a parameter- the description of the task provided in the *endpoint* call.

Thanks to the use of *mocks* we don't need to worry about what's happening further inside the application. What we are testing is the way in which the controller obtains the relevant data and passes them to the to the use case so it does whatever it must. If there isn't any problem, the controller will return a 201 response, indicating that the resource has been created. We won't deal with all of the possible errors that could occur in this example, but you can get an idea of how it could be handled.

Now we run the `TodoListController` test to ensure that it fails for the expected reasons: that `AddTaskHandler` is not called and that the HTTP 201 code is not returned.

In this case, the first error is that we don't have an `AddTaskHandler` class which to *mock*, so we create it. We'll put it in `App\Application`.

```
namespace App\Application;


class AddTaskHandler
{

}
```

We run the test again, which will indicate us that there isn't any *execute* method that can be *mocked*. We add it, but we let it throw an exception to tell us that it's not implemented. We'll see the usefulness of this in a while, because it's not actually going to be executed in this test.

```php
namespace App\Application;


class AddTaskHandler
{
    public function execute(string $taskDescription)
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

Instead, if everything has gone well, at this point the test will asks us to implement the controller's `addTask` method, which is the step we were trying to reach.

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


use App\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    private AddTaskHandler $addTask;

    public function __construct(AddTaskHandler $addTask)
    {
        $this->addTask = $addTask;
    }

    public function addTask(Request $request): Response
    {
        $body = json_decode($request->getContent(), true);

        $this->addTask->execute($body['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }
}
```

This code makes the test pass. Given that it's relatively simple, we won't do it in very small steps in order to move with the explanation faster.

We're going to take advantage of the fact that the test is green in order to refactor it a bit. We know that we're going to have to add more tests in this `TestCase` and instantiate the controller several times, so we're going to make our life easier for the near future. After making sure it's still passing, the test looks like this:

```php
namespace App\Tests\Infrastructure\EntryPoint\Api\Controller;

use App\Application\AddTaskHandler;
use App\Infrastructure\EntryPoint\Api\Controller\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListControllerTest extends TestCase
{
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;


    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->todoListController = new TodoListController($this->addTaskHandler);
    }
    
    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }
}
```

It's time to run the acceptance test again.

## Back to the acceptance cycle

Now that the `TodoListController` test is passing, we no longer have any work to perform in this level, so we go back to the acceptance test to check whether anything is still failing, and what is it that fails.

At this point, what it tells us is that `AddTaskHandler::execute` is not implemented. Remember the exception we added earlier? Well, that tells us that we have to move one level deeper and get to the Application layer to develop the use case. Of course, with a unit test.

Like we said earlier, in *outside-in* we design during the red test phase and *mock* the components that the current unit can use as collaborators. We normally wouldn't make entity doubles. In this case, what we expect of the use case is:

* That it creates a new task, modeled as a domain entity `Task`.
* That it makes it persist in a repository.
+ The task has to get an Id, which will be provided by the repository.

This indicates that the use case will have one dependency, the `TaskRepository` repository, and that we'll start modeling the tasks with a `Task`entity. This is the test.

```php
namespace App\Tests\Application;

use App\Application\AddTaskHandler;
use PHPUnit\Framework\TestCase;

class AddTaskHandlerTest extends TestCase
{

    /** @test */
    public function shouldAddATaskToRepository(): void
    {
        $taskRepository = $this->createMock(TaskRepository::class);
        $task = new Task(1, 'Task Description');
        
        $taskRepository
            ->method('nextId')
            ->willReturn(1);
        
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);
        
        
        $addTaskHandler = new AddTaskHandler($taskRepository);
        
        $addTaskHandler->execute('Task Description');
    }
}
```

We execute it, and it will tell us what to do.

The first thing will be to create `TaskRepository` so that we can *mock it* In this case, the repository is defined as interface in the domain layer, as we know already. So we start by doing that.

```php
namespace App\Domain;


interface TaskRepository
{

}
```

The next thing will be the `Task` entity, which is also in the domain.

```php
namespace App\Domain;


class Task
{

    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }
}
```

For now I limit myself to creating to creating the basics, we'll see what the development asks of us.

The next error indicates us that we don't have a `nextId` method in `TaskRepository`, so we introduce it in the interface.

```php
namespace App\Domain;


interface TaskRepository
{
    public function nextId(): int;
}
```

We're also missing a `store` method. Same thing:

```php
namespace App\Domain;


interface TaskRepository
{
    public function nextId(): int;

    public function store(Task $task): void;
}
```
Last, when invoking the `execute` method it throws the well-known exception that it's laking code, indicating that we've already prepared everything that we needed up until this point. So, let's finally implement.

```php
namespace App\Application;


use App\Domain\Task;
use App\Domain\TaskRepository;

class AddTaskHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(string $taskDescription): void
    {
        $id = $this->taskRepository->nextId();

        $task = new Task($id, $taskDescription);

        $this->taskRepository->store($task);
    }
}
```

With this code the test passes. We don't have anything else to do here, expect to see if there's anything that we can refactor. In the test we see some details that can be improved to make everything easier to understand:

```php
namespace App\Tests\Application;

use App\Application\AddTaskHandler;
use App\Domain\Task;
use App\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class AddTaskHandlerTest extends TestCase
{
    private const NEW_TASK_ID = 1;
    private const NEW_TASK_DESCRIPTION = 'Task Description';

    /** @test */
    public function shouldAddATaskToRepository(): void
    {
        $task = new Task(self::NEW_TASK_ID, self::NEW_TASK_DESCRIPTION);
        
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('nextId')
            ->willReturn(self::NEW_TASK_ID);
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);
        
        $addTaskHandler = new AddTaskHandler($taskRepository);

        $addTaskHandler->execute(self::NEW_TASK_DESCRIPTION);
    }
}
```

Let's go back to the acceptance test and see what happens.

## New visit to the acceptance test

When we run the acceptance test again it indicates us that, although we have an interface for `TaskRepository`, we haven't defined any concrete implementation, so the test isn't executed. It's time to develop one.

Taking into account that we're creating a REST API, we need that the tasks that we store persist between calls, so in principle, an in-memory repository won't work for us. In our case we'll use a *vendor*, which is located in the repository that we're using as a base for this development. It's the `FileStorageEngine` class. It simply saves the objects to a file, so that we simulate a real database whose persistence is sufficient to run the test.

```php
namespace App\Lib;


class FileStorageEngine
{
    private string $filePath;

    public function __construct($filePath)
    {
        $this->filePath = $filePath;
    }

    public function loadObjects(string $class): array
    {
        if (!file_exists($this->filePath)) {
            return [];
        }

        $file = fopen($this->filePath, 'rb');
        $objects = unserialize(fgets($file), ['allowed_classes' => [$class]]);
        fclose($file);

        return $objects;
    }

    public function persistObjects(array $objects): void
    {
        $file = fopen($this->filePath, 'wb');
        fwrite($file, serialize($objects));
        fclose($file);
    }

}
```

So, let's write unit tests to develop a task repository that uses `FileStorageEngine`.

```php
namespace App\Tests\Infrastructure\Persistence;

use App\Domain\Task;
use App\Infrastructure\Persistence\FileTaskRepository;
use App\Lib\FileStorageEngine;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    /** @test */
    public function shouldBeAbleToStoreTasks(): void
    {
        $task = new Task(1, 'TaskDescription');
        $storageEngine = $this->createMock(FileStorageEngine::class);
        $storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([]);
        $storageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with(['1' => $task]);

        $taskRepository = new FileTaskRepository($storageEngine);
        $taskRepository->store($task);
    }
}

```

Executing the test tells us that we don't have a `FileTaskRespository`, so we start building it. When it fails, the test will tell us what we have to do. And this is the result:

```php
namespace App\Infrastructure\Persistence;


use App\Domain\Task;
use App\Domain\TaskRepository;
use App\Lib\FileStorageEngine;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $storageEngine;

    public function __construct(FileStorageEngine $storageEngine)
    {
        $this->storageEngine = $storageEngine;
    }

    public function store(Task $task): void
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);
        $tasks[$task->id()] = $task;
        $this->storageEngine->persistObjects($tasks);
    }

    public function nextId(): int
    {
        throw new \RuntimeException('Implement nextId() method.');
    }
}
```

Again, we have skipped some *baby steps* to reach the desired implementation. Once the test passes, we return to the acceptance test.

The test now tells us that we're missing the implementation of the `nextId` method in `FileTaskRepository`. So we come back to the unit test.

In principle, what we're going to do is simply return the number of saved tasks -plus one- as a new `id`. This won't work properly in the event that we end up deleting tasks, but it will suffice for now. This is the test:

```php
    /** @test */
    public function shouldProvideNextIdentity(): void
    {
        $storageEngine = $this->createMock(FileStorageEngine::class);
        $storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([]);

        $taskRepository = new FileTaskRepository($storageEngine);
        $id = $taskRepository->nextId();
        self::assertEquals(1, $id);
    }
```

And this is the implementation:

```php
    public function nextId(): int
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }
```

It would be necessary to add a few more cases to verify it, but we leave it as is in order to move faster now.

## Finishing the first user story

If we run the acceptance test now, we'll see that the error that shows up says that we don't have a route for the *endpoint* in which we mark a task as completed. This means that the first of our *User Stories* is finished: tasks can now be added to the list.

We've gone from the exterior of the application to the details of the implementation, and every step was already covered by tests. The truth is that we've been able to get a lot of work done, but there's still a long way to go.

And the first step should sound familiar to us. We have to define the route to the *endpoint*, the controller, a new use case, and the interaction with the task repository. To **routes.yaml** we add the route:

```yaml
api_add_task:
  path: /api/todo
  controller: App\Infrastructure\EntryPoint\Api\Controller\TodoListController::addTask
  methods: ['POST']

api_mark_task_completed:
  path: /api/todo/{taskid}
  controller: App\Infrastructure\EntryPoint\Api\Controller\TodoListController::markTaskCompleted
  methods: ['PATCH']
```

We add a method to `TodoListController`:

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


use App\Application\AddTaskHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    private AddTaskHandler $addTask;

    public function __construct(AddTaskHandler $addTask)
    {
        $this->addTask = $addTask;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $this->addTask->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function markTaskCompleted(int $taskid, Request $request): Response
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

When we add this code and execute the acceptance test, the error messages asks us to implement the new method. So we go to `TodoListControllerTest` and add the following test:

```php
namespace App\Tests\Infrastructure\EntryPoint\Api\Controller;

use App\Application\AddTaskHandler;
use App\Infrastructure\EntryPoint\Api\Controller\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListControllerTest extends TestCase
{
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;


    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->markTaskCompletedHandler
        );
    }

    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    /** @test */
    public function shouldMarkATaskCompleted(): void
    {
        $this->markTaskCompletedHandler
            ->expects(self::once())
            ->method('execute')
            ->with(1);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['done' => true], JSON_THROW_ON_ERROR)
        );

        $taskId = 1;
        $response = $this->todoListController->markTaskCompleted($taskId, $request);

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
    }


}
```

This test will fail because we haven't defined `MarkTaskCompletedHandler` yet, so we will be running the test and solving the different errors until it fails for the right reasons and, after that, we'll implement whatever it needs to pass.

```php
namespace App\Application;


class MarkTaskCompletedHandler
{
    public function execute(int $taskId, bool $done): void
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

Once we've added the basic code of the use case we can start implementing the controller, which will look like this:

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


use App\Application\AddTaskHandler;
use App\Application\MarkTaskCompletedHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    private AddTaskHandler $addTask;
    private MarkTaskCompletedHandler $markTaskCompleted;

    public function __construct(
        AddTaskHandler $addTask,
        MarkTaskCompletedHandler $markTaskCompleted
    )
    {
        $this->addTask = $addTask;
        $this->markTaskCompleted = $markTaskCompleted;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $this->addTask->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function markTaskCompleted(int $taskid, Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $done = $payload['done'];

        $this->markTaskCompleted->execute($taskid, $done);

        return new JsonResponse('', Response::HTTP_OK);
    }
}
```

And with this we make `TodoListControllerTest` pass. It's time to run the acceptance test once again so that it tells us what we need to do now.

And basically, what it says is that we must implement `MarkTaskCompletedHandler`, which doesn't have any code yet. For that purpose we will need a unit test.

The use case will depend on the repository to obtain and update the desired task. That will be what we *mock*.

```php
namespace App\Tests\Application;

use App\Application\MarkTaskCompletedHandler;
use App\Domain\Task;
use App\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class MarkTaskCompletedHandlerTest extends TestCase
{
    private const TASK_ID = 1;

    /** @test */
    public function shouldMarkTaskAsComplete(): void
    {
        $task = $this->createMock(Task::class);
        $task
            ->expects(self::once())
            ->method('markCompleted');
        
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('retrieve')
            ->with(self::TASK_ID)
            ->willReturn($task);
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with($task);

        $markTaskAsCompleted = new MarkTaskCompletedHandler($taskRepository);

        $markTaskAsCompleted->execute(self::TASK_ID, true);
    }
}
```

As a somewhat striking detail, I should note that we're going to *mock* an entity. This is necessary to be able to test that something that interests us happens: that we call its `markCompleted` method. This will force us to implement it. I would usually avoid *mocking* entities.

When we run the test it asks us for a `retrieve` method, which we don't have in the repository yet.

```php
namespace App\Domain;


interface TaskRepository
{
    public function nextId(): int;

    public function store(Task $task): void;

    public function retrieve(int $taskId): Task;
}
```

As well as `markCompleted` in `Task`:

```php
namespace App\Domain;


class Task
{

    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function markCompleted(): void
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

Finally, we have to implement the `execute` method of the use case, which will look like this:

```php
namespace App\Application;


use App\Domain\TaskRepository;

class MarkTaskCompletedHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, bool $done): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        $task->markCompleted();

        $this->taskRepository->store($task);
    }
}
```

And we're done here for now.

We'll run the acceptance test again. Let's see what it tells us.

The first thing that it indicates us is that we don't have the `retrieve` method in the  `FileTaskRepository` repository. We have to implement it in order to continue. To do this, we'll use the same `FileTaskRepositoryTestCase` that we had already started.

```php
    /** @test */
    public function shouldRetrieveTasksById(): void
    {
        $storageEngine = $this->createMock(FileStorageEngine::class);
        $task1 = new Task(1, 'Task 1');
        $task2 = new Task(2, 'Task 2');
        $storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([1 => $task1, 2 => $task2]);

        $taskRepository = new FileTaskRepository($storageEngine);
        $task = $taskRepository->retrieve(2);

        self::assertEquals($task2, $task);
    }
```

It will ask us to implement `retrieve`. This would be enough:

```php
namespace App\Infrastructure\Persistence;


use App\Domain\Task;
use App\Domain\TaskRepository;
use App\Lib\FileStorageEngine;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $storageEngine;

    public function __construct(FileStorageEngine $storageEngine)
    {
        $this->storageEngine = $storageEngine;
    }

    public function store(Task $task): void
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);
        $tasks[$task->id()] = $task;
        $this->storageEngine->persistObjects($tasks);
    }

    public function nextId(): int
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function retrieve(int $taskId): Task
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);

        return $tasks[$taskId];
    }
}
```

And it does suffice. Now that we're in green, we can take the opportunity to fix the test up a little bit.

```php
namespace App\Tests\Infrastructure\Persistence;

use App\Domain\Task;
use App\Infrastructure\Persistence\FileTaskRepository;
use App\Lib\FileStorageEngine;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $storageEngine;
    private FileTaskRepository $taskRepository;
    
    protected function setUp(): void
    {
        $this->storageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->storageEngine);
    }


    /** @test */
    public function shouldBeAbleToStoreTasks(): void
    {
        $task = new Task(1, 'TaskDescription');
        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([]);
        $this->storageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }

    /** @test */
    public function shouldProvideNextIdentity(): void
    {
        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([]);
        
        $id = $this->taskRepository->nextId();
        self::assertEquals(1, $id);
    }

    /** @test */
    public function shouldRetrieveTasksById(): void
    {
        $task1 = new Task(1, 'Task 1');
        $task2 = new Task(2, 'Task 2');
        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([1 => $task1, 2 => $task2]);

        $task = $this->taskRepository->retrieve(2);

        self::assertEquals($task2, $task);
    }
}
```

Once this has been done, we can run the acceptance test again and see how far we've come.

When we do this, the exception that we had left in `Task::markCompleted` is thrown. For now we'll implement it without doing anything else. We'll wait until other tests force us to do it, since we don't actually have any way of verifying it without specifically creating a method to check its status in a test.

```php
namespace App\Domain;


class Task
{

    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function markCompleted(): void
    {
    }
}
```

This allows the test to reach the next interesting point: we don't have a route to recover the task list. In **routes.yaml** we add the definition:

```yaml
api_add_task:
  path: /api/todo
  controller: App\Infrastructure\EntryPoint\Api\Controller\TodoListController::addTask
  methods: ['POST']

api_mark_task_completed:
  path: /api/todo/{taskid}
  controller: App\Infrastructure\EntryPoint\Api\Controller\TodoListController::markTaskCompleted
  methods: ['PATCH']

api_get_tasks_list:
  path: /api/todo
  controller: App\Infrastructure\EntryPoint\Api\Controller\TodoListController::getTasksList
  methods: ['GET']
```

We run the acceptance test to see that it's no longer asking for the route, but rather for the implementation of a controller. And we add a skeleton to `TodoListController`.

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


use App\Application\AddTaskHandler;
use App\Application\MarkTaskCompletedHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    private AddTaskHandler $addTask;
    private MarkTaskCompletedHandler $markTaskCompleted;

    public function __construct(
        AddTaskHandler $addTask,
        MarkTaskCompletedHandler $markTaskCompleted
    )
    {
        $this->addTask = $addTask;
        $this->markTaskCompleted = $markTaskCompleted;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $this->addTask->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function markTaskCompleted(int $taskid, Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $done = $payload['done'];

        $this->markTaskCompleted->execute($taskid, $done);

        return new JsonResponse('', Response::HTTP_OK);
    }

    public function getTasksList(): Response
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

So we have to go back to `TodoListControllerTestCase` to develop this method:

```php
namespace App\Tests\Infrastructure\EntryPoint\Api\Controller;

use App\Application\AddTaskHandler;
use App\Application\MarkTaskCompletedHandler;
use App\Domain\Task;
use App\Infrastructure\EntryPoint\Api\Controller\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListControllerTest extends TestCase
{
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private GetTasksListHandler $getTasksListHandler;
    
    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->getTasksListHandler = $this->createMock(GetTasksListHandler::class)

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->markTaskCompletedHandler,
            $this->getTasksListHandler
        );
    }

    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    /** @test */
    public function shouldMarkATaskCompleted(): void
    {
        $this->markTaskCompletedHandler
            ->expects(self::once())
            ->method('execute')
            ->with(1);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['done' => true], JSON_THROW_ON_ERROR)
        );

        $taskId = 1;
        $response = $this->todoListController->markTaskCompleted($taskId, $request);

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
    }

    /** @test */
    public function shouldGetListOfTasks(): void
    {
        $task1 = new Task(1, 'Task 1');
        $task1->markCompleted();

        $task2 = new Task(2, 'Task 2');

        $expectedList = ['[√] Task 1', '[ ] Task 2'];

        $this->getTasksListHandler
            ->expects(self::once())
            ->method('execute')
            ->willReturn([$task1, $task2]);
        
        $request = new Request();
        
        $response = $this->todoListController->getTasksList($request);
        
        $list = json_decode($response->getContent(), true);
        
        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        self::assertEquals($expectedList, $list);
    }
}
```

The test will fail since we need to implement `GetTasksListHandler`.

```php
namespace App\Application;


class GetTasksListHandler
{
    public function execute(): array
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

When we are able to run the whole test, we start implementing. This is our attempt:

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


use App\Application\AddTaskHandler;
use App\Application\GetTasksListHandler;
use App\Application\MarkTaskCompletedHandler;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    private AddTaskHandler $addTask;
    private MarkTaskCompletedHandler $markTaskCompleted;
    private GetTasksListHandler $getTasksList;

    public function __construct(
        AddTaskHandler $addTask,
        MarkTaskCompletedHandler $markTaskCompleted,
        GetTasksListHandler $getTasksList
    )
    {
        $this->addTask = $addTask;
        $this->markTaskCompleted = $markTaskCompleted;
        $this->getTasksList = $getTasksList;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $this->addTask->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function markTaskCompleted(int $taskid, Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $done = $payload['done'];

        $this->markTaskCompleted->execute($taskid, $done);

        return new JsonResponse('', Response::HTTP_OK);
    }

    public function getTasksList(Request $request): Response
    {
        $list = $this->getTasksList->execute();

        return new JsonResponse($list, Response::HTTP_OK);
    }
}
```

The problem here is that we have to introduce a way of converting the list -as the `GetTaskListHandler` returns it- to the format that the *endpoint* consumer requires. It's a representation of the task in the form of a text string.

There are several ways of solving this, and all of them require `Task` to give us some kind of usable representation:

* The simplest one would be to perform the conversion in the controller itself, going through the list and generating their representations. In order to do that we would need a method that took care of it.
* Another one would be to create a service that does the conversion. It would be a dependency of the controller.
* And a third alternative would be to use that same service, but passing it to `GetTaskListHandler` as an strategy. This way, the controller decides how it wants to get the list, although it's `GetTaskListHandler` the one that prepares it.

This last option will be the one that we use. But to do that we'll need to modify tests. Not a lot, fortunately, only `TodoListControllerTest` actually needs changing.

```php
namespace App\Tests\Infrastructure\EntryPoint\Api\Controller;

use App\Application\AddTaskHandler;
use App\Application\GetTasksListHandler;
use App\Application\MarkTaskCompletedHandler;
use App\Application\TaskListFormatter;
use App\Domain\Task;
use App\Infrastructure\EntryPoint\Api\Controller\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListControllerTest extends TestCase
{
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private GetTasksListHandler $getTasksListHandler;
    private TaskListFormatter $taskListFormatter;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->getTasksListHandler = $this->createMock(GetTasksListHandler::class);
        $this->taskListFormatter = $this->createMock(TaskListFormatter::class);

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->markTaskCompletedHandler,
            $this->getTasksListHandler,
            $this->taskListFormatter
        );
    }

    /** @test */
    public function shouldAddTask(): void
    {
        $this->addTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with('Task Description');

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Task Description'], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(Response::HTTP_CREATED, $response->getStatusCode());
    }

    /** @test */
    public function shouldMarkATaskCompleted(): void
    {
        $this->markTaskCompletedHandler
            ->expects(self::once())
            ->method('execute')
            ->with(1);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['done' => true], JSON_THROW_ON_ERROR)
        );

        $taskId = 1;
        $response = $this->todoListController->markTaskCompleted($taskId, $request);

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
    }

    /** @test */
    public function shouldGetListOfTasks(): void
    {
        $expectedList = ['[√] Task 1', '[ ] Task 2'];

        $this->getTasksListHandler
            ->expects(self::once())
            ->method('execute')
            ->with($this->taskListFormatter)
            ->willReturn($expectedList);

        $request = new Request();

        $response = $this->todoListController->getTasksList($request);

        $list = json_decode($response->getContent(), true);

        self::assertEquals(Response::HTTP_OK, $response->getStatusCode());
        self::assertEquals($expectedList, $list);
    }
}
```

And the controller will end up like this:

```php
namespace App\Infrastructure\EntryPoint\Api\Controller;


use App\Application\AddTaskHandler;
use App\Application\GetTasksListHandler;
use App\Application\MarkTaskCompletedHandler;
use App\Application\TaskListFormatter;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{

    private AddTaskHandler $addTask;
    private MarkTaskCompletedHandler $markTaskCompleted;
    private GetTasksListHandler $getTasksList;
    private TaskListFormatter $taskListFormatter;


    public function __construct(
        AddTaskHandler $addTask,
        MarkTaskCompletedHandler $markTaskCompleted,
        GetTasksListHandler $getTasksList,
        TaskListFormatter $taskListFormatter
    )
    {
        $this->addTask = $addTask;
        $this->markTaskCompleted = $markTaskCompleted;
        $this->getTasksList = $getTasksList;
        $this->taskListFormatter = $taskListFormatter;
    }

    public function addTask(Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $this->addTask->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    public function markTaskCompleted(int $taskid, Request $request): Response
    {
        $payload = json_decode($request->getContent(), true);

        $done = $payload['done'];

        $this->markTaskCompleted->execute($taskid, $done);

        return new JsonResponse('', Response::HTTP_OK);
    }

    public function getTasksList(Request $request): Response
    {
        $list = $this->getTasksList->execute($this->taskListFormatter);

        return new JsonResponse($list, Response::HTTP_OK);
    }
}
```

And the use case will be this one:

```php
namespace App\Application;


class GetTasksListHandler
{
    public function execute(TaskListFormatter $taskListFormatter): array
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

And, for now, our *formatter* implementation will be like this:

```php
namespace App\Application;


class TaskListFormatter
{
    public function format(array $tasks): array
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

We're back to green, and in this case, as we'll see, it means that we've already finished with `TodoListController`. Let's see what the acceptance test has to say.

The acceptance test asks us to implement the use case. So we'll have to create a new unit test.

```php
namespace App\Tests\Application;

use App\Application\GetTasksListHandler;
use App\Application\TaskListFormatter;
use App\Domain\Task;
use App\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class GetTasksListHandlerTest extends TestCase
{

    /** @test */
    public function shouldGetTheListOfTasks(): void
    {
        $tasks = [
            new Task(1, 'Task 1'),
            new Task(2, 'Task 2')
        ];

        $expectedList = ['[√] Task 1', '[ ] Task 2'];

        $tasksRepository = $this->createMock(TaskRepository::class);
        $tasksRepository->method('findAll')->willReturn($tasks);
        
        $formatter = $this->createMock(TaskListFormatter::class);
        $formatter
            ->expects(self::once())
            ->method('format')
            ->with($tasks)
            ->willReturn($expectedList);

        $getTaskListHandler = new GetTasksListHandler($tasksRepository);
        $list = $getTaskListHandler->execute($formatter);

        self::assertEquals($expectedList, $list);
    }
}
```

Running the test show us the necessity to implement a `findAll` method in the repository. 
Once this is solved, we will have to implement the `execute` method of the use case:

```php
namespace App\Application;


use App\Domain\TaskRepository;
use App\Application\TaskListFormatter;

class GetTasksListHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(TaskListFormatter $taskListFormatter): array
    {
        $tasks = $this->taskRepository->findAll();

        return $taskListFormatter->format($tasks);
    }
}
```

This simple implementation takes us to green, and we can re-run the acceptance test. We're very close to the end! But we have to add the `findAll` method to the specific repository. First the test:

```php
namespace App\Tests\Infrastructure\Persistence;

use App\Domain\Task;
use App\Infrastructure\Persistence\FileTaskRepository;
use App\Lib\FileStorageEngine;
use PHPUnit\Framework\TestCase;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $storageEngine;
    private FileTaskRepository $taskRepository;

    protected function setUp(): void
    {
        $this->storageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->storageEngine);
    }


    /** @test */
    public function shouldBeAbleToStoreTasks(): void
    {
        $task = new Task(1, 'TaskDescription');
        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([]);
        $this->storageEngine
            ->expects(self::once())
            ->method('persistObjects')
            ->with([1 => $task]);

        $this->taskRepository->store($task);
    }

    /** @test */
    public function shouldProvideNextIdentity(): void
    {
        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([]);

        $id = $this->taskRepository->nextId();
        self::assertEquals(1, $id);
    }

    /** @test */
    public function shouldRetrieveTasksById(): void
    {
        $task1 = new Task(1, 'Task 1');
        $task2 = new Task(2, 'Task 2');
        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn([1 => $task1, 2 => $task2]);

        $task = $this->taskRepository->retrieve(2);

        self::assertEquals($task2, $task);
    }

    /** @test */
    public function shouldRetrieveAllTasks(): void
    {
        $expectedTasks = [
            1 => new Task(1, 'Task 1'),
            2 => new Task(2, 'Task 2'),
        ];

        $this->storageEngine
            ->method('loadObjects')
            ->with(Task::class)
            ->willReturn($expectedTasks);

        $tasks = $this->taskRepository->findAll();

        self::assertEquals($expectedTasks, $tasks);
    }
}
```

Test that is swiftly solved with:

```php
namespace App\Infrastructure\Persistence;


use App\Domain\Task;
use App\Domain\TaskRepository;
use App\Lib\FileStorageEngine;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $storageEngine;

    public function __construct(FileStorageEngine $storageEngine)
    {
        $this->storageEngine = $storageEngine;
    }

    public function store(Task $task): void
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);
        $tasks[$task->id()] = $task;
        $this->storageEngine->persistObjects($tasks);
    }

    public function nextId(): int
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);

        return count($tasks) + 1;
    }

    public function retrieve(int $taskId): Task
    {
        $tasks = $this->storageEngine->loadObjects(Task::class);

        return $tasks[$taskId];
    }

    public function findAll(): array
    {
        return $this->storageEngine->loadObjects(Task::class);
    }
}
```

And we run the acceptance test once again to see where to go next. This time the test tells us that we have to implement the `TaskListFormatter::format` method. We are really two steps away, but we have to create a unit test.

At this point we could propose different designs that avoid dealing with presentation issues in a domain entity, but for simplicity we'll make `Task` able to provide its text representation by adding an `asString` method.

It's worth wondering if it would be appropriate to use a double of `Task` here -something that we already did in another test- and wait until the acceptance test ask us to develop `Task`, or if it would be preferable to just use the entity as is, and that the test forced us to introduce the necessary methods.

In practice, having reached this point, I think that it all comes down to the complexity that this may entail.  In this exercise, the behavior of `Task` is pretty trivial, so we could just move forward with the entity without further complications. But if the behavior is complex, it might be better to slow down, work with the *mock*, and spend the necessary time afterwards.

So here we'll use *mocks* for that as well.


```php
namespace App\Tests\Application\Formatter;

use App\Domain\Task;
use App\Application\TaskListFormatter;
use PHPUnit\Framework\TestCase;

class TaskListFormatterTest extends TestCase
{

    /** @test */
    public function shouldFormatAListOfTasks(): void
    {
        $expected = [
            '[√] 1. Task 1',
            '[ ] 2. Task 2'
        ];

        $task1 = $this->createMock(Task::class);
        $task1->method('asString')->willReturn('[√] 1. Task 1');

        $task2 = $this->createMock(Task::class);
        $task2->method('asString')->willReturn('[ ] 2. Task 2');

        $formatter = new TaskListFormatter();
        $formattedList = $formatter->format([$task1, $task2]);

        self::assertEquals($expected, $formattedList);
    }
}
```

We run the test to see it fail because we don't have the `asString` method in `Task`. So we introduce it. Notice that we haven't implemented `markCompleted` yet.

```php
namespace App\Domain;


class Task
{

    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function markCompleted(): void
    {
    }

    public function asString(): string
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

When re-running the test it soon complains about the `format` method not being implemented, so we get down to it:

```php
namespace App\Application\Formatter;


class TaskListFormatter
{
    public function format(array $tasks): array
    {
        $formatted = [];

        foreach ($tasks as $task) {
            $formatted[] = $task->asString();
        }

        return $formatted;
    }
}
```

And we're already in green. Time go back to the acceptance test loop.

## Last steps

The acceptance test, as we might have expected, fails because `Task::asString` is not implemented. We had also left `Task:markCompleted` unimplemented doing nothing. It could be a good idea to let it complain again, and that way making sure that it's being called and not forgetting to handle it as well.

```php
namespace App\Domain;


class Task
{

    private int $id;
    private string $description;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function markCompleted(): void
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }

    public function asString(): string
    {
        throw new \RuntimeException(sprintf('Implement %s::%s', __CLASS__, __METHOD__));
    }
}
```

And when running the acceptance test again, we see that it complains exactly about that, and that this is where we want to be now.

We have to move forward with the development of `Task`, using a unit test. As we don't want to add methods, for now, we will verify the state of `done` through `asString`.

```php
namespace App\Tests\Domain;

use App\Domain\Task;
use PHPUnit\Framework\TestCase;

class TaskTest extends TestCase
{

    /** @test */
    public function shouldHaveTextualRepresentation(): void
    {
        $task = new Task(1, 'Task Description');
        
        $formatted = $task->asString();
        
        self::assertEquals('[ ] 1. Task Description', $formatted);
    }
}
```

This test passes. So we have to go back to the acceptance test.

Now the test message has changed. It's asking us to implement `markCompleted` in `Task`, but the test itself is failing because the responses don't match. It expects this:

```
Array (
    0 => '[√] 1. Write a test that fails'
    1 => '[ ] 2. Write Production code ...t pass'
    2 => '[ ] 3. Refactor if there is o...tunity'
)
``` 

and it obtains this:

```
Array (
    0 => '[ ] 1. Write a test that fails'
    1 => '[ ] 2. Write Production code ...t pass'
    2 => '[ ] 3. Refactor if there is o...tunity'
)
```

By now, the reason is obvious. There is nothing that's implemented in `Task` that takes care of keeping the `done` state.

Let's add one more case to the test:

```php
namespace App\Tests\Domain;

use App\Domain\Task;
use PHPUnit\Framework\TestCase;

class TaskTest extends TestCase
{

    /** @test */
    public function shouldHaveTextualRepresentation(): void
    {
        $task = new Task(1, 'Task Description');

        $formatted = $task->asString();

        self::assertEquals('[ ] 1. Task Description', $formatted);
    }

    /** @test */
    public function shouldHaveTextualRepresentationWhenDone(): void
    {
        $task = new Task(1, 'Task Description');
        $task->markCompleted();
        
        $formatted = $task->asString();

        self::assertEquals('[√] 1. Task Description', $formatted);
    }
}
```

Now we implement it:

```php
namespace App\Domain;


class Task
{

    private int $id;
    private string $description;
    private bool $done;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        $this->description = $description;
        $this->done = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function markCompleted(): void
    {
        $this->done = true;
    }

    public function asString(): string
    {
        $done = $this->done ? '√' : ' ';
        return sprintf('[%s] %s. %s', $done, $this->id, $this->description);
    }
}
```

With the test in green, we run the acceptance test again, and... Yes! The test passes without any more problems: we have finished the development of our application.

## What have we learned in this kata

* The *mockist outside-in* modality seems to contravene TDD rules. In spite of that, the whole process has been guided by what tests indicate.
* The acceptance test will fail as long as everything that's necessary to run the application has not been implemented.
* We always move between the acceptance test loop, and each of the acceptance test that we'll have to use to develop the components.
* Once the acceptance test passes the *feature* is complete, at least in the terms in which we have defined the test.
* In unit tests we use *mocks* to define the public interface of each component according to the needs of its consumers, which helps us to maintain the principle of interface segregation.

