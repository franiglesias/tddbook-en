# Adding new features

In the previous chapter we talked about that, from the point of view of TDD-based development, all of the defects can almost be considered as *features* that just weren't defined initially. Another way of looking at it is that they're called *features* if we're asked for them explicitly, and defects if they're implicit in another *feature*, but haven't been developed.

That is, when we say that we want to be able to mark a task as completed, to follow up with out to-do list project, we can assume that the system mustn't break if we try to mark an inexistent task. For this reason, we'd say that this *feature* had a bug, and that's precisely what we fixed in the previous chapter.

But in this chapter, we'll tackle how to add new features to existing software by following a TDD approach. And, as it could be expected, we're not actually going to make any change to our methodology. We'll still be starting with an acceptance test, and delving deeper into the application and the necessary changes.

All in all, it's a different scenario. A new behavior might require us to modify existing software units, and we need to make sure that the changes don't break any of the already created functionality.

## New user story

The next business requirement is to allow to edit an existing task.

### US-4

* As a user
* I want to modify a existing task in the list
* So that, I can express my ideas better

Initially, this story requires the creation of a new *endpoint* with which to change a task's information.

```
PUT /api/todo/{taskId}
```

If our application has a *front-end*, we might need an *endpoint* to recover the information of the task that we wish to edit, with the purpose of filling out the form with the current data. In this case, it would be:

```
GET /api/todo/{taskId}
```

In both cases, the procedure will be the same: we'll begin by creating an acceptance test, initiating the development process. What we will find is that some of the necessary components are already created.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    public function asUserIWantToModifyAnExistingTask(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $this->client->request(
            'PUT',
            '/api/todo/2',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write production code to make the test pass'], JSON_THROW_ON_ERROR)
        );

        $putResponse = $this->client->getResponse();
        
        self::assertEquals(204, $putResponse->getStatusCode());

        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write production code to make the test pass',
            ],
            $response
        );
    }
    
    # ...
}
```

So, we run the test to see what it tells us. As expected, the *endpoint* cannot be found because we don't have the route, so we start by defining it.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']

api_get_task_list:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
  methods: ['GET']

api_mark_task_completed:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
  methods: ['PATCH']

api_edit_task:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::modifyTask
  methods: ['PUT']
```

When rerunning the test after this change, it'll tell us that there isn't any action in the controller that's able to respond to this route.

```
"The controller for URI "/api/todo/2" is not callable. Expected method "modifyTask"
```

So we'll have to add a new empty action.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    # ...
    
    public function modifyTask(int $taskId, Request $request): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    # ...
}
```

In the new execution of the test, the error will be:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::modifyTask"
```

Which tells us that we have to dive into the unit level to implement this action in the controller. This cycle will ring a bell, because it's what we've been doing in all this part of the book.

But the truth is that this routine is something positive. We always have a concrete task to tackle at every moment, be it creating a test or writing production code, and we don't have to worry about anything else. The acceptance test tells us what to do, and at each level we just have to think about the specific component that we're working on.

It's time for us to implement the controller. As we already know, at this stage we have to design. Basically, it's a similar action to adding a task, but in this case we'll receive the id of the task that we're going to modify, as well as its new description.

We'll need a use case that expresses this user intention, to which we'll pass the two pÃ¬eces of data that we need. If everything goes as planned, we'll return the 204 response (no content).

We add a test that encompasses all this:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private const TASK_ID = 1;

    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->updateTaskHandler = $this->createMock(UpdateTaskHandler::class);

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler,
            $this->updateTaskHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldModifyATask(): void
    {
        $this->updateTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_ID, self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->modifyTask(self::TASK_ID,$request);

        self::assertEquals(204, $response->getStatusCode());
    }

    # ...
}
```

If we run the test, it will ask us to create the `UpdateTaskHandler` use case.

```php
namespace App\TodoList\Application;

class UpdateTaskHandler
{
}
```

And next, it will ask for the `execute` method.

```php
namespace App\TodoList\Application;

class UpdateTaskHandler
{
    public function execute()
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Once we have that, it again asks us to implement the controller's action. So we get to it:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler,
        UpdateTaskHandler $updateTaskHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
        $this->updateTaskHandler = $updateTaskHandler;
    }

    # ...

    public function modifyTask(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->updateTaskHandler->execute($taskId, $payload['task']);

        return new JsonResponse('', Response::HTTP_NO_CONTENT);
    }

    # ...
}
```

And the controller's unit test passes. If we return to the acceptance test, as we should be doing now, it'll tell us what we have to do next:

```
RuntimeException: "Implement App\TodoList\Application\UpdateTaskHandler::execute"
```

So, it's time to get into the application layer. Again, we have to design this level, which poses an interesting problem.

In principle, we have defined that the field of the task that can be changed is just its description. Therefore, this action has to respect the current stated of the completed flag. So what we want is to recover the stored task, modify its description, and save it.

Therefore, we'll ask the repository for the task, we'll change it, and we'll store it again.

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class UpdateTaskHandlerTest extends TestCase
{

    private const TASK_ID = 1;

    public function testShouldUpdateATask(): void
    {
        $task = new Task(self::TASK_ID, 'Task Description');
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('retrieve')
            ->with(self::TASK_ID)
            ->willReturn($task);
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with(new Task(self::TASK_ID, 'New Task Description'));

        $updateTaskHandler = new UpdateTaskHandler($taskRepository);

        $updateTaskHandler->execute(self::TASK_ID, 'New Task Description');
    }
}
```

When we run the test, it will ask us to implement the use case, as the repository had already been defined previously.

The implementation will surely force us to introduce some new method in `Task`, making a way for the description to be updated. This one, for example:

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\TaskRepository;

class UpdateTaskHandler
{

    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, string $newTaskDescription): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        $task->updateDescription($newTaskDescription);

        $this->taskRepository->store($task);
    }
}
```

I've chosen this implementation to simplify. However, as I write this, I can come up some ideas that could be interesting in a realistic use case. One of them could be to apply a certain immutability, that is, instead of updating the `Task` object, we'd create a new one filled out with new values.

But we'll leave those refinements for another occasion. If the run the test, it'll tell us that `Task` is lacking the `updateDescription` method, which we'll have to develop with the help of a unit test.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[â] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldUpdateDescription(): void
    {
        $expected = '[ ] 1. New Task Description';
        $task = new Task(1, 'Task Description');
        $task->updateDescription('New Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

}
```

To make the test pass, we have to introduce the method.

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? 'â' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        $this->description = $newTaskDescription;
    }
}
```

The test passes, but we've noticed a problem. â

El test pasa, pero nos hemos dado cuenta un problema. Hace nada hemos implementado una validaciÃ³n para impedir que `Task::description` pueda ser una cadena vacÃ­a. Para asegurar que cumplimos esta regla de negocio, deberÃ­amos introducir otro test que lo verifique e implementar la respuesta que queramos dar a este caso.

Sin embargo esto no lo hemos cubierto en el nivel de aceptaciÃ³n o en el del controlador. Â¿QuÃ© deberÃ­amos hacer entonces? Â¿Resolverlo ahora y aÃ±adir tests en los otros niveles despuÃ©s o esperar y aÃ±adir esa protecciÃ³n en una nueva iteraciÃ³n?

Personalmente creo que la mejor respuesta es tomar nota de esto y resolverlo en un nuevo ciclo. Es importante centrarnos ahora en la caracterÃ­stica que estamos desarrollando y terminar este ciclo.

Por tanto, al hacer pasar el test unitario de `Task`, volvemos primero al test de `UpdateTaskHandler` y comprobamos si ya pasa, cosa que ocurre.

Y con este nivel en verde, probamos de nuevo en el de aceptaciÃ³n, que tambiÃ©n pasa sin mÃ¡s problemas.

El resultado es que la nueva historia estÃ¡ implementada, aunque como hemos descubierto necesitamos hacer una iteraciÃ³n para prevenir el problema de intentar cambiar las descripciÃ³n de una historia con un valor no vÃ¡lido.

Â¿Lo hubiÃ©semos podido prevenir antes? Puede ser, sin embargo, igualmente necesitarÃ­amos introducir tests en los distintos niveles, al igual que hicimos en el capÃ­tulo anterior. El valor de usar TDD es justamente desarrollar una serie de hÃ¡bitos de pensamiento y una cierta automatizaciÃ³n. En otras palabras, desarrollar una disciplina y llegar a todos los objetivos paso a paso.

## Completar la historia

En cualquier caso, todo nuevo comportamiento del sistema tendrÃ­a que estar definido mediante un test. AsÃ­ que necesitaremos un test para incluir el cumplimiento de la regla de negocio, lo que nos lleva de nuevo al nivel de aceptaciÃ³n.

Puesto que es una regla de negocio, este test lo conservaremos despuÃ©s.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ..

    /** @test */
    public function asUserITryToUpdateTaskWithAnEmptyTaskDescription(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $this->client->request(
            'PUT',
            '/api/todo/1',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Task description should not be empty', $body['error']);
    }

    # ...
}
```


El test falla:

```
Failed asserting that 204 matches expected 400.
```

Lo que nos indica que se pueden crear tareas y modificarlas vaciando la descripciÃ³n.

Ahora veamos cÃ³mo solucionar esto. Con la informaciÃ³n disponible no tenemos una pista sobre dÃ³nde hay que intervenir. 

Matizo: obviamente sabemos que hay que aÃ±adir una validaciÃ³n en el mÃ©todo `updateDescription` que hemos aÃ±adido en `Task`. Sin embargo saltarnos los pasos sÃ³lo nos llevarÃ­a a generar *puntos ciegos* en el desarrollo. No basta con lanzar una excepciÃ³n desde `Task`, tenemos que asegurarnos de que el componente adecuado la captura y reacciona de la forma adecuada. Proceder sistemÃ¡ticamente nos ayudarÃ¡ a evitar estos riesgos.

De hecho, el componente que tiene la responsabilidad de comunicarse en primera instancia con el test de aceptaciÃ³n es el controlador y, como ya hemos visto, es quien produce el cÃ³digo de respuesta que evaluamos en el test de aceptaciÃ³n. Por tanto, es el primer lugar en el que vamos a intervenir. Por supuesto, definiendo con un test el comportamiento que esperamos.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private const TASK_ID = 1;

    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->updateTaskHandler = $this->createMock(UpdateTaskHandler::class);

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler,
            $this->updateTaskHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldFailWithBadRequestIfTaskDescriptionIsEmptyWhenUpdating(): void
    {
        $exceptionMessage = 'Task description should not be empty';
        $exception = new InvalidArgumentException($exceptionMessage);

        $this->updateTaskHandler
            ->method('execute')
            ->willThrowException($exception)
            ->with(1, '');


        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->modifyTask(1, $request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals($exceptionMessage, $body['error']);
    }

}
```

Al ejecutar el test en este nivel, vemos que falla porque se tira la excepciÃ³n y no se controla. Implementamos la gestiÃ³n de excepciones exactamente igual que en la acciÃ³n de crear.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler,
        UpdateTaskHandler $updateTaskHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
        $this->updateTaskHandler = $updateTaskHandler;
    }

    #Â ...
    
    public function markTaskCompleted(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        try {
            $this->markTaskCompletedHandler->execute($taskId, $payload['completed']);
        } catch (OutOfBoundsException $taskNotFound) {
            return new JsonResponse(['error' => $taskNotFound->getMessage()], Response::HTTP_NOT_FOUND);
        }

        return new JsonResponse('', Response::HTTP_OK);
    }

    public function modifyTask(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        try {
            $this->updateTaskHandler->execute($taskId, $payload['task']);
        } catch (\InvalidArgumentException $invalidTaskDescription) {
            return new JsonResponse(['error' => $invalidTaskDescription->getMessage()], Response::HTTP_BAD_REQUEST);
        }

        return new JsonResponse('', Response::HTTP_NO_CONTENT);
    }

    # ...
}
```

Esto hace que el test de controlador pase. Si chequeamos el test de aceptaciÃ³n vemos que sigue dando el mismo error.

El siguiente nivel es el caso de uso, que como hemos visto antes, es irrelevante porque simplemente dejarÃ¡ subir la excepciÃ³n. Como ya sabemos, es `Task`  quien se debe responsabilizar, asÃ­ que ahora es el momento de abordar ese cambio, definiendo el comportamiento deseado en el test:

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[â] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldUpdateDescription(): void
    {
        $expected = '[ ] 1. New Task Description';
        $task = new Task(1, 'Task Description');
        $task->updateDescription('New Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldFailUpdatingWithInvalidDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $task = new Task(1, 'Task Description');
        $task->updateDescription('');
    }
}
```

Al no haber nada implementado, el test fallarÃ¡.

Empezamos con una implementaciÃ³n bastante obvia:

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? 'â' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        if ($newTaskDescription === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $newTaskDescription;
    }
}
```

El test unitario de `Task` ya estÃ¡ en verde. Antes de nada, volvemos a lanzar el test de aceptaciÃ³n para ver si hemos resuelto el problema y no nos hemos dejado ningÃºn cabo suelto. Y todo funciona.

Sin embargo, podrÃ­amos refactorizar un poco nuestra soluciÃ³n, ya que estamos intentando mantener la misma regla de negocio en dos lugares. DeberÃ­amos unificarlo. Para ello utilizaremos auto-encapsulaciÃ³n. Es decir, crearemos un mÃ©todo privado con el cual asignar el valor de la descripciÃ³n y validarlo. AsÃ­ queda `Task` con este cambio.

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        
        $this->setDescription($description);

        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? 'â' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        $this->setDescription($newTaskDescription);
    }

    private function setDescription(string $description): void
    {
        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
    }
}
```

Y con esto, hemos implementado la nueva historia de usuario. Te habrÃ¡s dado cuenta de que en todos los casos, ya sean nuevas historias de usuario, modificaciÃ³n de prestaciones o correcciÃ³n de defectos, nuestro procedimiento es siempre el mismo. Definir el comportamiento deseado del sistema mediante un test y aÃ±adir el cÃ³digo de producciÃ³n que sea necesario para hacerlo pasar.


