# Adding new features

In the previous chapter we talked about that, from the point of view of TDD-based development, all of the defects can almost be considered as *features* that just weren't defined initially. Another way of looking at it is that they're called *features* if we're asked for them explicitly, and defects if they're implicit in another *feature*, but haven't been developed.

That is, when we say that we want to be able to mark a task as completed, to follow up with out to-do list project, we can assume that the system mustn't break if we try to mark an inexistent task. For this reason, we'd say that this *feature* had a bug, and that's precisely what we fixed in the previous chapter.

But in this chapter, we'll tackle how to add new features to existing software by following a TDD approach. And, as it could be expected, we're not actually going to make any change to our methodology. We'll still be starting with an acceptance test, and delving deeper into the application and the necessary changes.

All in all, it's a different scenario. A new behavior might require us to modify existing software units, and we need to make sure that the changes don't break any of the already created functionality.

## New user story

The next business requirement is to allow to edit an existing task.

### US-4

* As a user
* I want to modify a existing task in the list
* So that, I can express my ideas better

Initially, this story requires the creation of a new *endpoint* with which to change a task's information.

```
PUT /api/todo/{taskId}
```

If our application has a *front-end*, we might need an *endpoint* to recover the information of the task that we wish to edit, with the purpose of filling out the form with the current data. In this case, it would be:

```
GET /api/todo/{taskId}
```

In both cases, the procedure will be the same: we'll begin by creating an acceptance test, initiating the development process. What we will find is that some of the necessary components are already created.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    public function asUserIWantToModifyAnExistingTask(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $this->client->request(
            'PUT',
            '/api/todo/2',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 'Write production code to make the test pass'], JSON_THROW_ON_ERROR)
        );

        $putResponse = $this->client->getResponse();
        
        self::assertEquals(204, $putResponse->getStatusCode());

        $response = $this->whenIRequestTheListOfTasks();
        $this->thenICanSeeAddedTasksInTheList(
            [
                '[ ] 1. Write a test that fails',
                '[ ] 2. Write production code to make the test pass',
            ],
            $response
        );
    }
    
    # ...
}
```

So, we run the test to see what it tells us. As expected, the *endpoint* cannot be found because we don't have the route, so we start by defining it.

```yaml
api_add_task:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::addTask
  methods: ['POST']

api_get_task_list:
  path: /api/todo
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::getTaskList
  methods: ['GET']

api_mark_task_completed:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::markTaskCompleted
  methods: ['PATCH']

api_edit_task:
  path: /api/todo/{taskId}
  controller: App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::modifyTask
  methods: ['PUT']
```

When rerunning the test after this change, it'll tell us that there isn't any action in the controller that's able to respond to this route.

```
"The controller for URI "/api/todo/2" is not callable. Expected method "modifyTask"
```

So we'll have to add a new empty action.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    # ...
    
    public function modifyTask(int $taskId, Request $request): Response
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }

    # ...
}
```

In the new execution of the test, the error will be:

```
RuntimeException: "Implement App\TodoList\Infrastructure\EntryPoint\Api\TodoListController::modifyTask"
```

Which tells us that we have to dive into the unit level to implement this action in the controller. This cycle will ring a bell, because it's what we've been doing in all this part of the book.

But the truth is that this routine is something positive. We always have a concrete task to tackle at every moment, be it creating a test or writing production code, and we don't have to worry about anything else. The acceptance test tells us what to do, and at each level we just have to think about the specific component that we're working on.

It's time for us to implement the controller. As we already know, at this stage we have to design. Basically, it's a similar action to adding a task, but in this case we'll receive the id of the task that we're going to modify, as well as its new description.

We'll need a use case that expresses this user intention, to which we'll pass the two pìeces of data that we need. If everything goes as planned, we'll return the 204 response (no content).

We add a test that encompasses all this:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private const TASK_ID = 1;

    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->updateTaskHandler = $this->createMock(UpdateTaskHandler::class);

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler,
            $this->updateTaskHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldModifyATask(): void
    {
        $this->updateTaskHandler
            ->expects(self::once())
            ->method('execute')
            ->with(self::TASK_ID, self::TASK_DESCRIPTION);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => self::TASK_DESCRIPTION], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->modifyTask(self::TASK_ID,$request);

        self::assertEquals(204, $response->getStatusCode());
    }

    # ...
}
```

If we run the test, it will ask us to create the `UpdateTaskHandler` use case.

```php
namespace App\TodoList\Application;

class UpdateTaskHandler
{
}
```

And next, it will ask for the `execute` method.

```php
namespace App\TodoList\Application;

class UpdateTaskHandler
{
    public function execute()
    {
        throw new \RuntimeException(sprintf('Implement %s', __METHOD__));
    }
}
```

Once we have that, it again asks us to implement the controller's action. So we get to it:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler,
        UpdateTaskHandler $updateTaskHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
        $this->updateTaskHandler = $updateTaskHandler;
    }

    # ...

    public function modifyTask(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->updateTaskHandler->execute($taskId, $payload['task']);

        return new JsonResponse('', Response::HTTP_NO_CONTENT);
    }

    # ...
}
```

And the controller's unit test passes. If we return to the acceptance test, as we should be doing now, it'll tell us what we have to do next:

```
RuntimeException: "Implement App\TodoList\Application\UpdateTaskHandler::execute"
```

So, it's time to get into the application layer. Again, we have to design this level, which poses an interesting problem.

In principle, we have defined that the field of the task that can be changed is just its description. Therefore, this action has to respect the current stated of the completed flag. So what we want is to recover the stored task, modify its description, and save it.

Therefore, we'll ask the repository for the task, we'll change it, and we'll store it again.

```php
namespace App\Tests\TodoList\Application;

use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use PHPUnit\Framework\TestCase;

class UpdateTaskHandlerTest extends TestCase
{

    private const TASK_ID = 1;

    public function testShouldUpdateATask(): void
    {
        $task = new Task(self::TASK_ID, 'Task Description');
        $taskRepository = $this->createMock(TaskRepository::class);
        $taskRepository
            ->method('retrieve')
            ->with(self::TASK_ID)
            ->willReturn($task);
        $taskRepository
            ->expects(self::once())
            ->method('store')
            ->with(new Task(self::TASK_ID, 'New Task Description'));

        $updateTaskHandler = new UpdateTaskHandler($taskRepository);

        $updateTaskHandler->execute(self::TASK_ID, 'New Task Description');
    }
}
```

When we run the test, it will ask us to implement the use case, as the repository had already been defined previously.

The implementation will surely force us to introduce some new method in `Task`, making a way for the description to be updated. This one, for example:

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\TaskRepository;

class UpdateTaskHandler
{

    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, string $newTaskDescription): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        $task->updateDescription($newTaskDescription);

        $this->taskRepository->store($task);
    }
}
```

I've chosen this implementation to simplify. However, as I write this, I can come up some ideas that could be interesting in a realistic use case. One of them could be to apply a certain immutability, that is, instead of updating the `Task` object, we'd create a new one filled out with new values.

But we'll leave those refinements for another occasion. If the run the test, it'll tell us that `Task` is lacking the `updateDescription` method, which we'll have to develop with the help of a unit test.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldUpdateDescription(): void
    {
        $expected = '[ ] 1. New Task Description';
        $task = new Task(1, 'Task Description');
        $task->updateDescription('New Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

}
```

To make the test pass, we have to introduce the method.

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        $this->description = $newTaskDescription;
    }
}
```

The test passes, but we've noticed a problem. ∑

El test pasa, pero nos hemos dado cuenta un problema. Hace nada hemos implementado una validación para impedir que `Task::description` pueda ser una cadena vacía. Para asegurar que cumplimos esta regla de negocio, deberíamos introducir otro test que lo verifique e implementar la respuesta que queramos dar a este caso.

Sin embargo esto no lo hemos cubierto en el nivel de aceptación o en el del controlador. ¿Qué deberíamos hacer entonces? ¿Resolverlo ahora y añadir tests en los otros niveles después o esperar y añadir esa protección en una nueva iteración?

Personalmente creo que la mejor respuesta es tomar nota de esto y resolverlo en un nuevo ciclo. Es importante centrarnos ahora en la característica que estamos desarrollando y terminar este ciclo.

Por tanto, al hacer pasar el test unitario de `Task`, volvemos primero al test de `UpdateTaskHandler` y comprobamos si ya pasa, cosa que ocurre.

Y con este nivel en verde, probamos de nuevo en el de aceptación, que también pasa sin más problemas.

El resultado es que la nueva historia está implementada, aunque como hemos descubierto necesitamos hacer una iteración para prevenir el problema de intentar cambiar las descripción de una historia con un valor no válido.

¿Lo hubiésemos podido prevenir antes? Puede ser, sin embargo, igualmente necesitaríamos introducir tests en los distintos niveles, al igual que hicimos en el capítulo anterior. El valor de usar TDD es justamente desarrollar una serie de hábitos de pensamiento y una cierta automatización. En otras palabras, desarrollar una disciplina y llegar a todos los objetivos paso a paso.

## Completar la historia

En cualquier caso, todo nuevo comportamiento del sistema tendría que estar definido mediante un test. Así que necesitaremos un test para incluir el cumplimiento de la regla de negocio, lo que nos lleva de nuevo al nivel de aceptación.

Puesto que es una regla de negocio, este test lo conservaremos después.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ..

    /** @test */
    public function asUserITryToUpdateTaskWithAnEmptyTaskDescription(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $this->client->request(
            'PUT',
            '/api/todo/1',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Task description should not be empty', $body['error']);
    }

    # ...
}
```


El test falla:

```
Failed asserting that 204 matches expected 400.
```

Lo que nos indica que se pueden crear tareas y modificarlas vaciando la descripción.

Ahora veamos cómo solucionar esto. Con la información disponible no tenemos una pista sobre dónde hay que intervenir. 

Matizo: obviamente sabemos que hay que añadir una validación en el método `updateDescription` que hemos añadido en `Task`. Sin embargo saltarnos los pasos sólo nos llevaría a generar *puntos ciegos* en el desarrollo. No basta con lanzar una excepción desde `Task`, tenemos que asegurarnos de que el componente adecuado la captura y reacciona de la forma adecuada. Proceder sistemáticamente nos ayudará a evitar estos riesgos.

De hecho, el componente que tiene la responsabilidad de comunicarse en primera instancia con el test de aceptación es el controlador y, como ya hemos visto, es quien produce el código de respuesta que evaluamos en el test de aceptación. Por tanto, es el primer lugar en el que vamos a intervenir. Por supuesto, definiendo con un test el comportamiento que esperamos.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private const TASK_ID = 1;

    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->updateTaskHandler = $this->createMock(UpdateTaskHandler::class);

        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler,
            $this->updateTaskHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldFailWithBadRequestIfTaskDescriptionIsEmptyWhenUpdating(): void
    {
        $exceptionMessage = 'Task description should not be empty';
        $exception = new InvalidArgumentException($exceptionMessage);

        $this->updateTaskHandler
            ->method('execute')
            ->willThrowException($exception)
            ->with(1, '');


        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->modifyTask(1, $request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals($exceptionMessage, $body['error']);
    }

}
```

Al ejecutar el test en este nivel, vemos que falla porque se tira la excepción y no se controla. Implementamos la gestión de excepciones exactamente igual que en la acción de crear.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\UpdateTaskHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;
    private UpdateTaskHandler $updateTaskHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler,
        UpdateTaskHandler $updateTaskHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
        $this->updateTaskHandler = $updateTaskHandler;
    }

    # ...
    
    public function markTaskCompleted(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        try {
            $this->markTaskCompletedHandler->execute($taskId, $payload['completed']);
        } catch (OutOfBoundsException $taskNotFound) {
            return new JsonResponse(['error' => $taskNotFound->getMessage()], Response::HTTP_NOT_FOUND);
        }

        return new JsonResponse('', Response::HTTP_OK);
    }

    public function modifyTask(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        try {
            $this->updateTaskHandler->execute($taskId, $payload['task']);
        } catch (\InvalidArgumentException $invalidTaskDescription) {
            return new JsonResponse(['error' => $invalidTaskDescription->getMessage()], Response::HTTP_BAD_REQUEST);
        }

        return new JsonResponse('', Response::HTTP_NO_CONTENT);
    }

    # ...
}
```

Esto hace que el test de controlador pase. Si chequeamos el test de aceptación vemos que sigue dando el mismo error.

El siguiente nivel es el caso de uso, que como hemos visto antes, es irrelevante porque simplemente dejará subir la excepción. Como ya sabemos, es `Task`  quien se debe responsabilizar, así que ahora es el momento de abordar ese cambio, definiendo el comportamiento deseado en el test:

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldUpdateDescription(): void
    {
        $expected = '[ ] 1. New Task Description';
        $task = new Task(1, 'Task Description');
        $task->updateDescription('New Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldFailUpdatingWithInvalidDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $task = new Task(1, 'Task Description');
        $task->updateDescription('');
    }
}
```

Al no haber nada implementado, el test fallará.

Empezamos con una implementación bastante obvia:

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        if ($newTaskDescription === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $newTaskDescription;
    }
}
```

El test unitario de `Task` ya está en verde. Antes de nada, volvemos a lanzar el test de aceptación para ver si hemos resuelto el problema y no nos hemos dejado ningún cabo suelto. Y todo funciona.

Sin embargo, podríamos refactorizar un poco nuestra solución, ya que estamos intentando mantener la misma regla de negocio en dos lugares. Deberíamos unificarlo. Para ello utilizaremos auto-encapsulación. Es decir, crearemos un método privado con el cual asignar el valor de la descripción y validarlo. Así queda `Task` con este cambio.

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;
        
        $this->setDescription($description);

        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }

    public function updateDescription(string $newTaskDescription): void
    {
        $this->setDescription($newTaskDescription);
    }

    private function setDescription(string $description): void
    {
        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
    }
}
```

Y con esto, hemos implementado la nueva historia de usuario. Te habrás dado cuenta de que en todos los casos, ya sean nuevas historias de usuario, modificación de prestaciones o corrección de defectos, nuestro procedimiento es siempre el mismo. Definir el comportamiento deseado del sistema mediante un test y añadir el código de producción que sea necesario para hacerlo pasar.


