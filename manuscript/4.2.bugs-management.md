# Fixing bugs with TDD

In our to-do list project, we've developed what we could call the application's *happy path*. That is, we've assumed that, when trying to create a task, the consumer of the API wouldn't make mistakes such as trying to create a task without a name. Another assumption is that, when marking a task as completed, the system will only use ids from existing tasks on the list.

This means that the application might fail if any of these assumptions isn't met. Is this a bug? In a sense, yes, but we could also argue that they're just features that haven't been implemented yet.

When we develop using TDD we can prevent many defects due to faulty implementations. For example, imagine that we haven't implemented a `Task::markComplete` method, and we don't have any test that tries to call it. The result will be a *bug*.

Of course, if we haven't written a test to verify a specific behavior, as it could be preventing the creation of tasks without description, the bug will end up surfacing.

It's said that neither testing nor TDD rid us of every fault in a piece of software. Nevertheless, I think that we can rest assured that by using TDD, the defects will appear in those parts that aren't covered by a test. If we look at them through this lens, therefore, bugs are actually unforeseen circumstances and unimplemented cases. This is as interesting as it is liberating, because in a certain sense, it makes the software flaws quite predictable and manageable, motivated by a lack of definition, or simply by a lack of information at the time of development.

So, let's see how we would proceed in the case that a bug about our to-do list project was reported.

## To-do list bugs

After some time using our API to generate task lists, we find a few defects. One of them is that we're able to enter tasks that don't have a description, which doesn't make much sense, as it's not very useful if we want to know what we have to do.

This bug is due to the fact that we're not controlling at any point that we're actually receiving the description of the task, that is, we're trusting that the input is always correct. In that case, there's two possibilities: that the *payload* of the request to the POST *endpoint* is completely empty, or that the `task` field is blank.

In this occasion, the system doesn't have any specified behavior for these circumstances, nor is it expressed in the tests. In other cases, the bug is some kind of error not covered by the current tests.

So our first approach will be to create a test that exposes the bug.

Now then, where do we want to put that test? Let's try and think a little about this.

On the one hand, the affected *endpoints* should return a 400 response (*Bad Request*) because in this case, that happens is that the *request* is badly constructed and the *endpoint* doesn't understand it.

According to this, it would make sense to add an acceptance test. However, we also have the controller's unit tests, which are much faster and would also allow us to verify that the response has the correct code.

On the other hand, we have to take into consideration which component is responsible of validating which questions.

So, for example, if the *request* doesn't have any *payload* or the structure doesn't include the required fields, it makes sense for the controller to be responsible of verifying it and failing as soon as it detects it. The test makes sense at the controller level.

However, if the *request* has the correct structure and the required fields can be found, the validation of its values may correspond to more inner layers. Thus, for example, if the value of `task` in the *payload* is an empty string, the controller may try to pass it to the use case, and let the `Task` constructor validate whether that value is acceptable or not. The test, in this case, would be at the `AddTaskHandler` use case level.

This, however, opens up a new predicament for the controller, and that is handling the errors or exceptions that come from the use case in order to return the appropriate error response.

As you can see, a bunch of circumstances arise and force us to intervene at different levels of the application.

One principle that we could try following is that if something goes wrong at the acceptance level, it should be reflected at the unit level. The first error tells us that the application has a defect, while the error at the unit level tells us which one is the component that's failing. 

So, let's go bit by bit, tackling each of the problems.

## Invalid payload

The case that we'll be trying to handle and solve is sending an empty or badly formed request to the *endpoint*. In any case, it doesn't include the `task` field.

We'll start with the acceptance test, and we'll try to reproduce the error by launching a request to the API with an invalid payload.


```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

	// ...
	
    /** @test */
    public function asUserITryToAddTaskWithInvalidPayload(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['bad payload'], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

	// ...
}
```

The test fails because the *endpoint* returns a 500 error instead of the 400 error that would be desireable in this case. What can we do now?

Well, we'll move to the controller level to see what can we do there. And we'll have to write another test characterizing the same situation.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }


    // ...

     /** @test */
    public function shouldFailWithBadRequestIfInvalidPayload(): void
    {
        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['invalid payload'], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

}

```

Note that I've removed the expectations about the `mock` of the use case. In my opinion, it's a test that wouldn't add anything in this case, and contributes to the coupling to the implementation. It's true that the same happens in all of the controller tests that we have so far, but there's no reason to deliberately increase the coupling if we can avoid it.

When we run the test, it fails because it can no longer find the `task` index when it needs it in `TodoListController`:

```php
    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }
```

This is part of the controller's logic, so we're not going to need to go any deeper. If we fix it here, we'll have solved the problem.

It seems pretty clear that we have to check is the *payload* has the correct structure, and respond consequently:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!isset($payload['task'])) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    # ...
}
```

Having passed the controller test, we return to the acceptance one. We run them all, and we check that they also pass perfectly.

And with that, we've solved the *bug*.

## Invalid business values

One thing is that the *payload* is incorrect structurally, a validation that corresponds to the controller. However, given a structurally valid *payload* in which the controller is able to find all of the fields it needs, what happens if the values aren't acceptable according to the business rules?

What happens is that the responsibility of detecting the problem lies in the domain objects, which will throw exceptions that should bubble up the application until some component is able to handle them.

For example, in the case of `Task`, we expect it to have a description. It hasn't been defined in the user stories, but it's something that we just assume. It may happen, then, that the *payload* comes with a `task` field containing any of these values: 

* `null`
* A data type that isn't `string`
* An empty or too short string
* A string of sufficient length

The first two points are particularly technical. At the controller level, we could validate that `task` is a `string` and fail if it isn't.

However, the last two point to rules that must be defined by the business. That is to say, would we consider acceptable a task with a two-character description? It's a business decision. Let's assume that we're told that one character is enough to accept a string as a valid description, so we'll only have to control that it's not an empty string.

This rule, in any case, belongs to the domain because it's a business rule.

The location of the previous two restrictions is more open to debate, which may be summarizes as "the system cannot accept `task` if it's not a `string`".

But it's best to see this from the point of view of a test, so let's introduce one. In this case, to see what happens if `task` is `null`:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToAddTaskWithABadTaskDescription(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => null], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

    # ...
}
```

It's very interesting to check that this test passes. Probably, fixing the previous bug has prevented us from running into this one.

Is it worth it to leave this test here? I'd say no, as we haven't had to add anything to the code. I'll make use of it by trying to see what would happen if we sent non-string data, like a number.

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToAddTaskWithABadTaskDescription(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 12345], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }

    # ...
}
```

This test fails for the following reason:

```
TypeError : Argument 1 passed to App\TodoList\Application\AddTaskHandler::execute() must be of the type string, int given
```

That is. `AddTaskHandler` expects us to pass a `string` in `execute`, so it's never going to admit a value that isn't one. This poses an interesting problem: are we interested in forcing the `string` type for the description, so that if a number comes -as is the case-, it converts it and moves on?

In this example we're going to assume that we don't want that, that the type must be `string` no matter what.

As we've seen, the failure has also been produced in the controller, when trying to invoke the use case. Thereby, we go back to the controller test.

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }

    # ...

    /** @test */
    public function shouldFailWithBadRequestIfInvalidTaskField(): void
    {
        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => 12345], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Invalid payload', $body['error']);
    }
}
```

The controller test fails in the same way as the acceptance test. Next, we implement what's necessary to make it pass.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!isset($payload['task'])) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        if (!is_string($payload['task'])) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    # ...
}
```

This change makes the test pass, and it's to be expected that it also makes the acceptance one pass, so we check it. Remember: it's very important to pass all the tests every time, not only the one specific to the case, as we have to make sure that the changes that we introduce don't alter the current behavior of the system.

The acceptance test also passes. Now we have to think about a couple of things.

On the one hand, the code that we've introduced is a little ugly, and it distracts us from the controller's purpose. We need to refactor and clear things up a bit.

This is one possible solution:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!$this->isValidPayload($payload)) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        $this->addTaskHandler->execute($payload['task']);

        return new JsonResponse('', Response::HTTP_CREATED);
    }

    # ...

    private function isValidPayload(array $payload): bool
    {
        return isset($payload['task']) && is_string($payload['task']);
    }
}
```

It's a first approach. We could advance it further, but it's enough for now.

The other issue is the following. The acceptance tests that we've added have been useful to reproduce the bugs and guide us towards their solution. However, at the controller's unit level, we've made practically the same test. What's more, the acceptance test verifies exactly the same behavior as the controller one, as it's over the latter where all of the responsibility about this behavior lies.

This duplication isn't always useful. In fact, the business, which is only interested in the acceptance test, is not very worried about the kind of technical issues that we're verifying. On the other hand, at the unit level, this kind of detail is more relevant.

So, in case of having tests at the acceptance level that are identical to others at the unit level, it's preferable to delete the acceptance ones if they're not bringing in any business value, having covered the same circumstance in the unit ones.

So we're going to delete those tests before continuing.


## Guaranteeing business rules

Our next test will verify that an empty description, even if it's a `string`, will not generate a new task. We'll put it in the acceptance test:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToAddTaskWithAnEmptyTaskDescription(): void
    {
        $this->client->request(
            'POST',
            '/api/todo',
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->client->getResponse();

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals('Task description should not be empty', $body['error']);
    }

    # ...
}

```

This test already indicates the violation of a business rule. This is the error that generates:

```
Failed asserting that 201 matches expected 400.
Expected :400
Actual   :201
```

It tells us that tasks with empty description would be created as if they were valid. We have to go deeper into the application to see where we should be controlling the error.

So we go to the controller. But it mustn't know anything about the business rules, as it lives in the Infrastructure layer. Nevertheless, it has to give the appropriate HTTP response, and that's only possible is the use case somehow communicates to it that there's been a problem.

The best way for it to do so is to throw an exception that the controller will capture, returning an adequate response.

This way, the controller test might end up like this:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }
    
    # ...
    
    /** @test */
    public function shouldFailWithBadRequestIfTaskDescriptionIsEmpty(): void
    {
        $exceptionMessage = 'Task description should not be empty';
        $exception = new InvalidArgumentException($exceptionMessage);
        
        $this->addTaskHandler
            ->method('execute')
            ->willThrowException($exception)
            ->with('');


        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['task' => ''], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->addTask($request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals($exceptionMessage, $body['error']);
    }
}
```

As you can see we simulate the use case throwing an exception, and the test fails because it doesn't get captured, and therefore an adequate response isn't returned. To not complicate the solution too much, I'm not going to create a domain exception (but it's something that I would do in a real project).

Let's pass this test.

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;


use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    public function addTask(Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        if (!$this->isValidPayload($payload)) {
            return new JsonResponse(['error' => 'Invalid payload'], Response::HTTP_BAD_REQUEST);
        }

        try {
            $this->addTaskHandler->execute($payload['task']);
        } catch (InvalidArgumentException $invalidTaskDescription) {
            return new JsonResponse(['error' => $invalidTaskDescription->getMessage()], Response::HTTP_BAD_REQUEST);
        }

        return new JsonResponse('', Response::HTTP_CREATED);
    }

   # ...
}

```
The controller unit test has passed. However, the acceptance test has not. This is because we haven't touched the use case yet. We have to go down a bit further and write a test that can fail to tell us what to implement.

But first, let's examine the code:

```php
namespace App\TodoList\Application;

use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;

class AddTaskHandler
{
    /** @var TaskRepository */
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(string $taskDescription): void
    {
       $id = $this->taskRepository->nextIdentity();

       $task = new Task($id, $taskDescription);

       $this->taskRepository->store($task);
    }
}
```

As it can be seen, the point at which the exception should be thrown, is when a `Task` is created, but there's no reason for the use case to be the one who verifies that `$taskDescription` has a sufficient length.

Instead, it makes more sense that this logic is in `Task`. After all, the use case is not the place to apply business rules, but rather to coordinate domain objects, which are the ones that have the responsibility to maintain them.

So, we'd have to dive a little deeper, and modify the `Task` test to guarantee that it's always constructed consistently, with a description at least one character long. In the case that the description is empty, we'll throw the exception.

```php
namespace App\Tests\TodoList\Domain;

use App\TodoList\Domain\Task;
use PHPUnit\Framework\TestCase;
use InvalidArgumentException;

class TaskTest extends TestCase
{
    /** @test */
    public function shouldNotAllowEmptyDescription(): void
    {
        $this->expectException(InvalidArgumentException::class);

        new Task(1, '');
    }

    /** @test */
    public function shouldProvideRepresentation(): void
    {
        $expected = '[ ] 1. Task Description';
        $task = new Task(1, 'Task Description');

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }

    /** @test */
    public function shouldMarkTaskCompleted(): void
    {
        $expected = '[√] 1. Task Description';
        $task = new Task(1, 'Task Description');
        $task->markCompleted();

        $representation = $task->representedAs('[:check] :id. :description');

        self::assertEquals($expected, $representation);
    }
}
```

All that's left is to implement it.

```php
namespace App\TodoList\Domain;

use InvalidArgumentException;

class Task
{
    private int $id;
    private string $description;
    private bool $completed;

    public function __construct(int $id, string $description)
    {
        $this->id = $id;

        if ($description === '') {
            $exceptionMessage = 'Task description should not be empty';
            throw new InvalidArgumentException($exceptionMessage);
        }

        $this->description = $description;
        $this->completed = false;
    }

    public function id(): int
    {
        return $this->id;
    }

    public function representedAs(string $format): string
    {
        $values = [
            ':check' => $this->completed ? '√' : ' ',
            ':id' => $this->id,
            ':description' => $this->description
        ];
        return strtr($format, $values);

    }

    public function markCompleted(): void
    {
        $this->completed = true;
    }
}
```

This implementation is enough to pass the unit test. Let's see if the test at the other level also pass. Indeed, all of the unit tests keep passing, and so does the acceptance one.

We'll leave the acceptance test that we've just introduced, as it carries business meaning. Moreover, in this case the controller test only verifies that it's able to handle the exception thrown by the domain layer, while the `Task` test verifies that it has to be constructed with a valid description.

## Not found tasks

Another of our app's defects has to do with trying to mark as completed an inexistent task. Currently, the endpoint will return a 500 error, when the correct one would be a 404 indicating that the resource that we're trying to modify doesn't exist.

The following acceptance test puts a spotlight on it:

```php
namespace App\Tests\Katas\TodoList;

use Symfony\Bundle\FrameworkBundle\Client;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class TodoListAcceptanceTest extends WebTestCase
{
    private Client $client;

    # ...
    
    /** @test */
    public function asUserITryToMarkNotExistentTasksAsCompleted(): void
    {
        $this->givenIHaveAddedTasks(
            [
                'Write a test that fails',
                'Write code to make the test pass',
            ]
        );

        $response = $this->apiMarkTaskCompleted(3);

        self::assertEquals(404, $response->getStatusCode());
    }
    
    # ...
}

```

The result is:

```
Failed asserting that 500 matches expected 404.
```

Apart from an error in:

```
"Undefined offset: 3" at /application/src/TodoList/Infrastructure/Persistence/FileTaskRepository.php
```

The base error occurs in the repository. However, we're going to proceed systematically. As we've seen in the last example, the error can manifest itself in several manners in the different layers or levels of the application, so we have to go step by step, decide if that error has to be manifested in some way, and implement the necessary behavior.

The controller, as seen previously, is responsible of interpreting the problem and express it as a 404 error in the response. Therefore, it expects the use case to communicate it with an exception. In practice, it means that the controller has to react to a specific exception that will be thrown or rethrown by the use case.

So we express this with a test:

```php
namespace App\Tests\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use App\TodoList\Infrastructure\EntryPoint\Api\TodoListController;
use InvalidArgumentException;
use PHPUnit\Framework\TestCase;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\Request;

class TodoListControllerTest extends TestCase
{
    private const TASK_DESCRIPTION = 'Task Description';
    private const COMPLETED_TASK_ID = 1;
    private AddTaskHandler $addTaskHandler;
    private TodoListController $todoListController;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    protected function setUp(): void
    {
        $this->addTaskHandler = $this->createMock(AddTaskHandler::class);
        $this->getTaskListHandler = $this->createMock(GetTaskListHandler::class);
        $this->taskListTransformer = $this->createMock(TaskListTransformer::class);
        $this->markTaskCompletedHandler = $this->createMock(MarkTaskCompletedHandler::class);
        $this->todoListController = new TodoListController(
            $this->addTaskHandler,
            $this->getTaskListHandler,
            $this->taskListTransformer,
            $this->markTaskCompletedHandler
        );
    }

    # ...
    
    /** @test */
    public function shouldFailWithNotFoundIdCompletingNotExistentTask(): void
    {
        $exceptionMessage = 'Task 3 doesn\'t exist';
        $exception = new OutOfBoundsException($exceptionMessage);

        $this->markTaskCompletedHandler
            ->method('execute')
            ->willThrowException($exception);

        $request = new Request(
            [],
            [],
            [],
            [],
            [],
            ['CONTENT-TYPE' => 'json/application'],
            json_encode(['completed' => true], JSON_THROW_ON_ERROR)
        );

        $response = $this->todoListController->markTaskCompleted(self::COMPLETED_TASK_ID, $request);

        self::assertEquals(400, $response->getStatusCode());

        $body = json_decode($response->getContent(), true);

        self::assertEquals($exceptionMessage, $body['error']);
    }

}
```

As expected, the controller test will fail because the exception simulated in the *mock* isn't being captured. It's time to implement the code to do so:

```php
namespace App\TodoList\Infrastructure\EntryPoint\Api;

use App\TodoList\Application\AddTaskHandler;
use App\TodoList\Application\GetTaskListHandler;
use App\TodoList\Application\MarkTaskCompletedHandler;
use App\TodoList\Application\TaskListTransformer;
use InvalidArgumentException;
use OutOfBoundsException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use function is_string;

class TodoListController
{
    private AddTaskHandler $addTaskHandler;
    private GetTaskListHandler $getTaskListHandler;
    private TaskListTransformer $taskListTransformer;
    private MarkTaskCompletedHandler $markTaskCompletedHandler;

    public function __construct(
        AddTaskHandler $addTaskHandler,
        GetTaskListHandler $getTaskListHandler,
        TaskListTransformer $taskListTransformer,
        MarkTaskCompletedHandler $markTaskCompletedHandler
    ) {
        $this->addTaskHandler = $addTaskHandler;
        $this->getTaskListHandler = $getTaskListHandler;
        $this->taskListTransformer = $taskListTransformer;
        $this->markTaskCompletedHandler = $markTaskCompletedHandler;
    }

    # ...
    
    public function markTaskCompleted(int $taskId, Request $request): Response
    {
        $payload = $this->obtainPayload($request);

        try {
            $this->markTaskCompletedHandler->execute($taskId, $payload['completed']);
        } catch (OutOfBoundsException $taskNotFound) {
            return new JsonResponse(['error' => $taskNotFound->getMessage()], Response::HTTP_NOT_FOUND);
        }

        return new JsonResponse('', Response::HTTP_OK);
    }

    # ...
}
```

Given that the test is now passing at the controller level, we go back to the acceptance test. This level still fails because, in fact, no exception is being actually thrown in this action's flow.

We need to go a bit deeper.

If we examine the Application layer, the use case doesn't have much to do. As in the previous problem, its job is to delegate domain objects, so it's those the ones who should fail. As I've pointed out before I'm using generic exceptions, but in real projects we'd be also using domain exceptions at different levels. For example, a `TaskNotFound`, that could perfectly be extending `OutOfBoundsException`.

So we won't do anything to the use case, but we observe that the responsible of saying whether a task exists or not will be the repository. The first line of the `execute` method is clear.

```php
namespace App\TodoList\Application;


use App\TodoList\Domain\TaskRepository;

class MarkTaskCompletedHandler
{
    private TaskRepository $taskRepository;

    public function __construct(TaskRepository $taskRepository)
    {
        $this->taskRepository = $taskRepository;
    }

    public function execute(int $taskId, bool $completed): void
    {
        $task = $this->taskRepository->retrieve($taskId);

        if ($completed) {
            $task->markCompleted();
        }

        $this->taskRepository->store($task);
    }
}
```

It's not worth it to write a test to simulate that the repository throws an exception and the use case does nothing. If the use case was capturing exceptions from a more inner level to rethrow them as a different exception -a technique that we could call *exception nesting*, then we would do it to verify that.

Since we're not doing that, we go to the repository level and we write a test:

```php
namespace App\Tests\TodoList\Infrastructure\Persistence;

use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use App\TodoList\Infrastructure\Persistence\FileTaskRepository;
use PHPUnit\Framework\TestCase;
use Symfony\Component\DependencyInjection\Exception\OutOfBoundsException;

class FileTaskRepositoryTest extends TestCase
{
    private FileStorageEngine $fileStorageEngine;
    private TaskRepository $taskRepository;

    public function setUp(): void
    {
        $this->fileStorageEngine = $this->createMock(FileStorageEngine::class);
        $this->taskRepository = new FileTaskRepository($this->fileStorageEngine);
    }

    # ...
    
    /** @test */
    public function shouldFailIfTaskNotFound(): void
    {
        $storedTasks = [
            1 => new Task(1, 'Write a test that fails'),
            2 => new Task(2, 'Write code to make the test pass'),
        ];

        $this->fileStorageEngine
            ->method('loadObjects')
            ->willReturn(
                $storedTasks
            );

        $this->expectException(OutOfBoundsException::class);
        $this->taskRepository->retrieve(3);
    }
}
```

The test fails, as the exception is not being thrown. So we go to the production code:

```php
namespace App\TodoList\Infrastructure\Persistence;


use App\Lib\FileStorageEngine;
use App\TodoList\Domain\Task;
use App\TodoList\Domain\TaskRepository;
use OutOfBoundsException;

class FileTaskRepository implements TaskRepository
{
    private FileStorageEngine $fileStorageEngine;

    public function __construct(FileStorageEngine $fileStorageEngine)
    {
        $this->fileStorageEngine = $fileStorageEngine;
    }

    # ...
    
    public function retrieve(int $taskId): Task
    {
        $tasks = $this->findAll();

        if (!isset($tasks[$taskId])) {
            throw new OutOfBoundsException(
                sprintf('Task %s doesn\'t exist', $taskId)
            );
        }

        return $tasks[$taskId];
    }

    # ...
}
```

With this simple solution we pass the test. We rerun the acceptance test to check that the problem is solved.

## Solving defects

An interesting conclusion about what we just did is that, in reality, solving bugs is nothing more that implementing an inexistent behavior in the software. In this context, I prefer using the term *defect* instead of *bug*.

What's more, it could be argued that this chapter, more than being about fixing *bugs*, is about adding features to the software that had been left behind either consciously or unconsciously. In real life, this kind of thing is usually reported as a *bug*, although we know that it's a *feature* that hasn't been developed yet, or one that we hadn't taken into account before.

In fact, by developing software using TDD, we normally prevent the kinds of defects that are usually associated to *bugs*, as it might be a typing problem, or some slip in the code that the language, for some reason, allows to go undetected.

In any case, the procedure is more or less the following:

* The first thing to do is reproduce the *bug* through a test at the most external level possible. Most likely it will manifest itself in the acceptance test, and it's what's expected if it's a problem that can be detected by the users. But it may depend on the context.
* Next, we go to the next level of the application, trying to reproduce the same *bug* with a unit test. There will be levels where this isn't possible and the test passes. As we've seen in the last example, the manifestation of the *bug* may be different in each level, or it may not happen at all. If we can't demonstrate the *bug* at that level, we advance to the next one.
* In each level, we implement code to pass the test that showcases the *bug*. Once that level's tests are green, we return to the acceptance test.
* If the acceptance test continues to fail, we'll have to go to a deeper level in the application, create a test that describes the *bug*, and solve it. After this, we go back to the acceptance level until the test passes again.
* The moment the acceptance test passes, the defect is fixed.

